This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Series,  Next: Teoría de Números,  Prev: atensor,  Up: Top

30 Series
*********

* Menu:

* Introducción a las series::
* Funciones y variables para las series::


File: maxima.info,  Node: Introducción a las series,  Next: Funciones y variables para las series,  Prev: Series,  Up: Series

30.1 Introducción a las series
==============================

Maxima dispone de las funciones `taylor' y `powerseries' para calcular
las series de las funciones diferenciables. También tiene herramientas
como `nusum' capaces de encontrar la expresión compacta de algunas
series. Operaciones como la suma y la multiplicación operan de la forma
habitual en el contexto de las series. Esta sección presenta las
variables globales que controlan la expansión.


File: maxima.info,  Node: Funciones y variables para las series,  Prev: Introducción a las series,  Up: Series

30.2 Funciones y variables para las series
==========================================

 -- Variable opcional: cauchysum
     Valor por defecto: `false'

     Cuando se multiplican sumatorios infinitos, si `sumexpand' vale
     `true' y `cauchysum' vale `true', entonces se utilizará el
     producto  de Cauchy en lugar del usual. En el producto de Cauchy
     el índice de la suma interna es función del índice de la exterior
     en lugar de variar de forma independiente. Un ejemplo aclara esta
     idea:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0


 -- Función: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     Para cada función <f_i> de variable <x_i>,  `deftaylor' define
     <expr_i> como una serie de Taylor alrededor de cero. La expresión
     <expr_i> será un polinomio en  <x_i> o una suma; `deftaylor'
     admite también expresiones más generales.

     La llamada `powerseries (<f_i>(<x_i>), <x_i>, 0)' devuelve la
     serie definida por  `deftaylor'.

     La función `deftaylor' evalúa sus argumentos y devuelve la lista
     de las funciones <f_1>, ..., <f_n>.

     Ejemplo:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200


 -- Variable opcional: maxtayorder
     Valor por defecto: `true'

     Si `maxtayorder' vale `true', entonces durante la manipulación
     algebraica de series truncadas de Taylor, la función `taylor'
     trata de retener tantos términos correctos como sea posible.


 -- Función: niceindices (<expr>)
     Cambia las etiquetas de los índices de sumas y productos de
     <expr>. La función `niceindices' trata de cambiar cada índice al
     valor de `niceindicespref[1]', a menos que esa etiqueta aparezca
     ya en el sumando o factor, en cuyo caso  `niceindices' realiza
     intentos con los siguientes elementos de  `niceindicespref', hasta
     que encuentre una variable que que no esté en uso. Si todas las
     variables de la lista han sido ya revisadas, se formarán nuevos
     ínices añadiendo números enteros al valor de `niceindicespref[1]',
     como `i0', `i1', `i2', ....

     La función `niceindices' evalúa sus argumentos y devuelve una
     expresión.

     Ejemplo:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1


 -- Variable opcional: niceindicespref
     Valor por defecto: `[i, j, k, l, m, n]'

     La variable `niceindicespref' es la lista de la que la función
     `niceindices' va tomando nombres de etiquetas para índices de
     sumatorios y productos.

     En `niceindicespref' se guardan normalmente nombres de variables.

     Ejemplo:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1


 -- Función: nusum (<expr>, <x>, <i_0>, <i_1>)
     Calcula la suma hipergeométrica indefinida de  <expr> con respecto
     a la variable  <x> utilizando una procedimiento de decisión debido
     a R.W. Gosper. La expresión <expr> y el resultado deben poder ser
     escritos como productos de potencias enteras, factoriales,
     coeficientes binomiales y funciones racionales.

     Los términos suma "definida" e "indefinida" se usan de forma
     análoga a integración "definida" e "indefinida". La suma
     indefinida significa dar un resultado simbólico.

     Las funciones `nusum' y `unsum' disponen de cierta información
     sobre sumas y diferencias de productos finitos. Véase también
     `unsum'.

     Ejemplos:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1


 -- Función: pade (<taylor_series>, <numer_deg_bound>,
          <denom_deg_bound>)
     Devuelve la lista de todas las funciones racionales que tienen el
     desarrollo de Taylor dado, en las que la suma de los grados del
     numerador y denominador es menor o igual que el nivel de
     truncamiento de la serie de potencias.

     La expresión <taylor_series> es una serie de Taylor univariante.
     Los argumentos <numer_deg_bound> y <denom_deg_bound> son enteros
     positivos que indican las cotas para numerador y denominador.

     La expresión <taylor_series> también puede ser una serie de
     Laurent, y las cotas de los grados pueden ser `inf'. El grado
     total se define como `<numer_deg_bound> + <denom_deg_bound>'. La
     longitud de una serie de potencias se define como `"truncation
     level" + 1 - min(0, "order of series")'.

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     No hay ninguna función racional de grado 4 en numerador y
     denominador con este desarrollo en serie de potencias. Es
     necesario dar un número de grados al numerador y denominador cuya
     suma sea al menos el grado del desarrollo de la serie, a fin de
     disponer de un número suficiente de coeficientes desconocidos para
     calcular.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]


 -- Variable opcional: powerdisp
     Valor por defecto: `false'

     Si `powerdisp' vale `true', se muestran las sumas con sus términos
     ordenados de menor a mayor potencia. Así, un polinomio se presenta
     como una serie de potencias truncada con el término constante al
     principio y el de mayor potencia al final.

     Por defecto, los términos de una suma se muestran en el orden de
     las potencias decrecientes.


 -- Función: powerseries (<expr>, <x>, <a>)
     Devuelve la forma general del desarrollo en serie de potencias de
     <expr> para la variable <x> alrededor del punto <a> (que puede ser
     `inf', de infinito).

     Si `powerseries' no es capaz de desarrollar <expr>, la función
     `taylor' puede calcular los primeros términos de la serie.

     Si `verbose' vale `true', `powerseries' va mostrando mensajes
     mientras progresa el cálculo.

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2


 -- Variable opcional: psexpand
     Valor por defecto: `false'

     Si `psexpand' vale `true', toda expresi'on racional se muestra
     completamente expandida. La variable `ratexpand' tiene el mismo
     efecto.

     Si `psexpand' vale `false', las expresines multivariantes se
     presentan tal como lo hace el paquete de funciones racionales.

     Si `psexpand' vale  `multi', los términos de igual grado son
     agrupados.


 -- Función: revert (<expr>, <x>)
 -- Función: revert2 (<expr>, <x>, <n>)
     Estas funciones devuelven el recíproco de <expr> en forma de
     desarrollo de Taylor alrededor de cero respecto de la variable
     <x>. La función `revert' devuelve un polinomio de grado igual a la
     mayor potencia en <expr>.  La función `revert2' devuelve un
     polinomio de grado <n>, el cual puede ser mayor, igual o menor que
     el grado de  <expr>.

     Para utilizar estas funciones es necesario cargarlas en memoria
     mediante `load ("revert")'.

     Ejemplos:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2


 -- Función: taylor (<expr>, <x>, <a>, <n>)
 -- Función: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Función: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Función: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- Función: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
          <n_2>], ...)
     La llamada `taylor (<expr>, <x>, <a>, <n>)' expande la expresión
     <expr> en un desarrollo  de  Taylor o de  Laurent respecto de la
     variable <x> alrededor del punto <a>, con términos hasta `(<x> -
     <a>)^<n>'.

     Si <expr> es de la forma `<f>(<x>)/<g>(<x>)' y `<g>(<x>)' no tiene
     términos hasta de grado <n>, entonces `taylor' intenta expandir
     `<g>(<x>)' hasta el grado  `2 <n>'. Si aún así no hay términos no
     nulos, `taylor' dobla el grado de la expansión de `<g>(<x>)' hasta
     que el grado de la expansión sea menor o igual que `<n>
     2^taylordepth'.

     La llamada `taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)'
     devuelve la serie en potencias truncada de grado  <n> en todas las
     variables <x_1>, <x_2>, ... alrededor del punto `(<a>, <a>, ...)'.

     La llamada `taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
     <n_2>], ...)' devuelve la serie en potencias truncada en las
     variables <x_1>, <x_2>, ... alrededor del punto `(<a_1>, <a_2>,
     ...)'; el truncamiento se realiza, respectivamente, en los grados
     <n_1>, <n_2>, ....

     La llamada `taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>,
     ...], [<n_1>, <n_2>, ...])' devuelve la serie en potencias
     truncada en las variables <x_1>, <x_2>, ... alrededor del punto
     `(<a_1>, <a_2>, ...)', el truncamiento se realiza,
     respectivamente, en los grados <n_1>, <n_2>, ....

     La llamada `taylor (<expr>, [<x>, <a>, <n>, 'asymp])' devuelve el
     desarrollo de  <expr> en potencias negativas de `<x> - <a>'. El
     término de mayor orden es `(<x> - <a>)^<-n>'.

     Si `maxtayorder' vale `true', entonces durante la manipulación
     algebraica de las series (truncadas) de Taylor, la función
     `taylor' intenta mantener tantos términos correctos como sea
     posible.

     Si `psexpand' vale `true', una expresión racional desarrollada se
     muestra completamente expandida. La variable  `ratexpand' tiene el
     mismo efecto. Si `psexpand' vale `false', una expresión
     multivariante se mostrará tal como lo hace el paquete de funciones
     racionales. Si  `psexpand' vale  `multi', los términos del mismo
     grado son agrupados.

     Véase también la variable `taylor_logexpand' para el control del
     desarrollo.

     Ejemplos:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360


 -- Variable opcional: taylordepth
     Valor por defecto: 3

     Si todavía no hay términos no nulos, la función `taylor' dobla el
     grado del desarrollo de `<g>(<x>)' tantas veces como sea necesario
     para que el grado del desarrollo sea menor o igual que `<n>
     2^taylordepth'.


 -- Función: taylorinfo (<expr>)
     Devuelve información sobre el desarrollo de Taylor <expr>. El
     valor devuelto por esta función es una lista de listas. Cada lista
     contiene el nombre de una variable, el punto de expansión y el
     grado del desarrollo.

     La función `taylorinfo' devuelve `false' si <expr> no es un
     desarrollo de Taylor.

     Ejemplo:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]


 -- Función: taylorp (<expr>)
     Devuelve `true' si <expr> es un desarrollo de Taylor y `false' en
     caso contrario.


 -- Variable opcional: taylor_logexpand
     Valor por defecto: `true'

     La variable `taylor_logexpand' controla los desarrollos de
     logaritmos en la función `taylor'.

     Si `taylor_logexpand' vale `true', todos los logaritmos se
     expanden completamente de manera que algunos problemas que se
     plantean debido a ciertas identidades logarítmicas no interfieran
     con el proceso del cálculo del desarrollo de Taylor. Sin embargo,
     este proceder no es del todo correcto.


 -- Variable opcional: taylor_order_coefficients
     Valor por defecto: `true'

     La variable `taylor_order_coefficients' controla la ordenación de
     los coeficientes en un desarrollo de Taylor.

     Si `taylor_order_coefficients' vale `true', los coeficientes del
     desarrollo de Taylor se ordenan de la forma canónica.


 -- Función: taylor_simplifier (<expr>)
     Simplifica los coeficientes de la serie de potencias <expr>. Esta
     función es llamada desde la función `taylor'.


 -- Variable opcional: taylor_truncate_polynomials
     Valor por defecto: `true'

     Si `taylor_truncate_polynomials' vale `true', los polinomios
     quedan truncados en base a los niveles de truncamiento de entrada.

     En otro caso, aquellos polinomios que se utilicen como entrada a
     la función  `taylor' se consideran que tienen precisión infinita.


 -- Función: taytorat (<expr>)
     Convierte <expr> del formato de `taylor' al formato CRE (Canonical
     Rational Expression). El efecto es el mismo que haciendo  `rat
     (ratdisrep (<expr>))', pero más rápido.


 -- Función: trunc (<expr>)
     Devuelve la representación interna de la expresión <expr> de tal
     forma como si sus sumas fuesen una serie truncada de Taylor. La
     expresión <expr> no sufre ninguna otra modificación.

     Ejemplo:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true


 -- Función: unsum (<f>, <n>)
     Devuelve la diferencia `<f>(<n>) - <f>(<n> - 1)'. En cierto
     sentido `unsum' es la inversa de `sum'.

     Véase también `nusum'.

     Ejemplos:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)


 -- Variable opcional: verbose
     Valor por defecto: `false'

     Si `verbose' vale `true', la función `powerseries' va imprimiendo
     mensajes durante su ejecución.



File: maxima.info,  Node: Teoría de Números,  Next: Simetrías,  Prev: Series,  Up: Top

31 Teoría de Números
********************

* Menu:

* Funciones y variables para teoría de números::


File: maxima.info,  Node: Funciones y variables para teoría de números,  Prev: Teoría de Números,  Up: Teoría de Números

31.1 Funciones y variables para teoría de números
=================================================

 -- Función: bern (<n>)
     Devuelve el <n>-ésimo número de Bernoulli del entero <n>.  Los
     números de Bernoulli iguales a cero son suprimidos si `zerobern'
     vale `false'.

     Véase también `burn'.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798


 -- Función: bernpoly (<x>, <n>)
     Devuelve el <n>-ésimo polinomio de Bernoulli de variable <x>.


 -- Función: bfzeta (<s>, <n>)
     Devuelve la función zeta de Riemann para el argumento <s>. El
     valor que devuelve es del tipo "big float" (bfloat) y <n>  es su
     número de dígitos.

     Es necesario cargar en memoria esta función haciendo `load
     ("bffac")'.


 -- Función: bfhzeta (<s>, <h>, <n>)
     Devuelve la función zeta de Hurwitz para los argumentos <s> y <h>.
     El valor que devuelve es del tipo "big float" (bfloat) y <n>  es
     su número de dígitos.

     La función zeta de Hurwitz se define como

          sum ((k+h)^-s, k, 0, inf)


 -- Función: binomial (<x>, <y>)
     Es el coeficiente binomial `<x>!/(<y>! (<x> - <y>)!)'.  Si <x> y
     <y> son enteros, entonces se calcula el valor numérico del
     coeficiente binomial. Si <y> o <x - y> son enteros, el coeficiente
     binomial se expresa como un polinomio.

     Ejemplos:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)

 -- Función: burn (<n>)
     Devuelve el <n>-ésimo número de Bernoulli del entero <n>. La
     función `burn' puede ser más eficiente que `bern' para <n> grande
     (mayor que 105, por ejemplo), pues `bern' calcula todos los
     números de Bernoulli hasta <n> antes de devolver el resultado.

     La función `burn' se beneficia del hecho de que los números
     racionales de Bernoulli pueden aproximarse por funciones zeta con
     una eficiencia aceptable.

     Es necesario cargar en memoria esta función haciendo `load
     ("bffac")'.


 -- Función: cf (<expr>)
     Transforma <expr> a fracciones continuas. La expresión <expr> debe
     contener fracciones continuas y raíces cuadradas de números
     enteros. Los operandos de la expresión pueden combinarse con
     operadores aritméticos. Además de fracciones continuas y raíces
     cuadradas, los factores de la expresión deben ser enteros o
     números racionales. Maxima no tiene más conocimiento sobre
     operaciones con fracciones continuas que el que aporta la función
     `cf'.

     La función `cf' evalúa sus argumentos después de asignar a la
     variable `listarith' el valor `false', retornando una fracción
     continua en forma de lista.

     Una fracción continua `a + 1/(b + 1/(c + ...))' se representa como
     la lista `[a, b, c, ...]', donde los elementos `a', `b', `c', ...
     se evalúan como enteros. La expresión <expr> puede contener
     también  `sqrt (n)' donde `n' es un entero; en tal caso, `cf'
     devolverá tantos términos de la fracción continua como indique el
     valor de la variable `cflength' multiplicado por el período.

     Una fracción continua puede reducirse a un número evaluando la
     representación aritmética que devuelve `cfdisrep'. Véase también
     `cfexpand', que es otra alternativa para evaluar fracciones
     continuas.

     Véanse asimismo `cfdisrep', `cfexpand' y `cflength'.

     Ejemplos:

        * La expresión <expr> contiene fracciones continuas y raíces
          cuadradas de enteros.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * La variable `cflength' controla cuantos períodos de la
          fracción continua se calculan para números irracionales
          algebraicos.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * Una fracción continua puede calcularse evaluando la
          representación aritmética que devuelve `cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima no sabe sobre operaciones con fracciones continuas más
          de lo que aporta la función `cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]


 -- Función: cfdisrep (<lista>)
     Construye y devuelve una expresión aritmética ordinaria de la
     forma  `a + 1/(b + 1/(c + ...))' a partir de la representación en
     formato lista de la fracción continua  `[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2


 -- Función: cfexpand (<x>)
     Devuelve la matriz con los numeradores y denominadores de la
     última (columna 1) y penúltima (columna 2) convergentes de la
     fracción continua <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902


 -- Variable opcional: cflength
     Valor por defecto: 1

     La variable `cflength' controla el número de términos de la
     fracción continua que devuelve la función `cf', que será
     `cflength' multiplicado por el período. Así, el valor por defecto
     será el de un período.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]


 -- Función: divsum (<n>, <k>)
 -- Función: divsum (<n>)
     La llamada `divsum (<n>, <k>)' devuelve la suma de los divisores
     de <n> elevados a la <k>-ésima potencia.

     La llamada `divsum (<n>)' devuelve la suma de los divisores de <n>.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210


 -- Función: euler (<n>)
     Devuelve el <n>-ésimo número de Euler del entero no negativo <n>.

     Para la constante de Euler-Mascheroni, véase `%gamma'.

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]


 -- Constante: %gamma
     Es la constante de Euler-Mascheroni, 0.5772156649015329 ....


 -- Función: factorial (<x>)
     Representa la función factorial. Maxima considera `factorial
     (<x>)' lo mismo que `<x>!'.  Véase `!'.


 -- Función: fib (<n>)
     Devuelve el <n>-ésimo número de Fibonacci. La llamada `fib(0)' es
     igual a 0, `fib(1)' devuelve 1 y `fib (-<n>)' es igual a
     `(-1)^(<n> + 1) * fib(<n>)'.

     Después de llamar a `fib', la variable `prevfib' toma el valor
     `fib (<x> - 1)', que es el número de Fibonacci que precede al
     último calculado.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


 -- Función: fibtophi (<expr>)
     Expresa los números de Fibonacci en <expr> en términos de la razón
     áurea `%phi', que es `(1 + sqrt(5))/2', aproximadamente 1.61803399.

     Ejemplos:

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0


 -- Función: ifactors (<n>)
     Devuelve la factorización del argumento <n>, siendo éste un número
     entero positivo. Si `n=p1^e1..pk^nk' es la descomposición de <n>
     en números primos, `ifactors' devuelve `[[p1, e1], ... , [pk,
     ek]]'.

     Los métodos de factorización son las divisones tentativas hasta el
     9973, así como los  métodos rho de Pollard y el de la curva
     elíptica.

          (%i1) ifactors(51575319651600);
          (%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
          (%i2) apply("*", map(lambda([u], u[1]^u[2]), %));
          (%o2)                        51575319651600


 -- Función: inrt (<x>, <n>)
     Devuelve la raíz entera <n>-ésima del valor absoluto de  <x>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]


 -- Función: inv_mod (<n>, <m>)
     Calcula el inverso de <n> módulo <m>.  La llamada `inv_mod (n,m)'
     devuelve `false' si <n> es un divisor nulo módulo <m>.

          (%i1) inv_mod(3, 41);
          (%o1)                           14
          (%i2) ratsimp(3^-1), modulus=41;
          (%o2)                           14
          (%i3) inv_mod(3, 42);
          (%o3)                          false


 -- Función: jacobi (<p>, <q>)
     Devuelve el símbolo de Jacobi para <p> y <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]


 -- Función: lcm (<expr_1>, ..., <expr_n>)
     Devuelve el mínimo común múltiplo de sus argumentos. Los
     argumentos pueden ser tanto expresiones en general como enteros.

     Es necesario cargar en memoria esta función haciendo `load
     ("functs")'.


 -- Función: next_prime (<n>)
     Devuelve el menor de los primos mayores que <n>.

          (%i1) next_prime(27);
          (%o1)                       29


 -- Función: partfrac (<expr>, <var>)
     Expande la expresión <expr> en fracciones parciales respecto de la
     variable principal <var>. La función `partfrac' hace una
     descomposición completa en fracciones parciales. El algoritmo que
     se utiliza se basa en el hecho de que los denominadores de la
     expansión en fracciones parciales (los factores del denominador
     original) son primos relativos. Los numeradores se pueden escribir
     como combinaciones lineales de los denominadores.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)


 -- Función: power_mod (<a>, <n>, <m>)
     Utiliza un algoritmo modular para calcular `a^n mod m', siendo <a>
     y <n> enteros cualesquiera y <m> un entero positivo.  Si <n> es
     negativo, se utilizará `inv_mod' para encontrar el inverso modular.

          (%i1) power_mod(3, 15, 5);
          (%o1)                          2
          (%i2) mod(3^15,5);
          (%o2)                          2
          (%i3) power_mod(2, -1, 5);
          (%o3)                          3
          (%i4) inv_mod(2,5);
          (%o4)                          3


 -- Función: primep (<n>)
     Comprueba si el número entero <n> es o no primo, devolviendo `true'
     o `false' según el caso.

     Cuando el resultado de `primep (<n>)' es `false', <n> es un número
     compuesto, y si es `true', <n> es primo con alta probabilidad.

     Si <n> es menor que 10^16, se utiliza una versión determinística
     de la prueba de Miller-Rabin. En tal caso, si `primep (<n>)'
     devuelve `true', entonces <n> es un número primo.

     Para <n> mayor que 10^16 `primep' realiza un número de pruebas de
     seudo-primalidad de Miller-Rabin igual a `primep_number_of_tests'
     y una prueba de seudo-primalidad de Lucas. La probabilidad de que
     <n> pase una prueba de Miller-Rabin es menor que 1/4. Con el valor
     por defecto de `primep_number_of_tests', que es 25, la
     probabilidad de que <n> sea compuesto es menor que 10^-15.


 -- Variable opcional: primep_number_of_tests
     Valor por defecto: 25

     Número de pruebas de Miller-Rabin a realizar por `primep'.

 -- Función: prev_prime (<n>)
     Devuelve el mayor de los primos menores que <n>.

          (%i1) prev_prime(27);
          (%o1)                       23

 -- Función: qunit (<n>)
     Devuelve la unidad principal de `sqrt (<n>)', siendo <n> un
     entero; consiste en la resolución de la ecuación de Pell  `a^2 -
     <n> b^2 = 1'.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1


 -- Función: totient (<n>)
     Devuelve el número de enteros menores o iguales a <n> que son
     primos relativos con <n>.


 -- Variable opcional: zerobern
     Valor por defecto: `true'

     Si `zerobern' vale `false', `bern' excluye los números de
     Bernoulli iguales a cero.  See `bern'.


 -- Función: zeta (<n>)
     Devuelve la función zeta de Riemann para <x> entero negativo, 0, 1
     o número par positivo. No se evalúa `zeta (<n>)' para cualesquiera
     otros argumentos, incluyendo racionales no enteros, números en
     coma flotante o argumentos complejos.

     Véanse también `bfzeta' y `zeta%pi'.

          (%i1) map (zeta, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);
                                               2              4
                     1        1     1       %pi            %pi
          (%o1) [0, ---, 0, - --, - -, inf, ----, zeta(3), ----, zeta(5)]
                    120       12    2        6              90


 -- Variable opcional: zeta%pi
     Valor por defecto: `true'

     Si `zeta%pi' vale `true', `zeta' devuelve una expresión
     proporcional a `%pi^n' si `n' es un número par positivo. En caso
     contrario, `zeta' no se evalúa y devuelve la forma nominal `zeta
     (n)'.

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)



File: maxima.info,  Node: Simetrías,  Next: Grupos,  Prev: Teoría de Números,  Up: Top

32 Simetrías
************

* Menu:

* Funciones y variables para simetrías::


File: maxima.info,  Node: Funciones y variables para simetrías,  Prev: Simetrías,  Up: Simetrías

32.1 Funciones y variables para simetrías
=========================================

 -- Función: comp2pui (<n>, <l>)
     Realiza el paso de las funciones simétricas completas de la lista
     <l> a las funciones simétricas elementales de 0 a <n>. En caso de
     que la lista <l> contenga menos de `<n>+1' elementos, se
     completará con valores formales.  El primer elemento de la lista
     <l> almacena el cardinal del alfabeto, en caso de que exista; en
     caso contrario se le da el valor <n>.

          (%i1) comp2pui (3, [4, g]);
                                  2                    2
          (%o1)    [4, g, 2 h2 - g , 3 h3 - g h2 + g (g  - 2 h2)]


 -- Función: cont2part (<pc>, <lvar>)
     Convierte el polinomio particionado asociado a la forma contraída
     <pc>, cuyas variables se encuentran en <lvar>.

          (%i1) pc: 2*a^3*b*x^4*y + x^5;
                                     3    4      5
          (%o1)                   2 a  b x  y + x
          (%i2) cont2part (pc, [x, y]);
                                             3
          (%o2)              [[1, 5, 0], [2 a  b, 4, 1]]

     Otras funciones para efectuar cambios de representación son:
     `contract', `explose', `part2cont', `partpol', `tcontract' y
     `tpartpol'.


 -- Función: contract (<psym>, <lvar>)
     Convierte una forma contraída (como un monomio por órbita sobre la
     acción del grupo simétrico) del polinomio <psym> cuyas variables
     se encuentran en la lista <lvar>. La función `explose' realiza la
     operación inversa. A mayopes, la función `tcontract' comprueba la
     simetría del polinomio.

          (%i1) psym: explose (2*a^3*b*x^4*y, [x, y, z]);
                   3      4      3      4      3    4        3    4
          (%o1) 2 a  b y z  + 2 a  b x z  + 2 a  b y  z + 2 a  b x  z

                                                     3      4      3    4
                                                + 2 a  b x y  + 2 a  b x  y
          (%i2) contract (psym, [x, y, z]);
                                        3    4
          (%o2)                      2 a  b x  y

     Otras funciones para efectuar cambios de representación son:

     `cont2part', `explose', `part2cont', `partpol', `tcontract',
     `tpartpol'.


 -- Función: direct ([<p_1>, ..., <p_n>], <y>, <f>, [<lvar_1>, ...,
          <lvar_n>])
     Calcula la imagen directa (véase M. Giusti, D. Lazard et A.
     Valibouze, ISSAC 1988, Roma) asociada a la función <f>, en las
     listas de variables <lvar_1>, ..., <lvar_n>, y en los polinomios
     <p_1>, ..., <p_n> de una variable <y>. Si la expresión de <f> no
     depende de variable alguna, no sólo es inútil aportar esa
     variable, sino que también disminuyen considerablemente los
     cálculos cuando la variable no se declara.

          (%i1) direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]);
                 2
          (%o1) y  - e1 f1 y

                                           2            2             2   2
                            - 4 e2 f2 - (e1  - 2 e2) (f1  - 2 f2) + e1  f1
                          + -----------------------------------------------
                                                   2
          (%i2) ratsimp (%);
                        2                2                   2
          (%o2)        y  - e1 f1 y + (e1  - 4 e2) f2 + e2 f1
          (%i3) ratsimp (direct ([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]));
                 6            5         2                        2    2   4
          (%o3) y  - 2 e1 f1 y  + ((2 e1  - 6 e2) f2 + (2 e2 + e1 ) f1 ) y

                                    3                               3   3
           + ((9 e3 + 5 e1 e2 - 2 e1 ) f1 f2 + (- 2 e3 - 2 e1 e2) f1 ) y

                   2       2        4    2
           + ((9 e2  - 6 e1  e2 + e1 ) f2

                              2       2       2                   2    4
           + (- 9 e1 e3 - 6 e2  + 3 e1  e2) f1  f2 + (2 e1 e3 + e2 ) f1 )

            2          2                      2     3          2
           y  + (((9 e1  - 27 e2) e3 + 3 e1 e2  - e1  e2) f1 f2

                           2            2    3                5
           + ((15 e2 - 2 e1 ) e3 - e1 e2 ) f1  f2 - 2 e2 e3 f1 ) y

                     2                   3           3     2   2    3
           + (- 27 e3  + (18 e1 e2 - 4 e1 ) e3 - 4 e2  + e1  e2 ) f2

                   2      3                   3    2   2
           + (27 e3  + (e1  - 9 e1 e2) e3 + e2 ) f1  f2

                             2    4        2   6
           + (e1 e2 e3 - 9 e3 ) f1  f2 + e3  f1

     Búsqueda del polinomio cuyas raíces son la suma a+u o a es la raíz
     de z^2  - e1* z + e2 y u es la raíz de z^2  - f1* z + f2

          (%i1) ratsimp (direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                                    z, a + u, [[u], [a]]));
                 4                    3             2
          (%o1) y  + (- 2 f1 - 2 e1) y  + (2 f2 + f1  + 3 e1 f1 + 2 e2

               2   2                              2               2
           + e1 ) y  + ((- 2 f1 - 2 e1) f2 - e1 f1  + (- 2 e2 - e1 ) f1

                            2                     2            2
           - 2 e1 e2) y + f2  + (e1 f1 - 2 e2 + e1 ) f2 + e2 f1  + e1 e2 f1

               2
           + e2

     La función `direct' acepta dos indicadores: `elementaires'
     (elementales) y `puissances' (potenciales, que es el valor por
     defecto) que permiten hacer la descomposición de los polinomios
     simétricos que aparezcan en los cálculos en funciones simétricas
     elementales o en funciones potenciales, respectivamente.

     Funciones de `sym' utilizadas en esta función:

     `multi_orbit'(por tanto `orbit'),`pui_direct', `multi_elem' (por
     tanto `elem'), `multi_pui' (por tanto `pui'), `pui2ele', `ele2pui'
     (si al indicador `direct' se le asignó `puissances').


 -- Función: ele2comp (<m>, <l>)
     Pasa las funciones simétricas elementales a funciones completas,
     de forma similar a `comp2ele' y `comp2pui'.

     Otras funciones para cambio de bases son:

     `comp2ele', `comp2pui', `ele2pui', `elem', `mon2schur',
     `multi_elem', `multi_pui', `pui', `pui2comp', `pui2ele',
     `puireduc' y `schur2comp'.


 -- Función: ele2polynome (<l>, <z>)
     Devuelve el polinomio en <z> en el que las funciones simétricas
     elementales de las raíces son las de la lista <l>.  `<l> = [<n>,
     <e_1>, ..., <e_n>]', donde <n> es el grado del polinomio y <e_i>
     la <i>-ésima función simétrica elemental.

          (%i1) ele2polynome ([2, e1, e2], z);
                                    2
          (%o1)                    z  - e1 z + e2
          (%i2) polynome2ele (x^7 - 14*x^5 + 56*x^3  - 56*x + 22, x);
          (%o2)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i3) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o3)            x  - 14 x  + 56 x  - 56 x + 22

     La función recíproca es `polynome2ele (<P>, <z>)'

     Véanse también `polynome2ele' y `pui2polynome'.


 -- Función: ele2pui (<m>, <l>)
     Pasa las funciones simétricas elementales a funciones completas,
     de forma similar a `comp2ele' y `comp2comp'.

     Otras funciones para cambio de bases son:

     `comp2ele', `comp2pui', `ele2comp', `elem', `mon2schur',
     `multi_elem', `multi_pui', `pui', `pui2comp', `pui2ele',
     `puireduc' y `schur2comp'.


 -- Función: elem (<ele>, <sym>, <lvar>)
     Descompone el polinomio simétrico <sym> con las variables
     continuas de la lista <lvar> en las funciones simétricas
     elementales contenidas en la lista <ele>.  El primer elemento de
     la lista <ele> almacena el cardinal del alfabeto, en caso de que
     exista; en caso contrario se le da como valor el grado del
     polinomio <sym>.  Si faltan valores en la lista <ele>, ésta se
     completará con valores formales del tipo "ei".  El polinomio <sym>
     puede especificarse de tres formas diferentes: contraído (en cuyo
     caso `elem' debe valer 1, que es el valor por defecto),
     particionado (`elem' valdrá 3) o extendido (por ejemplo, el
     polinomio completo) (en este caso, `elem' valdrá 2). La
     utilización de la función `pui' se hace siguiendo este mismo
     modelo.

     Con un alfabeto de cardinal 3 con <e1>, la primera función
     simétrica elemental valiendo 7, el polinomio simétrico de tres
     variables cuya forma contraída (aquí dependiendo solamente de dos
     de sus variables) es ^4-2*x*y, se descompone en funciones
     simétricas elementales:

          (%i1) elem ([3, 7], x^4 - 2*x*y, [x, y]);
          (%o1) 7 (e3 - 7 e2 + 7 (49 - e2)) + 21 e3

                                                   + (- 2 (49 - e2) - 2) e2
          (%i2) ratsimp (%);
                                        2
          (%o2)             28 e3 + 2 e2  - 198 e2 + 2401

     Otras funciones para cambio de bases son: `comp2ele', `comp2pui',
     `ele2comp', `ele2pui', `mon2schur', `multi_elem', `multi_pui',
     `pui', `pui2comp', `pui2ele', `puireduc' y `schur2comp'.


 -- Función: explose (<pc>, <lvar>)
     Devuelve el polinomio simétrico asociado a la forma contraída
     <pc>. La lista <lvar> contiene las variables.

          (%i1) explose (a*x + 1, [x, y, z]);
          (%o1)                  a z + a y + a x + 1

     Otras funciones para efectuar cambios de representación son:
     `contract', `cont2part', `part2cont', `partpol', `tcontract' y
     `tpartpol'.


 -- Función: kostka (<part_1>, <part_2>)
     Función escrita por P. Espert, calcula el número de Kostka
     asociado a las particiones <part_1> y <part_2>.

          (%i1) kostka ([3, 3, 3], [2, 2, 2, 1, 1, 1]);
          (%o1)                           6


 -- Función: lgtreillis (<n>, <m>)
     Devuelve la lista de particiones de peso <n> y longitud <m>.

          (%i1) lgtreillis (4, 2);
          (%o1)                   [[3, 1], [2, 2]]

     Véanse también `ltreillis', `treillis' y `treinat'.


 -- Función: ltreillis (<n>, <m>)
     Devuelve la lista de particiones de peso <n> y longitud menor o
     igual que <m>.

          (%i1) ltreillis (4, 2);
          (%o1)               [[4, 0], [3, 1], [2, 2]]

     Véanse tambiént `lgtreillis', `treillis' y `treinat'.


 -- Función: mon2schur (<l>)
     La lista <l> representa la función de Schur S_<l>: Se tiene <l> =
     [<i_1>, <i_2>, ..., <i_q>] con <i_1> <= <i_2> <= ... <= <i_q>.  La
     función de Schur es S_[<i_1>, <i_2>, ..., <i_q>], el menor de la
     matriz infinita (h_{i-j}) <i> >= 1, <j> >= 1 compuesto de las <q>
     primeras filas y columnas <i_1> + 1, <i_2> + 2, ..., <i_q> + <q>.

     Se ha escrito esta función de Schur en función de las formas
     monomiales utilizando las funciones `treinat' y `kostka'.  La
     forma devuelta es un polinomio simétrico en una de sus
     representaciones contraídas con las variables <x_1>, <x_2>, ...

          (%i1) mon2schur ([1, 1, 1]);
          (%o1)                       x1 x2 x3
          (%i2) mon2schur ([3]);
                                            2        3
          (%o2)                x1 x2 x3 + x1  x2 + x1
          (%i3) mon2schur ([1, 2]);
                                                2
          (%o3)                  2 x1 x2 x3 + x1  x2

     Para 3 variables se tendrá:

             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2

     Otras funciones para cambio de bases son:

     `comp2ele', `comp2pui', `ele2comp', `ele2pui', `elem',
     `multi_elem', `multi_pui', `pui', `pui2comp', `pui2ele',
     `puireduc' y `schur2comp'.


 -- Función: multi_elem (<l_elem>, <multi_pc>, <l_var>)
     Descompone un polinomio multisimétrico sobre una forma
     multicontraída <multi_pc> en los grupos de variables contenidas en
     la lista de listas  <l_var> sobre los grupos de funciones
     simétricas elementales contenidas en <l_elem>.

          (%i1) multi_elem ([[2, e1, e2], [2, f1, f2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                            3
          (%o1)         - 2 f2 + f1 (f1 + e1) - 3 e1 e2 + e1
          (%i2) ratsimp (%);
                                   2                       3
          (%o2)         - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     Otras funciones para cambio de bases son:

     `comp2ele', `comp2pui', `ele2comp', `ele2pui', `elem',
     `mon2schur', `multi_pui', `pui', `pui2comp', `pui2ele', `puireduc'
     y `schur2comp'.


 -- Función: multi_orbit (<P>, [<lvar_1>, <lvar_2>, ..., <lvar_p>])
     <P> es un polinomio en el conjunto de variables contenidas en las
     listas <lvar_1>, <lvar_2>, ..., <lvar_p>.  Esta función restablece
     la órbita del polinomio <P> sobre la acción del producto de los
     grupos simétricos de los conjuntos de variables representadas por
     esas <p> listas.

          (%i1) multi_orbit (a*x + b*y, [[x, y], [a, b]]);
          (%o1)                [b y + a x, a y + b x]
          (%i2) multi_orbit (x + y + 2*a, [[x, y], [a, b, c]]);
          (%o2)        [y + x + 2 c, y + x + 2 b, y + x + 2 a]

     Véase también `orbit' para la acción de un solo grupo simérico.


 -- Función: multi_pui
     Es a la función `pui' lo que la función `multi_elem' es a la
     función `elem'.

          (%i1) multi_pui ([[2, p1, p2], [2, t1, t2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                      3
                                          3 p1 p2   p1
          (%o1)              t2 + p1 t1 + ------- - ---
                                             2       2


 -- Función: multinomial (<r>, <part>)
     El argumento <r> es el peso de la partición <part>.  Esta función
     calcula el coeficiente multinomial asociado: si las partes de las
     particiones <part> son <i_1>, <i_2>, ..., <i_k>, el resultado de
     `multinomial' es `<r>!/(<i_1>! <i_2>! ... <i_k>!)'.


 -- Función: multsym (<ppart_1>, <ppart_2>, <n>)
     Calcula el producto de dos polinomios simétricos de <n> variables
     operando solamente con el módulo de la acción del grupo simétrico
     de orden <n>. Los polinomios están en su representación
     particionada.

     Sean los dos polinomios simétricos en `x' e `y': `3*(x + y) +
     2*x*y' y `5*(x^2 + y^2)' cuyas formas particionadas son `[[3, 1],
     [2, 1, 1]]' y `[[5, 2]]', respectivamente; el producto de ambos
     será:

          (%i1) multsym ([[3, 1], [2, 1, 1]], [[5, 2]], 2);
          (%o1)         [[10, 3, 1], [15, 3, 0], [15, 2, 1]]

     o sea, `10*(x^3*y + y^3*x) + 15*(x^2*y + y^2*x) + 15*(x^3 + y^3)'.

     Funciones de cambio de representación de un polinomio simétrico:

     `contract', `cont2part', `explose', `part2cont', `partpol',
     `tcontract' y `tpartpol'.


 -- Función: orbit (<P>, <lvar>)
     Calcula la órbita de un polinomio <P> en las variables de la lista
     <lvar> bajo la acción del grupo simétrico del conjunto de
     variables contenidas en la lista <lvar>.

          (%i1) orbit (a*x + b*y, [x, y]);
          (%o1)                [a y + b x, b y + a x]
          (%i2) orbit (2*x + x^2, [x, y]);
                                  2         2
          (%o2)                 [y  + 2 y, x  + 2 x]

     Véase también `multi_orbit' para la acción de un producto de
     grupos simétricos sobre un polinomio.


 -- Función: part2cont (<ppart>, <lvar>)
     Transforma un polinomio simétrico de su forma particionada a su
     forma contraída. La forma contraída se devuelve con las variables
     contenidas en <lvar>.

          (%i1) part2cont ([[2*a^3*b, 4, 1]], [x, y]);
                                        3    4
          (%o1)                      2 a  b x  y

     Otras funciones para efectuar cambios de representación son:

     `contract', `cont2part', `explose', `partpol', `tcontract' y
     `tpartpol'.


 -- Función: partpol (<psym>, <lvar>)
     Restablece la representación particionada del polinomio simétrico
     <psym> de variables en <lvar>.

          (%i1) partpol (-a*(x + y) + 3*x*y, [x, y]);
          (%o1)               [[3, 1, 1], [- a, 1, 0]]

     Otras funciones para efectuar cambios de representación son:

     `contract', `cont2part', `explose', `part2cont', `tcontract' y
     `tpartpol'.


 -- Función: permut (<l>)
     Devuelve la lista de permutaciones de la lista <l>.

 -- Función: polynome2ele (<P>, <x>)
     Devuelve la lista `<l> = [<n>, <e_1>, ..., <e_n>]', en la que <n>
     es el grado del polinomio <P> de variable <x> y <e_i> es la
     <i>-ésima función simétrica elemental de las raíces de <P>.

          (%i1) polynome2ele (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x);
          (%o1)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i2) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o2)            x  - 14 x  + 56 x  - 56 x + 22

     La función recíproca es `ele2polynome (<l>, <x>)'.


 -- Función: prodrac (<l>, <k>)
     Siendo <l> una lista que contiene las funciones simétricas
     elementales sobre un conjunto <A>, la función `prodrac' calcula el
     polinomio cuyas raíces son los productos <k> a <k> de los
     elementos de <A>.

 -- Función: pui (<l>, <sym>, <lvar>)
     Descompone el polinomio simétrico <sym>, cuyas variables son las
     contenidas en <lvar>, en las funciones potenciales contenidas en
     la lista <l>.  El primer elemento de la lista <l> almacena el
     cardinal del alfabeto, en caso de que exista; en caso contrario se
     le da el grado del polinomio <sym>.  Si faltan los valores de la
     lista <l>, en su lugar serán colocados valores formales del tipo
     "pi".  El polinomio <sym> puede especificarse de tres formas
     diferentes: contraído (en cuyo caso `pui' debe valer 1, que es el
     valor por defecto), particionado (`pui' valdrá 3) o extendido (por
     ejemplo, el polinomio completo) (en este caso, `pui' valdrá 2). La
     utilización de la función `elem' se hace siguiendo este mismo
     modelo.

          (%i1) pui;
          (%o1)                           1
          (%i2) pui ([3, a, b], u*x*y*z, [x, y, z]);
                                 2
                             a (a  - b) u   (a b - p3) u
          (%o2)              ------------ - ------------
                                  6              3
          (%i3) ratsimp (%);
                                                 3
                                (2 p3 - 3 a b + a ) u
          (%o3)                 ---------------------
                                          6

     Otras funciones para cambio de bases son: `comp2ele', `comp2pui',
     `ele2comp', `ele2pui', `elem', `mon2schur', `multi_elem',
     `multi_pui', `pui2comp', `pui2ele', `puireduc' y `schur2comp'.


 -- Función: pui2comp (<n>, <lpui>)
     Devuelve la lista de las <n> primeras funciones completas (con el
     cardinal en primer lugar) en función de las funciones potenciales
     dadas en la lista <lpui>. Si la lista <lpui> estuviese vacía, el
     cardinal sería <N>; si no estuviese vacía, se tomaría como
     cardinal su primer elemento, de forma similar a como se procede en
     `comp2ele' y en `comp2pui'.

          (%i1) pui2comp (2, []);
                                                 2
                                          p2 + p1
          (%o1)                   [2, p1, --------]
                                             2
          (%i2) pui2comp (3, [2, a1]);
                                                      2
                                           a1 (p2 + a1 )
                                   2  p3 + ------------- + a1 p2
                            p2 + a1              2
          (%o2)     [2, a1, --------, --------------------------]
                               2                  3
          (%i3) ratsimp (%);
                                      2                     3
                               p2 + a1   2 p3 + 3 a1 p2 + a1
          (%o3)        [2, a1, --------, --------------------]
                                  2               6

     Otras funciones para cambio de bases son: `comp2ele', `comp2pui',
     `ele2comp', `ele2pui', `elem', `mon2schur', `multi_elem',
     `multi_pui', `pui', `pui2ele', `puireduc' y `schur2comp'.


 -- Función: pui2ele (<n>, <lpui>)
     Transforma las funciones potenciales a funciones simétricas
     elementales. Si la variable global `pui2ele' vale `girard', se
     recupera la lista de funciones simétricas elementales de 1 <n>, y
     si es igual a `close', se recupera la <n>-ésima función simétrica
     elemental.

     Otras funciones para cambio de bases son: `comp2ele', `comp2pui',
     `ele2comp', `ele2pui', `elem', `mon2schur', `multi_elem',
     `multi_pui', `pui', `pui2comp', `puireduc' y `schur2comp'.


 -- Función: pui2polynome (<x>, <lpui>)
     Calcula el polinomio en <x> cuyas raíces tienen como funciones
     potenciales las dadas en la lista <lpui>.

          (%i1) pui;
          (%o1)                           1
          (%i2) kill(labels);
          (%o0)                         done
          (%i1) polynome2ele (x^3 - 4*x^2 + 5*x - 1, x);
          (%o1)                     [3, 4, 5, 1]
          (%i2) ele2pui (3, %);
          (%o2)                     [3, 4, 6, 7]
          (%i3) pui2polynome (x, %);
                                  3      2
          (%o3)                  x  - 4 x  + 5 x - 1

     Véanse también `polynome2ele' y `ele2polynome'.


 -- Función: pui_direct (<orbite>, [<lvar_1>, ..., <lvar_n>], [<d_1>,
          <d_2>, ..., <d_n>])
     Sea <f> un polinomio en <n> bloques de variables <lvar_1>, ...,
     <lvar_n>.  Sea <c_i> el número de variables en <lvar_i> y <SC> el
     producto de los <n> grupos simétricos de grados <c_1>, ..., <c_n>,
     que actúan sobre <f>.  La lista <orbite> es la órbita,
     representada por `<SC>(<f>)', de la función <f> sobre la acción de
     <SC>, la cual puede ser obtenida por medio de la función
     `multi_orbit'.  Los valores `d_i' son enteros tales que <c_1> <=
     <d_1>, <c_2> <= <d_2>, ..., <c_n> <= <d_n>.  Por último, sea <SD>
     el producto de los grupos simétricos <S_d1> x <S_d2> x ... x
     <S_dn>.

     La función `pui_direct' devuelve las <n> primeras funciones
     potenciales de `<SD>(<f>)' deducidas de las funciones potenciales
     de `<SC>(<f>)', siendo <n> el cardinal de `<SD>(<f>)'.

     El resultado se devuelve en la forma multicontraída respecto de
     <SD>.

          (%i1) l: [[x, y], [a, b]];
          (%o1)                   [[x, y], [a, b]]
          (%i2) pui_direct (multi_orbit (a*x + b*y, l), l, [2, 2]);
                                                 2  2
          (%o2)               [a x, 4 a b x y + a  x ]
          (%i3) pui_direct (multi_orbit (a*x + b*y, l), l, [3, 2]);
                                       2  2     2    2        3  3
          (%o3) [2 a x, 4 a b x y + 2 a  x , 3 a  b x  y + 2 a  x ,

              2  2  2  2      3    3        4  4
          12 a  b  x  y  + 4 a  b x  y + 2 a  x ,

              3  2  3  2      4    4        5  5
          10 a  b  x  y  + 5 a  b x  y + 2 a  x ,

              3  3  3  3       4  2  4  2      5    5        6  6
          40 a  b  x  y  + 15 a  b  x  y  + 6 a  b x  y + 2 a  x ]
          (%i4) pui_direct ([y + x + 2*c, y + x + 2*b, y + x + 2*a], [[x, y], [a, b, c]], [2, 3]);
                                       2              2
          (%o4) [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,

                           2                   3        2       2        3
                        9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]


 -- Función: puireduc (<n>, <lpui>)
     Siendo <lpui> una lista en la que el primer elemento es un entero
     <m>, `puireduc' devuelve las <n> primeras funciones potenciales en
     función de las <m> primeras.

          (%i1) puireduc (3, [2]);
                                                   2
                                             p1 (p1  - p2)
          (%o1)          [2, p1, p2, p1 p2 - -------------]
                                                   2
          (%i2) ratsimp (%);
                                                     3
                                         3 p1 p2 - p1
          (%o2)              [2, p1, p2, -------------]
                                               2


 -- Función: resolvante (<P>, <x>, <f>, [<x_1>, ..., <x_d>])
     Calcula la resolvente del polinomio <P> de variable <x> y grado
     <n> >= <d> por la función <f> de variables <x_1>, ..., <x_d>.
     Para mejorar los cálculos, es importante no incluir en la lista
     `[<x_1>, ..., <x_d>]' las variables que no intervienen en la
     función de transformación <f>.

     Con el fin de hacer más eficaces los cálculos, se puede asignar a
     `resolvante' un indicador que permita seleccionar el algoritmo más
     apropiado:

        *   `unitaire',

        *   `lineaire',

        *   `alternee',

        *   `somme',

        *   `produit',

        *   `cayley',

        *   `generale'.

          (%i1) resolvante: unitaire$
          (%i2) resolvante (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x, x^3 - 1, [x]);

          " resolvante unitaire " [7, 0, 28, 0, 168, 0, 1120, - 154, 7840, - 2772, 56448, - 33880,

          413952, - 352352, 3076668, - 3363360, 23114112, - 30494464,

          175230832, - 267412992, 1338886528, - 2292126760]
            3       6      3       9      6      3
          [x  - 1, x  - 2 x  + 1, x  - 3 x  + 3 x  - 1,

           12      9      6      3       15      12       9       6      3
          x   - 4 x  + 6 x  - 4 x  + 1, x   - 5 x   + 10 x  - 10 x  + 5 x

                 18      15       12       9       6      3
           - 1, x   - 6 x   + 15 x   - 20 x  + 15 x  - 6 x  + 1,

           21      18       15       12       9       6      3
          x   - 7 x   + 21 x   - 35 x   + 35 x  - 21 x  + 7 x  - 1]
          [- 7, 1127, - 6139, 431767, - 5472047, 201692519, - 3603982011]
                 7      6        5         4          3           2
          (%o2) y  + 7 y  - 539 y  - 1841 y  + 51443 y  + 315133 y

                                                        + 376999 y + 125253
          (%i3) resolvante: lineaire$
          (%i4) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante lineaire "
                 24       20         16            12             8
          (%o4) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i5) resolvante: general$
          (%i6) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante generale "
                 24       20         16            12             8
          (%o6) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i7) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3, x4]);

          " resolvante generale "
                 24       20         16            12             8
          (%o7) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i8) direct ([x^4 - 1], x, x1 + 2*x2 + 3*x3, [[x1, x2, x3]]);
                 24       20         16            12             8
          (%o8) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i9) resolvante :lineaire$
          (%i10) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante lineaire "
                                        4
          (%o10)                       y  - 1
          (%i11) resolvante: symetrique$
          (%i12) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante symetrique "
                                        4
          (%o12)                       y  - 1
          (%i13) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante symetrique "
                                     6      2
          (%o13)                    y  - 4 y  - 1
          (%i14) resolvante: alternee$
          (%i15) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante alternee "
                      12      8       6        4        2
          (%o15)     y   + 8 y  + 26 y  - 112 y  + 216 y  + 229
          (%i16) resolvante: produit$
          (%i17) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante produit "
                  35      33         29        28         27        26
          (%o17) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i18) resolvante: symetrique$
          (%i19) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante symetrique "
                  35      33         29        28         27        26
          (%o19) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i20) resolvante: cayley$
          (%i21) resolvante (x^5 - 4*x^2 + x + 1, x, a, []);

          " resolvante de Cayley "
                  6       5         4          3            2
          (%o21) x  - 40 x  + 4080 x  - 92928 x  + 3772160 x  + 37880832 x

                                                                 + 93392896

     Para la resolvente de Cayley, los dos últimos argumentos son neutro
     y el polinomio dado en el argumento debe ser necesariamente de
     grado 5.

     Véanse también: `resolvante_bipartite', `resolvante_produit_sym',
     `resolvante_unitaire', `resolvante_alternee1', `resolvante_klein',
     `resolvante_klein3', `resolvante_vierer' y `resolvante_diedrale'.


 -- Función: resolvante_alternee1 (<P>, <x>)
     Calcula la transformación de `<P>(<x>)' de grado <n> por la
     función $\prod_{1\leq i<j\leq n-1} (x_i-x_j)$.

     Véanse también: `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante', `resolvante_klein', `resolvante_klein3',
     `resolvante_vierer', `resolvante_diedrale' y
     `resolvante_bipartite'.


 -- Función: resolvante_bipartite (<P>, <x>)
     Calcula la transformación de `<P>(<x>)' de grado <n> (<n> par) por
     la función $x_1x_2\ldots x_{n/2}+x_{n/2+1}\ldotsx_n$

          (%i1) resolvante_bipartite (x^6 + 108, x);
                        10        8           6             4
          (%o1)        y   - 972 y  + 314928 y  - 34012224 y

     Véanse también: `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante', `resolvante_klein', `resolvante_klein3',
     `resolvante_vierer', `resolvante_diedrale' y
     `resolvante_alternee1'.


 -- Función: resolvante_diedrale (<P>, <x>)
     Calcula la transformación de `<P>(<x>)' por la función `<x_1>
     <x_2> + <x_3> <x_4>'.

          (%i1) resolvante_diedrale (x^5 - 3*x^4 + 1, x);
                 15       12       11       10        9         8         7
          (%o1) x   - 21 x   - 81 x   - 21 x   + 207 x  + 1134 x  + 2331 x

                  6         5          4          3          2
           - 945 x  - 4970 x  - 18333 x  - 29079 x  - 20745 x  - 25326 x

           - 697

     Véanse también: `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante_vierer' y `resolvante'.


 -- Función: resolvante_klein (<P>, <x>)
     Calcula la transformación de `<P>(<x>)' por la función `<x_1>
     <x_2> <x_4> + <x_4>'.

     Véanse también: `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante', `resolvante_klein3',
     `resolvante_vierer' y `resolvante_diedrale'.


 -- Función: resolvante_klein3 (<P>, <x>)
     Calcula la transformación de `<P>(<x>)' por la función `<x_1>
     <x_2> <x_4> + <x_4>'.

     Véanse también: `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante',
     `resolvante_vierer' y `resolvante_diedrale'.


 -- Función: resolvante_produit_sym (<P>, <x>)
     Calcula la lista de todas las resolventes producto del polinomio
     `<P>(<x>)'.

          (%i1) resolvante_produit_sym (x^5 + 3*x^4 + 2*x - 1, x);
                  5      4             10      8       7       6       5
          (%o1) [y  + 3 y  + 2 y - 1, y   - 2 y  - 21 y  - 31 y  - 14 y

              4       3      2       10      8       7    6       5       4
           - y  + 14 y  + 3 y  + 1, y   + 3 y  + 14 y  - y  - 14 y  - 31 y

                 3      2       5      4
           - 21 y  - 2 y  + 1, y  - 2 y  - 3 y - 1, y - 1]
          (%i2) resolvante: produit$
          (%i3) resolvante (x^5 + 3*x^4 + 2*x - 1, x, a*b*c, [a, b, c]);

          " resolvante produit "
                 10      8       7    6        5       4       3     2
          (%o3) y   + 3 y  + 14 y  - y  - 14 y  - 31 y  - 21 y  - 2 y  + 1

     Véanse también: `resolvante', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante_vierer' y `resolvante_diedrale'.


 -- Función: resolvante_unitaire (<P>, <Q>, <x>)
     Calcula la resolvente del polinomio `<P>(<x>)' por el polinomio
     `<Q>(<x>)'.

     Véanse también: `resolvante_produit_sym', `resolvante',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante_vierer' y `resolvante_diedrale'.


 -- Función: resolvante_vierer (<P>, <x>)
     Calcula la transformación de `<P>(<x>)' por la función `<x_1>
     <x_2> - <x_3> <x_4>'.

     Véanse también: `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante' y `resolvante_diedrale'.


 -- Función: schur2comp (<P>, <l_var>)
     <P> es un polinomio de variables contenidas en la lista <l_var>.
     Cada una de las variables de <l_var> representa una función
     simétrica completa.  La <i>-ésima función simétrica completa de
     <l_var> se representa como la concatenación de la letra `h' con el
     entero <i>: `h<i>'.  La función `schur2comp' devuelve la expresión
     de <P> en función de las funciones de Schur.

          (%i1) schur2comp (h1*h2 - h3, [h1, h2, h3]);
          (%o1)                         s
                                         1, 2
          (%i2) schur2comp (a*h3, [h3]);
          (%o2)                         s  a
                                         3


 -- Función: somrac (<l>, <k>)
     Si la lista <l> contiene las funciones simétricas elementales de
     un polinomio <P>, la función `somrac' calcula el polinomio cuyas
     raíces son las sumas <k> a <k> de las raíces de <P>.

     Véase también `prodrac'.


 -- Función: tcontract (<pol>, <lvar>)
     Comprueba si el polinomio <pol> es simétrico en las variable
     contenidas en la lista <lvar>. En caso afirmativo, devuelve una
     forma contraída tal como lo hace la función `contract'.

     Otras funciones para efectuar cambios de representación son:
     `contract', `cont2part', `explose', `part2cont', `partpol' y
     `tpartpol'.


 -- Función: tpartpol (<pol>, <lvar>)
     Comprueba si el polinomio <pol> es simétrico en las variable
     contenidas en la lista <lvar>. En caso afirmativo, devuelve una
     forma particionada tal como lo hace la función `partpol'.

     Otras funciones para efectuar cambios de representación son:
     `contract', `cont2part', `explose', `part2cont', `partpol' y
     `tcontract'.


 -- Función: treillis (<n>)
     Devuelve todas las particiones de pesos <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     Véanse también `lgtreillis', `ltreillis' y `treinat'.


 -- Función: treinat (<part>)
     Devuelve la lista de las particiones inferiores de la partición
     <part> en su orden natural.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     Véanse también `lgtreillis', `ltreillis' y `treillis'.



File: maxima.info,  Node: Grupos,  Next: Entorno de Ejecución,  Prev: Simetrías,  Up: Top

33 Grupos
*********

* Menu:

* Funciones y variables para grupos::


File: maxima.info,  Node: Funciones y variables para grupos,  Prev: Grupos,  Up: Grupos

33.1 Funciones y variables para grupos
======================================

 -- Función: todd_coxeter (<relaciones>, <subgrupo>)
 -- Función: todd_coxeter (<relaciones>)
     Busca el orden de G/H donde G es el módulo del Grupo Libre de
     <relations>, y H es el subgrupo de G generado por `subgrupo'.
     `subgrupo' es un argumento opcional, cuyo valor por defecto es [].

     En este proceso se obtiene una tabla de multiplicación para la
     acción correcta de G sobre G/H, donde los co-cojuntos son
     enumerados [H,Hg2,Hg3,...]. Esto puede ser observado internamente
     en el `todd_coxeter_state'.

     Ejemplo:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20



File: maxima.info,  Node: Entorno de Ejecución,  Next: Miscelánea de opciones,  Prev: Grupos,  Up: Top

34 Entorno de Ejecución
***********************

* Menu:

* Introducción al entorno de ejecución::
* Interrupciones::
* Funciones y variables para el entorno de ejecución::


File: maxima.info,  Node: Introducción al entorno de ejecución,  Next: Interrupciones,  Prev: Entorno de Ejecución,  Up: Entorno de Ejecución

34.1 Introducción al entorno de ejecución
=========================================

El fichero `maxima-init.mac' se carga automáticamente cada vez que se
empieza a ejecutar Maxima.  Se puede utilizar `maxima-init.mac' para
personalizar el entorno de Maxima. Si existe, `maxima-init.mac' se
almacena normalmente en el directorio indicado por `maxima_userdir',
aunque puede estar alojado en cualquier otro directorio que esté al
alcance de la función  `file_search'.

   He aquí un ejemplo de fichero `maxima-init.mac':

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   En este ejemplo, `setup_autoload' le dice a Maxima que cargue en
memoria el fichero `specfun.mac' si cualquiera de las funciones
`ultraspherical' o `assoc_legendre_p' es invocada pero todavía no está
definida. De esta manera, no es necesario recordar cargar el fichero
antes de llamar a las funciones.

   La sentencia  `showtime: all' le dice a Maxima que haga una
asignación a la variable `showtime'.  El fichero  `maxima-init.mac'
puede contener cualesquiera otras asignaciones o sentencias de Maxima.


File: maxima.info,  Node: Interrupciones,  Next: Funciones y variables para el entorno de ejecución,  Prev: Introducción al entorno de ejecución,  Up: Entorno de Ejecución

34.2 Interrupciones
===================

El usuario puede detener un cómputo que esté consumiendo recursos
excesivos con el carácter ^C (control-C). La acción que se sigue por
defecto es la detención del cómputo y la impresión de otro prompt. En
este caso, no será posible reiniciar la tarea interrumpida.

   Si a la variable Lisp `*debugger-hook*' se le asigna `nil' haciendo

     :lisp (setq *debugger-hook* nil)

entonces tras recibir ^C, Maxima entra en el depurador de Lisp y el
usuario podrá utilizar el depurador para inspeccionar el entorno Lisp.
La tarea que haya sido interrumpida podrá reiniciarse escribiendo
`continue' en el depurado de Lisp. La forma de volver a Maxima desde el
depurador de Lisp, que no sea la de permitir la computación hasta la
terminación de la tarea, dependerá de la versión de Lisp.

   En sistemas Unix el carácter ^Z (control-Z) hace que Maxima deje de
ejecutarse devolviendo el control al terminal del sistema. El comando
`fg' hace que la ejecución de Maxima se reanude en el punto que lo dejó.


File: maxima.info,  Node: Funciones y variables para el entorno de ejecución,  Prev: Interrupciones,  Up: Entorno de Ejecución

34.3 Funciones y variables para el entorno de ejecución
=======================================================

 -- Declaración: feature
     Maxima trata con dos tipos diferentes de características, las del
     sistema y las correspondientes a expresiones matemáticas. Véase
     también `status' para información sobre características del
     sistema. Véanse asimismo `features' y `featurep' para información
     sobre características matemáticas.

     `feature' no es el nombre de una función ni de una variable.


 -- Función: featurep (<a>, <f>)
     Intenta determinar si el objeto <a> tiene la característica <f> en
     base a la información en la base de datos actual. De ser así,
     devuelve `true', en caso contrario `false'.

     Nótese que `featurep' devuelve `false' cuando ni <f> ni la
     negación <f> puedan determinarse.

     La función `featurep' evalúa sus argumentos.

     Véanse también `declare' y `features'.

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true


 -- Variable del sistema: maxima_tempdir
     La variable `maxima_tempdir' almacena la ruta del directorio en el
     que Maxima crea ciertos ficheros temporales.  En particular, los
     ficheros temporales para la realización de gráficos se guardan en
     `maxima_tempdir'.

     El valor que inicialmente toma esta variable es el directorio de
     inicio del usuario, si Maxima es capaz de localizarlo; en caso
     contrario, Maxima intenta encontrar un directorio que sea
     aceptable.

     A la variable `maxima_tempdir' se le puede asignar una cadena de
     caracteres con la ruta del directorio.

 -- Variable del sistema: maxima_userdir
     La variable `maxima_userdir' almacena la ruta del directorio en el
     que Maxima buscará ficheros Lisp y de Maxima. Maxima también busca
     en otros directorios, guardando las variables `file_search_maxima'
     y `file_search_lisp' la lista completa de búsqueda.

     El valor que inicialmente toma esta variable es el de un
     subdirectorio del directorio de inicio del usuario, si Maxima es
     capaz de localizarlo; en caso contrario, Maxima intenta encontrar
     un directorio que sea aceptable.

     A la variable `maxima_userdir' se le puede asignar una cadena de
     caracteres con la ruta del directorio.  Sin embargo, cambiando el
     valor de la variable `maxima_userdir' no se alteran
     `file_search_maxima' ni `file_search_lisp', cuyos contenidos se
     modifican mediante otro sistema.

 -- Función: room ()
 -- Función: room (true)
 -- Función: room (false)
     Presenta una descrpción del estado de almacenamiento y gestión de
     la pila en Maxima. La llamada `room' invoca a la función Lisp
     homónima.

        * `room ()' prints out a moderate description.

        * `room (true)' prints out a verbose description.

        * `room (false)' prints out a terse description.


 -- Función: status (feature)
 -- Función: status (feature, <putative_feature>)
 -- Función: status (status)
     Devuelve información sobre la presencia o ausencia de ciertas
     características dependientes del sistema.

        * `status (feature)' devuelve una lista con características del
          sistema. Éstas incluyen la versión de Lisp, tipo de sistema
          operativo, etc. La lista puede variar de un Lisp a otro.

        * `status (feature, <putative_feature>)' devuelve `true' si
          <putative_feature> está en la lista de elementos retornados
          por `status (feature)' y `false' en otro caso.  La función
          `status' no evalúa el argumento <putative_feature>. El
          operador comilla-comilla, `''', permite la evaluación. Una
          característica cuyo nombre contenga un carácter especial debe
          ser suministrada como un argumento del tipo cadena
          alfanumérica. Por ejemplo, `status (feature, "ansi-cl")'.

        * La llamada `status (status)' devuelve una lista con dos
          elementos `[feature, status]'. Los elementos `feature' y
          `status' son los dos argumentos que acepta la función
          `status'; no está claro si esta lista tiene algún interés
          adicional.

     La variable `features' contiene una lista de características que
     se aplican a expresiones matemáticas. Véanse `features' y
     `featurep' para más información.


 -- Función: time (%o1, %o2, %o3, ...)
     Devuelve una lista de los tiempos, en segundos, que fueron
     necesarios para calcular los resultados de las salidas `%o1',
     `%o2', `%o3', .... Los tiempos devueltos son estimaciones hechas
     por Maxima del tiempo interno de computación. La función `time'
     sólo puede utilizarse para variables correspondientes a líneas de
     salida; para cualquier otro tipo de variables, `time' devuelve
     `unknown'.

     Hágase `showtime: true' para que Maxima devuelva el tiempo de
     ejecución de cada línea de salida.


 -- Función: timedate ()
     Devuelve una cadena alfanumérica con la hora y fecha actuales. La
     cadena tiene el formato `HH:MM:SS Day, mm/dd/yyyy (GMT-n)', donde
     los campos son: las horas, minutos, segundos, día de de la semana,
     mes, día del mes, año y número de horas de diferencia con respecto
     a la hora GMT.

     Ejemplo

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate reports current time", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)


 -- Función: absolute_real_time ()
     Devuelve el número de segundos transcurridos desde la medianoche
     del 1 de enero de 1900 UTC. Este valor es un número entero
     positivo.

     Véanse también `elapsed_real_time' y `elapsed_run_time'.

     Ejemplo:

          (%i1) absolute_real_time ();
          (%o1)                      3385045277
          (%i2) 1900 + absolute_real_time () / (365.25 * 24 * 3600);
          (%o2)                   2007.265612087104


 -- Función: elapsed_real_time ()
     Devuelve los segundos (incluyendo fracciones de segundo)
     transcurridos desde que Maxima se inició (o reinició) la sesión de
     Maxima. Este valor es un decimal en coma flotante.

     Véanse también `absolute_real_time' y `elapsed_run_time'.

     Ejemplo:

          (%i1) elapsed_real_time ();
          (%o1)                       2.559324
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_real_time ();
          (%o3)                       7.552087


 -- Función: elapsed_run_time ()
     Devuelve una estimación en segundos (incluyendo fracciones de
     segundo) durante los cuales Maxima ha estado realizando cálculos
     desde que se inició (o reinició) la sesión actual.  Este valor es
     un decimal en coma flotante.

     Véanse también `absolute_real_time' y `elapsed_real_time'.

     Ejemplo:

          (%i1) elapsed_run_time ();
          (%o1)                         0.04
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_run_time ();
          (%o3)                         1.26



File: maxima.info,  Node: Miscelánea de opciones,  Next: Reglas y patrones,  Prev: Entorno de Ejecución,  Up: Top

35 Miscelánea de opciones
*************************

* Menu:

* Introducción a la miscelánea de opciones::
* Share::
* Funciones y variables para la miscelánea de opciones::


File: maxima.info,  Node: Introducción a la miscelánea de opciones,  Next: Share,  Prev: Miscelánea de opciones,  Up: Miscelánea de opciones

35.1 Introducción a la miscelánea de opciones
=============================================

En esta sección se comentan varias opciones que tienen un efecto global
sobre le comportamiento de Maxima. También se comentan varias listas,
como la de las funciones definidas por el usuario.


File: maxima.info,  Node: Share,  Next: Funciones y variables para la miscelánea de opciones,  Prev: Introducción a la miscelánea de opciones,  Up: Miscelánea de opciones

35.2 Share
==========

El directorio "share" de Maxima contiene programas y ficheros de
interés para los usuarios de Maxima, pero no forman parte del núcleo de
Maxima. Estos programas se cargan en memoria con llamadas a las
funciones `load' o `setup_autoload'.

   La llamada `:lisp *maxima-sharedir*' muestra la localización del
directorio "share" dentro del sistema de ficheros del usuario.

   La llamada `printfile ("share.usg")' muestra una lista actualizada
de paquetes en "share". Los usuarios pueden encontrar más información
accediendo directamente a los contenidos del directorio "share".


File: maxima.info,  Node: Funciones y variables para la miscelánea de opciones,  Prev: Share,  Up: Miscelánea de opciones

35.3 Funciones y variables para la miscelánea de opciones
=========================================================

 -- Variable del sistema: aliases
     Valor por defecto: `[]'

     La variable `aliases' es la lista de átomos que tienen un "alias"
     definido por el usuario (establecido mediante las funciones
     `alias', `ordergreat' o `orderless' o declarando el átomo como un
     `noun' (nombre) con `declare'.

 -- Declaración: alphabetic
     `alphabetic' es una declaración de tipo reconocida por `declare'.
     La expresión `declare(<s>, alphabetic)' indica a Maxima que
     reconozca como alfabéticos todos los caracteres de <s>, que debe
     ser una cadena alfanumérica.

     Ejemplo:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]


 -- Función: apropos (<cadena>)
     Busca nombres en Maxima en los cuales aparezca <cadena> en
     cualquier lugar dentro de ellos. Así, `apropos (exp)' devuelve una
     lista con todas las variables y funciones que tengan  `exp'
     formando parte de sus nombres, como  `expand', `exp' y
     `exponentialize'. De esta forma, si el usuario tan solo recuerda
     parte del nombre de algo, puede utilizar este comando para
     encontrar el resto del nombre. De manera semejante, también se
     puede hacer `apropos (tr_)' para encontrar una lista de muchas de
     las variables relacionadas con el traductor, buena parte de las
     cuales comienzan con `tr_'.


 -- Función: args (<expr>)
     Devuelve la lista de argumentos de `expr', que puede ser cualquier
     tipo de expresión a excepción de un átomo. Tan solo se muestran
     los argumentos del operador principal; subexpresiones de `expr'
     aparecen como elementos o subexpresiones de elementos de la lista
     de argumentos.

     El orden de los miembros de la lista puede depender de la variable
     global `inflag'.

     La llamada `args (<expr>)' es equivalente a `substpart ("[",
     <expr>, 0)'.

     Véanse también `substpart' y `op'.


 -- Variable optativa: genindex
     Valor por defecto: `i'

     La variable `genindex' es el prefijo alfabético utilizado para
     generar la siguiente variable de sumación en caso de necesidad.


 -- Variable optativa: gensumnum
     Valor por defecto: 0

     La variable `gensumnum' es el sufijo numérico utilizado para
     generar la siguiente variable de sumación. Si vale  `false'
     entonces el índice consistirá solamente de  `genindex', sin sufijo
     numérico.


 -- Constante: inf
     Símbolo que identifica al infinito positivo dentro de un contexto
     de números reales.


 -- Constante: infinity
     Símbolo que identifica al infinito complejo, una magnitud infinita
     con ángulo de fase arbitrario.  Véanse también `inf' y `minf'.


 -- Variable del sistema: infolists
     Valor por defecto: `[]'

     La variable `infolists' es una lista con los nombres de todas las
     listas que guardan información sobre Maxima. Estas son:

    `labels'
          Todas las etiquetas `%i', `%o' y `%t' con valores asignados.

    `values'
          Todos los átomos que son variables de usuario, no opciones de
          Maxima creadas con  `:' o `::'.

    `functions'
          Todas las funciones de usuario creadas con `:=' o `define'.

    `arrays'
          Arreglos declarados y no declarados, creados por `:', `::' o
          `:='.

    `macros'
          Cualquier macro definida por el usuario.

    `myoptions'
          Todas las opciones inicializadas por el usuario,
          independientemente de que posteriormente hayan sido devueltas
          a sus valores por defecto.

    `rules'
          Reglas de patrones y simplificación definidas por el usuario,
          creadas con `tellsimp', `tellsimpafter', `defmatch' o
          `defrule'.

    `aliases'
          Átomos que tienen un "alias" definido por el usuario, creado
          por las funciones `alias', `ordergreat' o `orderless' o por
          haber declarado el átomo como `noun' (nombre) con `declare'.

    `dependencies'
          Átomos que tienen dependencias funcionales, creados por las
          funciones `depends' o `gradef'.

    `gradefs'
          Funciones que tienen derivadas definidas por el usuario,
          creadas por la función `gradef'.

    `props'
          Todos los átomos que tengan cualquier propiedad que no sea de
          las mencionadas hasta ahora, como las establecidas por
          `atvalue', `matchdeclare', etc., así como propiedadas
          especificadas en la función `declare'.

    `let_rule_packages'
          Todos los paquetes de reglas `let' definidos por el usuario,
          junto con el paquete especial `default_let_rule_package';
          `default_let_rule_package' es el nombre del paquete de reglas
          utilizado cuando no se use ningún otro especificado por el
          usuario.


 -- Función: integerp (<expr>)
     Devuelve `true' si <expr> es un número entero y `false' en
     cualquier otro caso.

     La función `integerp' devuelve `false' si su argumento es un
     símbolo, incluso cuando éste ha sido declarado como entero.

     Ejemplos:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false


 -- Variable optativa: m1pbranch
     Valor por defecto: `false'

     La variable `m1pbranch' es la rama principal de `-1' elevado a una
     potencia. Cantidades como `(-1)^(1/3)' (esto es, un exponente
     racional impar) y `(-1)^(1/4)' (esto es, un exponente racional
     par) son tratados como sigue:

                        dominio real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       dominio complejo
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2


 -- Función: numberp (<expr>)
     Devuelve `true' si <expr> es un enúmero entero, racional, de coma
     flotante o "bigfloat", en caso contrario devuelve `false'.

     La función `numberp' devuelve `false' si su argumento es un
     símbolo, incluso cuando el argumento es un número simbólico como
     `%pi' o `%i', o aunque haya sido declarado como `even' (par),
     `odd' (impar), `integer' (entero), `rational' (racional),
     `irrational' (irracional), `real' (real), `imaginary' (imaginario)
     o `complex' (complejo).

     Ejemplos:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]


 -- Función: properties (<a>)
     Devuelve una lista con los nombres de propiedades asociadas con el
     átomo <a>.


 -- Símbolo especial: props
     `props' son átomos que tienen cualquier propiedad diferente de las
     mencionadas explícitamente en `infolists', tales como las
     especificadas por `atvalues', `matchdeclares', etc., así como las
     propiedades especificadas mediante la función `declare'.


 -- Función: propvars (<prop>)
     Devuelve una lista con aquellos átomos de la lista `props' que
     tienen la propiedad indicada por <prop>.


 -- Función: put (<átomo>, <valor>, <indicador>)
     Asigna el <valor> a la propiedad  (especificada por <indicador>)
     de <átomo>; <indicador> puede ser el nombre de cualquier propiedad
     y no solamente de aquellas definidas por el sistema.

     La función `put' evalúa sus argumentos y devuelve <valor>.

     Ejemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello


 -- Función: qput (<átomo>, <valor>, <indicador>)
     Asigna <valor> a la propiedad de <átomo> que especifique
     <indicador>. Actúa del mismo modeo que `put', excepto que sus
     argumentos no son evaluados.

     Ejemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar


 -- Función: rem (<átomo>, <indicador>)
     Elimina del <átomo> la propiedad indicada por <indicador>.


 -- Función: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Función: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Función: remove ("<a>", operator)
 -- Función: remove (<a>, transfun)
 -- Función: remove (all, <p>)
     Elimina propiedades asociadas con átomos.

     La llamada `remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' elimina la
     propiedad `p_k' del átomo `a_k'.

     La llamada `remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)'
     elimina las propiedades `<p_1>, ..., <p_n>' de los átomos <a_1>,
     ..., <a_m>. Puede tener más de un par de listas.

     La llamada `remove (all, <p>)' elimina la propiedad <p> de todos
     los átomos que la tengan.

     Las propiedades eliminadas pueden ser de las que define el
     sistema, como `function', `macro' o `mode_declare', o de las que
     define el usuario.

     La llamada `remove ("<a>", operator)' o su equivalente `remove
     ("<a>", op)' elimina de  <a> las propiedades de operador
     declaradas por `prefix', `infix', `nary', `postfix', `matchfix' o
     `nofix'. Nótese que el nombre del operador debe escribirse como
     cadena precedida de apóstrofo.

     La llamada `remove' devuelve siempre `done' independientemente que
     haya algún átomo con la propiedad especificada.


 -- Función: remvalue (<nombre_1>, ..., <nombre_n>)
 -- Función: remvalue (all)
     Elimina del sistema los valores de las variable de usuario
     <nombre_1>, ..., <nombre_n> (incluso las que tienen subíndices).

     La llamada `remvalue (all)' elimina los valores de todas las
     variables en `values', la lista de todas las variables a las que
     el usuario a dado algún nombre, pero no de aquéllas a las que
     Maxima asigna automáticamente un valor.

     Véase también `values'.


 -- Función: rncombine (<expr>)
     Transforma <expr> combinando todos los términos de <expr> que
     tengan denominadores idénticos o que difieran unos de otros por
     factores numéricos. Su comportamiento es diferente al de la
     función `combine', que combina términos con iguales denominadores.

     Haciendo `pfeformat: true' y utilizando `combine' se consiguen
     resultados similares a aquéllos que se pueden obtener con
     `rncombine', pero `rncombine' realiza el paso adicional de
     multiplicar denominadores numéricos. Esto da como resultado
     expresiones en las que se pueden reconocer algunas cancelaciones.

     Antes de utilizar esta función ejecútese `load(rncomb)'.

 -- Función: scalarp (<expr>)
     Devuelve `true' si <expr> is un número, constante  o variable
     declarada como `scalar' con `declare', o compuesta completamente
     de tales números, constantes o variables, pero que no contengan
     matrices ni listas.


 -- Función: setup_autoload (<nombre_fichero>, <función_1>, ...,
          <función_n>)
     Especifica que si alguna de las funciones <function_1>, ...,
     <function_n> es referenciada pero todavía no ha sido definida, se
     cargará <nombre_fichero> mediante una llamada a `load'. El
     <nombre_fichero> normalmente contendrá las definiciones de las
     funciones especificadas, aunque esto no es imperativo.

     La función `setup_autoload' no opera con arreglos de funciones.

     La función `setup_autoload' no evalúa sus argumentos.

     Ejemplo:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma function ultraspherical
          Warning - you are redefining the Macsyma function legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2



File: maxima.info,  Node: Reglas y patrones,  Next: Listas,  Prev: Miscelánea de opciones,  Up: Top

36 Reglas y patrones
********************

* Menu:

* Introducción a reglas y patrones::
* Funciones y variables sobre reglas y patrones::


File: maxima.info,  Node: Introducción a reglas y patrones,  Next: Funciones y variables sobre reglas y patrones,  Prev: Reglas y patrones,  Up: Reglas y patrones

36.1 Introducción a reglas y patrones
=====================================

Esta sección describe las reglas de simplificación y los patrones de
comparación definidos por el usuario. Hay dos grupos de funciones que
implementan diferentes esquemas de comparación de patrones. En un grupo
están `tellsimp', `tellsimpafter', `defmatch', `defrule', `apply1',
`applyb1' y `apply2'. En el otro, se encuentran `let' y `letsimp'.
Ambos esquemas definen patrones en términos de variables de patrones
declaradas mediante  `matchdeclare'.

   Las reglas de comparación de patrones definidas por `tellsimp' y
`tellsimpafter' se aplican automáticamente por el simplificador de
Maxima. Las reglas definidas por `defmatch', `defrule' y `let' se
aplican previa llamada a una función.

   Hay otros mecanismos para las reglas; las relativas a polinomios se
controlan mediante `tellrat' y las del álgebra conmutativa y no
conmutativa se definen en el paquete `affine'.


File: maxima.info,  Node: Funciones y variables sobre reglas y patrones,  Prev: Introducción a reglas y patrones,  Up: Reglas y patrones

36.2 Funciones y variables sobre reglas y patrones
==================================================

 -- Función: apply1 (<expr>, <regla_1>, ..., <regla_n>)
     Aplica de forma repetida la <regla_1> a <expr> hasta que falla, a
     continuación aplica repetidamente la misma regla a todas las
     subexpresiones de <expr>, de izquierda a derecha, hasta que la
     <regla_1> haya fallado en todas las subexpresiones. Llámese
     <expr_2> al resultado de transformar <expr> de esta forma.
     Entonces la <regla_2> se aplica de la misma manera comenzando en
     el nivel superior de <expr_2>. Cuando la <regla_n> falla en la
     última expresión, se devuelve el resultado.

     `maxapplydepth' es el nivel de las subexpresiones más internas
     procesadas por `apply1' y `apply2'.

     Véase también `applyb1', `apply2' y `let'.


 -- Función: apply2 (<expr>, <regla_1>, ..., <regla_n>)
     Si la <regla_1> falla en una subexpresión dada, entonces se aplica
     la <regla_2> repetidamente, etc. Sólo si todas las reglas fallan
     en una subexpresión serán aplicadas todas las reglas de forma
     repetida a la siguiente subexpresión. Si alguna de las reglas
     tiene éxito entonces la misma subexpresión es reprocesada,
     comenzando por la primera regla.

     `maxapplydepth' es el nivel de las subexpresiones más internas
     procesadas por `apply1' y `apply2'.

     Véase también `applyb1' y `let'.


 -- Función: applyb1 (<expr>, <regla_1>, ..., <regla_n>)
     Aplica la <regla_1> reiteradamente hasta la subexpresión más
     interna de <expr> hasta que falle, a continuación pasa a aplicar
     la misma regla en un nivel superior (esto es, en subexpresiones
     más grandes), hasta que la <regla_1> falle en la expresión de
     nivel más alto. Después se aplica la <regla_2> de la misma manera
     al resultado obtenido de <regla_1>. Tras la aplicación de la
     <regla_n> a la expresión de mayor nivel, se devuelve el resultado.

     La función `applyb1' es similar a `apply1' pero opera de
     abajo-arriba, en lugar de arriba-abajo.

     `maxapplyheight' es la máxima altura a la que llega `applyb1'
     antes de terminar su cometido.

     Véase también `apply1', `apply2' y `let'.


 -- Variable opcional: current_let_rule_package
     Valor por defecto: `default_let_rule_package'

     La variable `current_let_rule_package' es el nombre del paquete de
     reglas que están utilizando las funciones del paquete `let'
     (`letsimp', etc.), a menos que se especifique otro paquete de
     reglas. A esta variable se le puede asignar el nombre de cualquier
     paquete de reglas definido por medio de la instrucción `let'.

     Si se hace la llamada `letsimp (expr, rule_pkg_name)', el paquete
     de reglas `rule_pkg_name' será utilizado únicamente para esa
     llamada y el valor de `current_let_rule_package' no cambia.


 -- Variable opcional: default_let_rule_package
     Valor por defecto: `default_let_rule_package'

     La variable `default_let_rule_package' es el nombre del paquete de
     reglas utilizado cuando el usuario no especifica otro
     explícitamente con `let' o cambiando el valor de
     `current_let_rule_package'.


 -- Función: defmatch (<nombre_prog>, <patrón>, <x_1>, ..., <x_n>)
 -- Función: defmatch (<progname>, <pattern>)
     Define una función `<nombre_prog>(<expr>, <x_1>, ..., <x_n>)' que
     analiza si <expr> coincide con el <patrón>.

     El argumento <patrón> es una expresión que contiene los argumentos
     de patrón <x_1>, ..., <x_n> y algunas variables de patrón.  Los
     argumentos de patrón se dan de forma explícita como argumentos a
     `defmatch', mientras que las variables de patrón se declaran
     mediante la función `matchdeclare'.  Cualquier variable no
     declarada bien como variable patrón en `matchdeclare', bien como
     argumento patrón en `defmatch' se hace coincidir con ella misma.

     El primer argumento de la función definida <nombre_prog> es una
     expresión a ser comparada con el patrón y los demás argumentos son
     los argumentos que se corresponden con las variables ficticias
     <x_1>, ..., <x_n> del patrón.

     Si el resultado de la comparación es positivo, <nombre_prog>
     devuelve una lista de ecuaciones cuyos miembros izquierdos son los
     argumentos y variables de patrón, y cuyos miembros derechos son
     las subexpresiones en las que se han producido las coincidencias
     con patrones. A las variables de patrón, no a los argumentos, se
     les asignan las subexpresiones con las que coinciden. Si la
     comparación falla, <nombre_prog> devuelve `false'.

     Un patrón literal, es decir, que no contiene ni argumentos ni
     variables de patrón, devuelve `true' en caso de coincidencia.

     A literal pattern (that is, a pattern which contains neither
     pattern arguments nor pattern variables) returns `true' if the
     match succeeds.

     Véase también `matchdeclare', `defrule', `tellsimp' y
     `tellsimpafter'.

     Ejemplos:

     Define una función `linearp(expr, x)' que comprueba si `expr' es
     de la forma `a*x + b', donde ni `a' ni `b' contienen a `x' y `a'
     es no nulo.  La función definida reconoce expresiones lineales
     respecto de cualquier variable, pues el argumento de patrón `x' es
     pasado a `defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)),
                              b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Define una función `linearp(expr)' que comprueba si `expr' es de
     la forma `a*x + b', donde ni `a' ni `b' contienen a `x' y `a' es
     no nulo.  La función definida sólo reconoce expresiones lineales
     únicamente respecto de `x', pues no se le pasa a `defmatch' nigún
     argumento de patrón

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)),
                              b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Define una función `checklimits(expr)' que comprueba si `expr' es
     una integral definida.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]


 -- Función: defrule (<nombre_regla>, <patrón>, <reemplazamiento>)
     Define y da nombre a una regla de reemplazamiento para el patrón
     dado. Si la regla <nombre_regla> es aplicada a una expresión (por
     `apply1', `applyb1' o `apply2'), cada subexpresión que coincida
     con el patrón será reemplazada por el contenido de
     <reemplazamiento>.

     Las propias reglas pueden ser tratadas como funciones que
     transforman una expresión mediante una operación consistente en la
     búsqueda de una coincidencia y posterior aplicación de un
     reemplazamiento. Si la comparación falla, la función que
     implementa la regla devuelve `false'.


 -- Función: disprule (<nombre_regla_1>, ..., <nombre_regla_n>)
 -- Función: disprule (all)
     Muestra las reglas de <nombre_regla_1>, ..., <nombre_regla_n>, tal
     como son devueltas por `defrule', `tellsimp' o `tellsimpafter', o
     un patrón definido por `defmatch'.  Cada regla se muestra con una
     etiqueta de expresión intermedia (`%t').

     La llamada `disprule (all)' muestra todas las reglas.

     La función `disprule' no evalúa sus argumentos y devuelve la lista
     de etiquetas de expresiones intermedias correspondientes a las
     reglas mostradas.

     Véase también `letrules', que muestra las reglas definidas por
     `let'.

     Ejemplos:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
               +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]


 -- Función: let (<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>)
 -- Función: let ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
          <nombre_paquete>)
     Define una regla de sustitución para `letsimp' tal que <prod> es
     sustituido por <repl>, donde <prod> es un producto de potencias
     positivas o negativas de los términos siguientes:

        * Átomos que `letsimp' buscará a menos que antes de llamar a
          `letsimp' se utilice la función `matchdeclare' para asociar
          un predicado con el átomo. En este caso `letsimp' hará
          coincidir el átomo con cualquier término del producto que
          satisfaga el predicado.

        * Expresiones básicas como `sin(x)', `n!', `f(x,y)', etc.  Como
          en el caso anterior, `letsimp' buscará coincidencias exactas,
          a menos que se utilice `matchdeclare' para asociar un
          predicado con el argumento de la expresión básica (`sin(x)',
          `n!', `f(x,y)', ...).

     Si se incluye un predicado en la función `let' seguido de una
     lista de argumentos, una coincidencia aceptable  (es decir, una
     que fuese aceptada si se hubiese omitido el predicado) se aceptará
     sólo si `predname (arg_1', ..., arg_n')' vale `true', donde
     <arg_i'> es el valor coincidente con <arg_i>.  El argumento
     <arg_i> puede ser el nombre de cualquier átomo o el argumento de
     cualquier expresión básica que aparezca en <prod>.  <repl> puede
     ser cualquier expresión racional. Si cualquiera de los átomos o
     argumentos de <prod> aparece en <repl> se llevan a cabo las
     sustituciones correspondientes.

     La variable global `letrat' controla la simplificación de los
     cocientes por `letsimp'. Cuando `letrat' vale  `false', `letsimp'
     simplifica separadamente el numerador y denominador de  <expr> y
     no simplifica el cociente. Sustituciones como que `n!/n' se
     reduzca a `(n-1)!' ya no se realizarán. Cuando  `letrat' vale
     `true', entonces se simplifican el numerador, el denominador y el
     cociente, en este orden.

     Estas funciones de sustitución permiten al usuario trabajar con
     varios paquetes de reglas al mismo tiempo. Cada paquete de reglas
     puede contener cierto número de reglas `let' que son referenciadas
     por un nombre dado por el usuario.  `let ([<prod>, <repl>,
     <predname>, <arg_1>, ..., <arg_n>], <nombre_paquete>)' añade la
     regla  <predname> al paquete de reglas  <nombre_paquete>. `letsimp
     (<expr>, <package_name>)' aplica las reglas de <nombre_paquete>.
     La llamada `letsimp (<expr>, <nombre_paquete1>, <nombre_paquete2>,
     ...)' es equivalente a `letsimp (<expr>, <nombre_paquete1>)'
     seguida de `letsimp (%, <nombre_paquete2>)', ....

     `current_let_rule_package' es el nombre del paquete de reglas que
     se está utilizando. A esta variable se le puede asignar el nombre
     de cualquier paquete de reglas definido mediante el comando `let'.
     Siempre que una de las funciones incluidas en el paquete  `let'
     sean invocadas sin nombre de paquete, se utilizará el paquete cuyo
     nombre se guarde en `current_let_rule_package'. Si se hace una
     llamada tal como `letsimp (<expr>, <rule_pkg_name>)', el paquete
     de reglas <rule_pkg_name> es utilizado solamente para ese comando
     `letsimp', sin efectuarse cambios en `current_let_rule_package'. A
     menos que se indique otra cosa, `current_let_rule_package' toma
     por defecto el valor de `default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1


 -- Variable opcional: letrat
     Valor por defecto: `false'

     Cuando `letrat' vale `false', `letsimp' simplifica separadamente
     el numerador y denominador de una fracción sin simplificar luego
     el cociente.

     Cuando `letrat' vale `true', se simplifican el numerador,
     denominador y cociente, por este orden.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!


 -- Función: letrules ()
 -- Función: letrules (<nombre_paquete>)
     Muestra las reglas de un paquete de reglas. La llamada `letrules
     ()' muestra las reglas del paquete de reglas actual. La llamada
     `letrules (<nombre_paquete>)' muestra las reglas de
     <nombre_paquete>.

     El paquete de reglas actual tiene su nombre almacenado en by
     `current_let_rule_package'. A menos que se indique de otra manera,
     `current_let_rule_package' toma por defecto el valor de
     `default_let_rule_package'.

     Véase también `disprule', que muestra las reglas definidas por
     `tellsimp' y `tellsimpafter'.


 -- Función: letsimp (<expr>)
 -- Función: letsimp (<expr>, <nombre_paquete>)
 -- Función: letsimp (<expr>, <nombre_paquete_1>, ...,
          <nombre_paquete_n>)
     Aplica repetidamente las reglas definidas por `let' hasta que no
     se puedan hacer más cambios en <expr>.

     La llamada `letsimp (<expr>)' utiliza las reglas de
     `current_let_rule_package'.

     La llamada `letsimp (<expr>, <nombre_paquete>)' utiliza las reglas
     de <nombre_paquete> sin efectuar cambios en
     `current_let_rule_package'.

     La llamada `letsimp (<expr>, <nombre_paquete_1>, ...,
     <nombre_paquete_n>)' es equivalente a `letsimp (<expr>,
     <nombre_paquete_1>', seguida de  `letsimp (%, <nombre_paquete_2>)'
     y así sucesivamente.


 -- Variable opcional: let_rule_packages
     Valor por defecto: `[default_let_rule_package]'

     La variable `let_rule_packages' guarda una lista con todos los
     paquetes de reglas definidos por el usuario, junto con el paquete
     por defecto `default_let_rule_package'.


 -- Función: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Asocia un predicado <pred_k> con una variable o lista de variables
     <a_k>, de forma que  <a_k> se comparará con expresiones para las
     cuales el predicado devuelva algo que no sea `false'.

     Un predicado puede ser el nombre de una función, una expresión
     lambda, una llamada a función, una llamada a una expresión lambda
     sin el último argumento, `true' o `all'.  Cualquier expresión se
     hace coincidir con `true' o `all'.

     Si el predicado se especifica como una llamada a función o a una
     expresión lambda, la expresión a ser analizada es añadida a la
     lista de argumentos, siendo los argumentos evaluados en el momento
     de ser evaluada la comparación.  En cambio, si el predicado se
     especifica como un nombre de función o como una expresión lambda,
     la expresión a ser analizada será su único argumento. No es
     necesario definir una función de predicado cuando se hace una
     llamada a `matchdeclare'; el predicado no se evalúa hasta que se
     ensaya  una comparación.

     Un predicado puede devolver tanto una expresión booleana, como
     `true' o `false'.  Las expresiones booleanas se evalúan con `is'
     dentro de la regla, por lo que no es necesario llamar a `is' desde
     dentro del predicado.

     Si una expresión satisface un predicado, se asigna a la variable
     de comparación la expresión, excepto cuando las variables de
     comparación son operandos de sumas `+' o multiplicaciones `*'.
     Solamente las sumas y multiplicaciones son tratadas de forma
     especial; los demás operadores n-arios (tanto los del sistema como
     los definidos por el usuario) son tratados como funciones
     ordinarias.

     En el caso de sumas y multiplicaciones, a la variable de
     comparación se le puede asignar una expresión simple que satisfaga
     el predicado de comparación, o una suma o producto,
     respectivamente, de tales expresiones. Los predicados son
     evaluados en el orden en el que sus variables asociadas aparecen
     en el patrón de comparación, y un término que satisfaga más de un
     predicado es tomado por el primer predicado que satisfaga. Cada
     predicado se compara con todos los operandos de la suma o producto
     antes de ser evaluado el siguiente predicado. Además, si 0 o 1,
     respectivamente, satisface un predicado de comparación, y no hay
     otros términos que lo satisfagan, se asignará el 0 o 1 a la
     variable de comparación asociada al predicado.

     El algoritmo para procesar patrones de suma y multiplicación hace
     que los resultados de algunas comparaciones dependan del orden de
     los términos en el patrón de comparación y en la expresión a ser
     comparada. Sin embargo, si todos los predicados de comparación son
     mutuamente excluyentes, el resultado de la comparación no depende
     para nada de la ordenación, puesto que un predicado de comparación
     no puede aceptar términos aceptados por otros predicados.

     Invocando `matchdeclare' con una variable <a> como argumento
     cambia la propiedad de `matchdeclare' para  <a>, si ya había una
     declarada; solamente el `matchdeclare' más reciente está activo
     cuando se define una regla. Cambios posteriores en la propiedad de
     `matchdeclare' (via `matchdeclare' o `remove') no afectan a las
     reglas existentes.

     `propvars (matchdeclare)' devuelve la lista de todas las variables
     para las cuales hay una propiedad de `matchdeclare'. La llamada
     `printprops (<a>, matchdeclare)' devuelve el predicado para la
     variable `a'.  La llamada `printprops (all, matchdeclare)'
     devuelve la lista de predicados de todas las variables de
     `matchdeclare'. La llamada `remove (<a>, matchdeclare)' borra la
     propiedad `matchdeclare' de <a>.

     Las funciones `defmatch', `defrule', `tellsimp', `tellsimpafter' y
     `let' construyen reglas que analizan expresiones mediante patrones.

     `matchdeclare' no evalúa sus argumentos y siempre devuelve `done'.

     Ejemplos:

     Un predicado puede ser el nombre de una función, una expresión
     lambda, una llamada a función, una llamada a una expresión lambda
     sin el último argumento, `true' o `all'.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     Si una expresión satisface un predicado, se asigna a la variable
     de comparación la expresión.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     En el caso de sumas y multiplicaciones, a la variable de
     comparación se le puede asignar una expresión simple que satisfaga
     el predicado de comparación, o una suma o producto,
     respectivamente, de tales expresiones.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb,
                        ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb,
                         ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]


 -- Función: matchfix (<ldelimiter>, <rdelimiter>)
 -- Función: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)
     Declara un operador "matchfix" con delimitadores a la izquierda y
     derecha, <ldelimiter> y <rdelimiter>, respectivamente. Los
     delimitadores son cadenas alfanuméricas.

     Un operador "matchfix" es una función con un número arbitrario de
     argumentos, de manera que los argumentos se presentan entre los
     delimitadores de la izquierda y derecha. Los delimitadores pueden
     ser cualquier tipo de cadena, en tanto que el analizador
     sintáctico pueda distinguirlos de los operandos y de expresiones
     con operadores. En la práctica esto excluye delimitadores como
     `%', `,', `$' y `;',  necesitando aislar los delimitadores con
     espacios en blanco. El delimitador de la derecha puede ser igual o
     diferente del de la izquierda.

     Un delimitador de la izquierda sólo puede asociarse con un único
     delimitador de la derecha; dos operadores "matchfix" diferentes no
     pueden tener el mismo delimitador por la izquierda.

     Un operador ya existente puede declararse como operador "matchfix"
     sin necesidad de que cambie el resto de propiedades. En
     particular, los operadores de Maxima tales como la suma `+' pueden
     ser declarados como "matchfix".

     La llamada `matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>,
     <pos>)' declara el argumento <arg_pos> y el resultado <pos>, así
     como los delimitadores  <ldelimiter> y <rdelimiter>.

     Los argumentos <arg_pos> y <pos> son tipos de funciones,
     reconociéndose como tales: `expr', `clause' y `any', los cuales
     hacen referencia a una expresión algebraica, booleana o de
     cualquier otro tipo, respectivamente.  Maxima puede detectar
     ciertos errores sintácticos comparando el tipo de expresión
     declarado con el de la expresión actual.

     La función que ejecutará una operación "matchfix" será una típica
     función definida por el usuario. La función de operador se define
     por el método habitual con  `:=' o `define'. Los argumentos pueden
     escribirse entre los delimitadores, o con el delimitador izquierdo
     como una cadena precedida de apóstrofo y seguidamente los
     argumentos entre paréntesis. La llamada `dispfun (<ldelimiter>)'
     muestra la definición de la función.

     El único operador "matchfix" de Maxima es el constructor de listas
     `[ ]'. Los paréntesis  `( )' y las comillas dobles  `" "'  actúan
     como operadores "matchfix", pero son tratados como operadores
     "matchfix" por el analizador sintáctico de Maxima.

     Ejemplos:

        * Los delimitadores pueden ser practicamente cualquier cadena.

          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

        * Los operadores "matchfix" son funciones definidas por el
          usuario.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15


 -- Función: remlet (<prod>, <nombre>)
 -- Función: remlet ()
 -- Función: remlet (all)
 -- Función: remlet (all, <nombre>)
     Elimina la última regla de sustitución <prod> -> repl que haya
     sido definida por la función `let'. Si se suministar el nombre la
     regla será borrada del paquete con ese mismo nombre.

     Las llamadas `remlet()' y `remlet(all)' eliminan todas las reglas
     de sustitución del paquete de reglas actual. Si se suministra el
     nombre de un paquete de reglas, como en `remlet (all, <nombre>)',
     el paquete de reglas con ese  <nombre> es también eliminado.

     Si es necesario cambiar una sustitución haciendo uso de la misma
     producción, no es necesario llamar a  `remlet', simplemente
     redefínase la sustitución utilizando la misma producción con la
     función  `let' junto con el nuevo reemplazamiento y/o nombre de
     predicado. De ser llamado nuevamente `remlet (<prod>)' la
     sustitución original sería recuperada.

     Véase también `remrule', que elimina una regla definida por
     `tellsimp' o `tellsimpafter'.


 -- Función: remrule (<op>, <nombre_regla>)
 -- Función: remrule (<op>, all)
     Elimina las reglas previamente definidas por `tellsimp' o
     `tellsimpafter'.

     La llamada `remrule (<op>, <nombre_regla>)' elimina la regla de
     nombre  <nombre_regla> del operador <op>.

     Independientemente de que  <op> sea un operador propio de Maxima o
     haya sido definido por el usario (como los establecidos por
     `infix', `prefix', etc.), tanto <op> como <rulename> deben ir
     encerrados entre comillas dobles.

     La llamada `remrule (<function>, all)' borra todas las reglas para
     el operador <op>.

     Véase también `remlet', que elimina una regla definida mediante
     `let'.

     Ejemplos:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@@", "@@rule1");
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]


 -- Función: tellsimp (<patrón>, <reemplazamiento>)
     La función `tellsimp' es similar a  `tellsimpafter' pero coloca
     nueva información antes que la antigua, de manera que se aplica
     antes que las reglas de simplificación de Maxima.

     La función `tellsimp' se utiliza cuando es importante utilizar la
     expresión antes de que el simplificador opere sobre ella; por
     ejemplo, cuando el simplificador ya "sabe" algo sobre una
     expresión, pero lo que devuelve no es lo que quiere el usuario. En
     cambio, cuando  el simplificador ya "sabe" algo sobre una
     expresión pero lo que devuelve no es lo suficiente para el
     usuario, entonces éste podrá estar interesado en utilizar
     `tellsimpafter'.

     El patrón no puede ser una suma, ni un producto, ni una variable
     ni un número.

     `rules' es la lista de reglas definidas por `defrule', `defmatch',
     `tellsimp' y `tellsimpafter'.

     Ejemplos:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)


 -- Función: tellsimpafter (<patrón>, <reemplazamiento>)
     Define una regla de simplificación que el simplificador aplicará
     después de las reglas de simplificación propias de de Maxima. El
     <patrón> es una expresión que contiene variables de patrón
     (declaradas por `matchdeclare') junto con otros átomos y
     operadores. El contenido de <reemplazamiento> sustituye una
     expresión que coincida con el patrón; a las variables de patrón en
     <reemplazamiento> se les asignan los valores coincidentes en la
     expresión.

     El <patrón> puede ser una expresión no atómica en la que el
     operador principal no sea una variable de patrón; la regla de
     simplificación se asocia con el operador principal. Los nombres de
     las funciones (con una excepción que se indica más abajo), listas
     y arrays pueden aparecer en el <patrón> como operador principal
     sólo como literales (no variables de patrones); esto excluye
     expresiones como  `aa(x)' y `bb[y]', si tanto `aa' como `bb' son
     patrones de variables. Nombres de funciones, listas y arrays que
     sean variables de patrón pueden aparecer como operadores que no
     sean el operador principal de  <patrón>.

     Hay una excepción a la regla indicada más arriba concerniente a
     los nombres de funciones. El nombre de una función subindicada en
     una expresión tal como `aa[x](y)' puede ser una variable de patrón
     porque el operador principal no es  `aa' sino el átomo de Lisp
     `mqapply'. Esta es una consecuencia de la representación de
     expresiones que contienen funciones subindicadas.

     Las reglas de simplificación se aplican tras las evaluaciones (a
     menos que se supriman con el apóstrofo o la variable `noeval').
     Las reglas establecidas por `tellsimpafter' se aplican en el orden
     en que han sido definidas y después de las reglas propias de
     Maxima. Las reglas se aplican de abajo arriba, esto es, se aplican
     primero a las subexpresiones antes que a toda la expresión. Puede
     ser necesario simplificar repetidamente un resultado (por ejemplo,
     mediante el operador de doble comilla simple `''' o la variable
     `infeval') para asegurar que se aplican todas las reglas.

     Las variables de patrón se tratan como variables locales en las
     reglas de simplificación. Una vez definida una regla, el valor de
     una variable de patrón no afecta a la regla, ni se ve influenciada
     poe ésta. Una asignación a una variable de patrón que resulta de
     la aplicación exitosa de una regla no afecta a la asignación
     actual de la variable de patrón. Sin embargo, como cualquier otro
     átomo de Maxima, las propiedades de las variables de patrón (tal
     como se definen con `put' y sus funciones relacionadas) son
     globales.

     La regla construida por  `tellsimpafter' es nombrada detrás del
     operador principal de <patrón>. Reglas para operadores de Maxima y
     operadores definidos por el usuario con `infix', `prefix',
     `postfix', `matchfix' y `nofix', tienen nombres que son cadenas
     alfanuméricas de Maxima. Reglas para otras funciones tienen
     nombres que son identificadores ordinarios de Maxima.

     El tratamiento de formas nominales y verbales es hasta cierto
     punto confuso. Si se define una regla para una forma nominal (o
     verbal)  y ya existe una regla para la correspondiente forma
     verbal (o nominal), la regla recién definida se aplica a ambas
     formas (nominal y verbal). Si no existe regla para una forma
     verbal (o nominal) la regla recién definida se aplica únicamente a
     la forma nominal (o verbal).

     La regla construida por  `tellsimpafter' es una típica función de
     Lisp. Si el nombre de la regla es `$foorule1', la sentencia `:lisp
     (trace $foorule1)' hace una traza de la función y  `:lisp
     (symbol-function '$foorule1' muestra su definición.

     La función `tellsimpafter' no evalúa sus argumentos y devuelve la
     lista de reglas para el operador principal de  <patrón>, incluida
     la regla recién establecida.

     Véanse también `matchdeclare', `defmatch', `defrule', `tellsimp',
     `let', `kill', `remrule' y `clear_rules'.

     Ejemplos:

     <pattern> puede ser cualquier expresión no atómica en la que el
     operador principal no sea una variable de patrón.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Las reglas se aplican en el orden en que se definen. Si dos reglas
     coinciden con una expresión, se aplica aquélla que haya sido
     definida en primer lugar.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     Las variables de patrón se tratan como variables locales en las
     reglas de simplificación.  (Compárese con `defmatch', que trata
     las variables de patrón como globales.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Como cualquier otro átomo, las propiedades de las variables de
     patrón son globales, incluso cuando sus valores sean locales. En
     este ejemplo se declara una propiedad de asignación a treavés de
     `define_variable'. Esta es una propiedad del átomo  `bb' en todo
     Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Las reglas se nombran después de los operadores principales. Los
     nombres de reglas tanto para las funciones de Maxima como para las
     definidas por el usuario son cadenas alfanuméricas, mientras que
     los nombres de las otras funciones son identificadores típicos.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4,
          htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1,
          foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
          (%o10)                    [false, true]
          (%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
          (%o11)                    [true, true]
          (%i12) remrule (foo, foorule1);
          (%o12)                         foo
          (%i13) remrule ("^", "^rule1");
          (%o13)                          ^

     Un ejemplo de producto anticonmutativo.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0


 -- Función: clear_rules ()
     Ejecuta `kill (rules)' y después inicializa el siguiente número de
     regla a 1 para la adición `+', multiplicación `*' y exponenciación
     `^'.



File: maxima.info,  Node: Listas,  Next: Conjuntos,  Prev: Reglas y patrones,  Up: Top

37 Listas
*********

* Menu:

* Introducción a las listas::
* Funciones y variables para listas::


File: maxima.info,  Node: Introducción a las listas,  Next: Funciones y variables para listas,  Prev: Listas,  Up: Listas

37.1 Introducción a las listas
==============================

Las listas son bloques de construcción básica para Maxima y Lisp. Todos
los tipos de datos diferentes a los arreglos, tablas mixtas o números
son representados como listas Lisp, estas listas Lisp tienen la forma

     ((MPLUS) $A 2)

para indicar la expresión `a+2'. Al nivel de Maxima se observará la
notación infija `a+2'. Maxima también tiene listas con el formato

     [1, 2, 7, x+y]

para una lista de 4 elementos. Internamente esto se corresponde con una
lista Lisp de la forma

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

El elemento que denota el tipo de expresión en Maxima es también una
lista, la cual tras ser analizada y simplificada tomará la forma

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Funciones y variables para listas,  Prev: Introducción a las listas,  Up: Listas

37.2 Funciones y variables para listas
======================================

 -- Función: append (<lista_1>, ..., <lista_n>)
     Devuelve una lista cuyos elementos son los de la lista <lista_1>
     seguidos de los de <lista_2>, ...  La función `append' también
     opera con expresiones generales, como la llamada `append (f(a,b),
     f(c,d,e));', de la que se obtiene `f(a,b,c,d,e)'.

     Tecléese `example(append);' para ver un ejemplo.


 -- Función: assoc (<clave>, <lista>, <valor_por_defecto>)
 -- Function: assoc (<clave>, <lista>)
     Esta función busca la <clave> en el lado derecho de la  <lista>,
     la cual es de la forma `[x,y,z,...]', donde cada elemento  es una
     expresión formada por un operador binario y dos elementos. Por
     ejemplo, `x=1', `2^3', `[a,b]' etc.  La <clave> se compara con el
     primer operando. La función `assoc' devuelve el segundo operando
     si se encuentra con que la `clave' coincide.  Si la `clave' no
     coincide entonces devuelve el valor <valor_por_defecto>. El
     argumento <valor_por_defecto> es opcional; en caso de no estar
     presente, se devolverá `false'.


 -- Función: atom (<expr>)
     Devuelve `true' si <expr> es un átomo (número, nombre o cadena
     alfanumérica) y `false' en caso contario. Así, `atom(5)' devolverá
     `true', mientras que `atom(a[1])' y `atom(sin(x))' darán como
     resultado `false' (dando por hecho que tanto `a[1]' como `x' no
     tienen valores asignados).


 -- Función: cons (<expr>, <lista>)
     Devuelve una nueva lista en la que el elemento <expr> ocupa la
     primera posición, seguido de los elementos de <lista>. La función
     `cons' también opera con otro tipo de expresiones, como  `cons(x,
     f(a,b,c));'  ->  `f(x,a,b,c)'.


 -- Función: copylist (<lista>)
     Devuelve una copia de la <lista>.


 -- Función: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)
     Crea una lista mediante la evaluación de <form> con <x_1> tomando
     cada uno de los valores de <list_1>, para cada uno de estos
     valores liga <x_2> con cada elemento de <list_2>, .... El número
     de elementos en el resultado será el producto del número de
     elementos en cada lista. Cada variable <x_i> debe ser un símbolo y
     no será evaluado. La lista de argumentos será evaluada una vez al
     comienzo de la iteración.

     Por ejemplo:
          (%i1) create_list(x^i,i,[1,3,7]);
                           3   7
          (%o1)       [x, x , x ]

     Con una doble iteración:

          (%i1) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o1) [[a, e], [a, f], [a, h], [b, e], [b, f], [b, h]]

     En lugar de <list_i> se pueden suministrar dos argumentos cada uno
     de los cuales debería poder evaluarse a un número, los cuales
     serán los límites inferior y superior, ambos inclusive, para cada
     iteración.

     Por ejemplo:
          (%i1) create_list([i,j],i,[1,2,3],j,1,i);
          (%o1) [[1, 1], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]]

     Nótese que los límites o lista para la variable `j' pueden depender
     del valor actual de `i'.

 -- Función: delete (<expr_1>, <expr_2>)
 -- Función: delete (<expr_1>, <expr_2>, <n>)
     Elimina las expresiones <expr_1> de <expr_2>. La expresión
     <expr_1> a eliminar puede ser un sumando de <expr_2> (en caso de
     que ésta sea una suma) o un factor de <expr_2> (si se trata de un
     producto).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     La llamada `delete(<expr_1>, <expr_2>, <n>)' elimina las primeras
     <n> apariciones de <expr_1> en  <expr_2>.  En caso de que <expr_1>
     aparezca menos de <n> veces dentro de la expresión de referencia
     <expr_2> entonces se eliminan todas ellas.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)


 -- Función: eighth (<expr>)
     Devuelve el octavo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: endcons (<expr>, <lista>)
     Devuelve una nueva lista formada por los elementos de `lista'
     seguidos de los de <expr>. La función `endcons' también opera con
     expresiones generales, por ejemplo `endcons(x, f(a,b,c));'  ->
     `f(a,b,c,x)'.


 -- Función: fifth (<expr>)
     Devuelve el quinto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: first (<expr>)
     Devuelve la primera parte de <expr>, que puede consistir en el
     primer elemento de una lista, la primera fila de una matriz, el
     primer término de una suma, etc. Nótese que tanto `first' como sus
     funciones relacionadas, `rest' y `last', operan sobre la forma en
     la que <expr> es mostrada por Maxima, no sobre la forma en la que
     es introducida la expresión. Sin embargo, cuando la variable
     `inflag' toma el valor `true' estas funciones tendrán en cuenta el
     formato interno de <expr>. Téngase en cuenta que el simplificador
     reordena las expresiones.  Así, `first(x+y)' devolverá `x' si
     `inflag' vale `true' y `y' cuando `inflag' tome el valor `false'
     (`first(y+x)' devuelve el mismo resultado). Las funciones `second'
     ... `tenth' devuelven desde el segundo hasta el décimo elemento
     del argumento de entrada.


 -- Función: fourth (<expr>)
     Devuelve el cuarto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: get (<a>, <i>)
     Recupera la propiedad de usuario indicada por <i> asociada al
     átomo <a> o devuelve `false' si <a> no tiene la propiedad <i>.

     La función `get' evalúa sus argumentos.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]


 -- Función: join (<l>, <m>)
     Crea una nueva lista con los elementos de las listas <l> y <m>
     alternados.  El resultado tiene como elementos `[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]'.  Las listas <l> y <m> pueden contener
     cualquier tipo de elementos.

     Si las listas son de diferente longitud, `join' ignora los
     elementos sobrantes de la lista más larga.

     Maxima da error si o bien <l> o <m> no son listas.

     Ejemplos:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]


 -- Función: last (<expr>)
     Devuelve la última parte (término, fila, elemento, etc.) de <expr>.


 -- Función: length (<expr>)
     Devuelve (por defecto) el número de partes de que consta <expr> en
     la versión correspondiente a la que muestra.  En el caso de
     listas, se devuelve el número de elementos, si se trata de
     matrices el número de filas y se se trata de sumas el número de
     términos o sumandos (véase `dispform').

     La función `length' se ve afectada por el valor de la variable
     `inflag'.  Así, `length(a/(b*c));' devuelve 2 si `inflag' vale
     `false' (dando por hecho que `exptdispflag' vale `true'), pero
     devuelve 3 si `inflag' vale `true' (ya que la representación
     interna es `a*b^-1*c^-1').


 -- Variable opcional: listarith
     Valor por defecto: `true'

     Cuando vale `false' provoca que no se realicen operaciones
     aritméticas con listas;  cuando vale `true', las operaciones con
     listas y matrices son contagiosas, en el sentido de que las listas
     se transforman en matrices, retornando resultados de este último
     tipo. Sin embargo, operaciones que involucren listas con listas
     devolverán también listas.


 -- Función: listp (<expr>)
     Devuelve el valor `true' si <expr> es una lista, y `false' en caso
     contrario.


 -- Función: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Función: makelist (<expr>, <x>, <list>)
     Construye y devuelve una lista, siendo cada uno de sus elementos
     generados por <expr>.

     La llamada `makelist (<expr>, <i>, <i_0>, <i_1>)' devuelve una
     lista cuyo `j'-ésimo elemento es igual a `ev (<expr>, <i>=j)',
     tomando  `j' los valores enteros entre  <i_0> y <i_1>.

     La llamada `makelist (<expr>, <x>, <list>)' devuelve una lista
     cuyo `j'-ésimo elemento es igual a `ev (<expr>, <x>=<list>[j])',
     tomando  `j' los valores enteros entre  1 through `length
     (<list>)'.

     Ejemplos:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]


 -- Función: member (<expr_1>, <expr_2>)
     Devuelve `true' si `is(<expr_1> = <a>)' para algún elemento <a> de
     `args(<expr_2>)', en caso contrario devuelve `false'.

     Normalmente, `expr_2' será una lista, en cuyo caso `args(<expr_2>)
     = <expr_2>', y la comprobación será si `is(<expr_1> = <a>)' para
     algún elemento <a> de `expr_2'.

     La función `member' no inspecciona las partes de los argumentos de
     `expr_2', por lo que puede devolver `false' si `expr_1' es parte
     de alguno de los argumentos de `expr_2'.

     Véase también `elementp'.

     Ejemplos:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true


 -- Función: ninth (<expr>)
     Devuelve el noveno elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: unique (<L>)
     Devuelve la lista <L> sin redundancias, es decir, sin elementos
     repetidos

     Cuando ninguno de los elementos de <L> está repetido, `unique'
     devuelve una réplica de <L>, no la propia <L>.

     Si <L> no es una lista, `unique' devuelve <L>.

     Ejemplo:

          (%i1) unique ([1, %pi, a + b, 2, 1, %e, %pi, a + b, [1]]);
          (%o1)              [1, 2, %e, %pi, [1], b + a]

 -- Función: rest (<expr>, <n>)
 -- Función: rest (<expr>)
     Devuelve <expr> sin sus primeros <n> elementos si <n> es positivo,
     o sus últimos `- <n>' elementos si <n> es negativo. En caso de que
     <n> tome el valor 1 puede ser omitido. La expresión  <expr> puede
     ser una lista, una matriz o cualquier otra expresión.


 -- Función: reverse (<lista>)
     Invierte el orden de los elementos de la <lista> (no los propios
     elementos). La función `reverse' también opera sobre expresiones
     generales, como en  `reverse(a=b);' gives `b=a'.


 -- Función: second (<expr>)
     Devuelve el segundo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: seventh (<expr>)
     Devuelve el séptimo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: sixth (<expr>)
     Devuelve el sexto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: sublist_indices (<L>, <P>)
     Devuelve los índices de los elementos `x' de la lista <L> para la
     cual el predicado `maybe(<P>(x))' devuelve `true', lo que excluye
     a `unknown' y a `false'.  <P> puede ser el nombre de una función o
     de una expresión lambda.  <L> debe ser una lista literal.

     Ejemplos:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b],
                              lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b],
                              symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0],
                              identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]


 -- Función: tenth (<expr>)
     Devuelve el décimo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: third (<expr>)
     Devuelve el tercer elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.



File: maxima.info,  Node: Conjuntos,  Next: Definición de Funciones,  Prev: Listas,  Up: Top

38 Conjuntos
************

* Menu:

* Introducción a los conjuntos::
* Funciones y variables para los conjuntos::


File: maxima.info,  Node: Introducción a los conjuntos,  Next: Funciones y variables para los conjuntos,  Prev: Conjuntos,  Up: Conjuntos

38.1 Introducción a los conjuntos
=================================

Maxima dispone de funciones para realizar operaciones con conjuntos,
como la intersección o la unión. Los conjuntos deben ser finitos y
definidos por enumeración. Maxima trata a los conjuntos y a las listas
como objectos de distinta naturaleza, lo que permite trabajar con
conjuntos cuyos elementos puedan ser también conjuntos o listas.

   Además de funciones para operar con conjuntos finitos, Maxima
dispone también de algunas funciones sobre combinatoria, como los
números de Stirling de primera y segunda especie, números de Bell,
coeficientes multinomiales, particiones de enteros no negativos y
algunos otros. Maxima también define la función delta de Kronecker.

38.1.1 Utilización
------------------

Para construir un conjunto cuyos elementos sean `a_1, ..., a_n', se
utiliza la instrucción  `set(a_1, ..., a_n)' o `{a_1, ..., a_n}'; para
formar un conjunto vacío, basta con hacer `set()' o `{}'. Para
introducir conjuntos en Maxima, `set (...)' y `{ ... }' son
equivalentes. Los conjuntos se muestran siempre con llave.

   Si un elemento se indica más de una vez, el proceso de
simplificación elimina los elementos redundantes.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Dos elementos candidatos a formar parte de un conjunto, <x> e <y>,
son redundantes, esto es, se consideran el mismo elemento a efectos de
consruir el conjunto, si y sólo si `is (<x> = <y>)' devuelve el valor
`true'. Nótese que `is (equal (<x>, <y>))' puede devolver `true' y `is
(<x> = <y>)' retornar `false'; en cuyo caso los elementos <x> e <y> se
considerarían distintos.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   Para formar un conjunto a partir de los miembros de una lista úsese
`setify'.

     (%i1) setify([b, a]);
     (%o1)                        {a, b}

   Los elementos `x' e `y' de un conjunto se consideran iguales si
`is(x = y)' devuelve el valor `true'. Así, `rat(x)' y `x' se consideran
el mismo elemento de un conjunto; consecuentemente,

     (%i1) {x, rat(x)};
     (%o1)                          {x}

   Además, puesto que  `is((x-1)*(x+1) = x^2 - 1)' devuelve `false',
`(x-1)*(x+1)' y `x^2-1' se consideran elementos diferentes; así

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   Para reducir este conjunto a otro unitario, aplicar `rat' a cada
elemento del conjunto:

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   Para eliminar redundancias con otros conjuntos, será necesario
utilizar otras funciones de simplificación. He aquí un ejemplo que
utiliza  `trigsimp':

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

   Se entiende que un conjunto está simplificado cuando entre sus
elementos no hay redundancias y se hayan ordenados. La versión actual
de las funciones para conjuntos utiliza la función `orderlessp' de
Maxima para ordenar sus elementos; sin embargo, futuras versiones de
las funciones para operar con conjuntos podrán utilizar otras funciones
de ordenación.

   Algunas operaciones con conjuntos, tales como la sustitución,
fuerzan automáticamente una re-simplificación; por ejemplo,

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima considera a las listas y conjuntos como objetos diferentes;
funciones tales como `union' y `intersection' emitirán un error si
alguno de sus argumentos no es un conjunto. Si se necesita aplicar una
función de conjunto a una lista, se deberá utilizar la función `setify'
para convertirla previamente en conjunto.  Así,

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

   Para extraer todos los elementos de un conjunto `s' que satisfagan
un predicado `f', úsese `subset(s,f)'. (Un predicado es una función
booleana.) Por ejemplo, para encontrar las ecuaciones en un conjunto
dado que no dependan de la variable `z', se hará

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                   lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   La sección `Funciones y variables para los conjuntos' incluye una
lista completa de funciones para operar con conjuntos en  Maxima.

38.1.2 Iteraciones con elementos
--------------------------------

Hay dos formas para operar iterativamente sobre los elementos de un
conjunto. Una es utilizar `map'; por ejemplo:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

   La otra forma consiste en hacer uso de la construcción `for <x> in
<s> do'

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   Las funciones de Maxima  `first' y `rest' funcionan también con
conjuntos.  En este caso, `first' devuelve el primer elemento que se
muestra del conjunto, el cual puede depender de la implementación del
sistema. Si `s' es un conjunto, entonces `rest(s)' equivale a `disjoin
(first(s), s)'. Hay otras funciones que trabajan correctamente con
conjuntos. En próximas versiones de las funciones para operar con
conjuntos es posible que `first' y `rest' trabajen de modo diferente o
que ya no lo hagan en absoluto.

38.1.3 Fallos
-------------

Las funciones para operar con conjuntos utilizan la función `orderlessp'
de Maxima para ordenar los elementos de los conjuntos, así como la
función `like' de Lisp para decidir sobre la igualdad de dichos
elementos. Ambas funciones tienen fallos que son conocidos y que pueden
aflorar si se trabaja con conjuntos que tengan elementos en formato de
listas o matrices y que contengan expresiones racionales canónicas
(CRE).  Un ejemplo es

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Esta expresión provoca una parada de Maxima junto con la emisión de
un mensaje de error, el cual dependerá de la versión de Lisp que
utilice Maxima. Otro ejemplo es

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Estos fallos son causados por fallos en  `orderlessp' y `like', no
por fallos cuyo origen se encuentre en las funciones para conjuntos.
Para ilustrarlo, se pueden ejecutar las siguientes expresiones

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Hasta que estos errores no se corrijan, no es aconsejable construir
conjuntos que tengan por elementos listas o matrices que contengan
expresiones en forma CRE; sin embargo, un conjunto con elementos de la
forma CRE no deberían dar problemas:

     (%i1) {x, rat (x)};
     (%o1)                          {x}

   La función `orderlessp' de Maxima tiene otro fallo que puede causar
problemas con las funciones para conjuntos, en concreto, que el
predicado de ordenación `orderlessp' no es transitivo. El ejemplo más
simple que ilustra este punto es

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   El fallo puede causar problemas con todas las funciones para
conjuntos, así como también con otras funciones de Maxima.  Es
probable, pero no seguro, que este fallo se puede evitar si todos los
elementos del conjunto están en la forma de expresión racional canónica
(CRE) o han sido simplificados con `ratsimp'.

   Los mecanismos `orderless' y `ordergreat' de Maxima son incompatibles
con las funciones para conjuntos. Si se necesitan utilizar `orderless' o
`ordergreat', hágase antes de construir los conjuntos y no se utilice
la instrucción `unorder'.

   Se ruega a todo usuario que crea haber encontrado un fallo en las
funciones para conjuntos que lo comunique en la base de datos de
Maxima. Véase `bug_report'.

38.1.4 Autores
--------------

Stavros Macrakis de Cambridge, Massachusetts y Barton Willis de la
University of Nebraska at Kearney (UNK).


File: maxima.info,  Node: Funciones y variables para los conjuntos,  Prev: Introducción a los conjuntos,  Up: Conjuntos

38.2 Funciones y variables para los conjuntos
=============================================

 -- Función: adjoin (<x>, <a>)
     Calcula la unión del conjunto <a> y `{<x>}'.

     La función `adjoin' emite un mensaje de error si <a> no es un
     conjunto literal.

     Las sentencias `adjoin(<x>, <a>)' y `union(set(<x>), <a>)' son
     equivalentes, aunque `adjoin' puede ser algo más rápida que
     `union'.

     Véase también `disjoin'.

     Ejemplos:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}


 -- Función: belln (<n>)
     Representa el n-ésimo número de Bell, de modo que `belln(n)' es el
     número de particiones de un conjunto de <n> elementos.

     El argumento <n> debe ser un entero no negativo.

     La función `belln' se distribuye sobre ecuaciones, listas,
     matrices y conjuntos.

     Ejemplos:

     `belln' se aplica a enteros no negativos,

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6}))
                                      = belln (6));
          (%o3)                         true

     Si <n> no es un entero no negativo, la función `belln(n)' no hace
     cálculo alguno.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

 -- Función: cardinality (<a>)
     Devuelve el número de elementos del conjunto <a>.

     La función `cardinality' ignora los elementos redundantes, incluso
     cuando la simplificación está desabilitada.

     Ejemplos:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3

 -- Función: cartesian_product (<b_1>, ... , <b_n>)
     Devuelve un conjunto formado por listas de la forma `[<x_1>, ...,
     <x_n>]', siendo <x_1>, ..., <x_n> elementos de los conjuntos
     <b_1>, ... , <b_n>, respectivamente.

     La función `cartesian_product' emite un mensaje de error si alguno
     de sus argumentos no es un conjunto literal.

     Ejemplos:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Función: disjoin (<x>, <a>)
     Devuelve el conjunto <a> sin el elemento <x>.  Si <x> no es
     elemento de <a>, entonces el resultado es el propio <a>.

     La función `disjoin' emite un mensaje de error si <a> no es un
     conjunto literal.

     Las sentencias `disjoin(<x>, <a>)', `delete(<x>, <a>)' y
     `setdifference(<a>, set(<x>))' son todas ellas equivalentes; pero
     en general, `disjoin' será más rápida que las otras.

     Ejemplos:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}

 -- Función: disjointp (<a>, <b>)
     Devuelve `true' si y sólo si los conjuntos  <a> y <b> son
     disjuntos.

     La función `disjointp' emite un mensaje de error si <a> o <b> no
     son conjuntos literales.

     Ejemplos:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false

 -- Función: divisors (<n>)
     Calcula el conjunto de divisores de <n>.

     La sentencia `divisors(<n>)' devuelve un conjunto de enteros si
     <n> es un entero no nulo.  El conjunto de divisores incluye los
     elementos 1 y <n>.  Los divisores de un entero negativo son los
     divisores de su valor absoluto.

     La función `divisors' se distribuye sobre las ecuaciones, listas,
     matrices y conjuntos.

     Ejemplos:

     Se puede comprobar que 28 es un número perfecto: la suma de sus
     divisores (excepto él mismo) es 28.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     La función `divisors' es simplificadora.  Haciendo la sustitución
     de `a' por 8 en `divisors(a)' devuelve los divisores sin tener que
     reevaluar `divisors(8)',

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     La función `divisors' se distribuye sobre ecuaciones, listas,
     matrices y conjuntos.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- Función: elementp (<x>, <a>)
     Devuelve `true' si y sólo si <x> es miembro del conjunto <a>.

     La función `elementp' emite un mensaje de error si <a> no es un
     conjunto literal.

     Ejemplos:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false

 -- Función: emptyp (<a>)
     Devuelve `true' si y sólo si <a> es el conjunto vacío o la lista
     vacía.

     Ejemplos:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- Función: equiv_classes (<s>, <F>)
     Devuelve el conjunto de las clases de equivalencia del conjunto <s>
     respecto de la relación de equivalencia <F>.

     El argumento <F> es una función de dos variables definida sobre el
     producto cartesiano <s> por <s>.  El valor devuelto por <F> debe
     ser `true' o `false', o bien una expresión <expr> tal que
     `is(<expr>)' tome el valor `true' o `false'.

     Si <F> no es una relación de equivalencia, `equiv_classes' la
     acepta sin emitir ningún mensaje de error, pero el resultado será
     incorrecto en general.

     Ejemplos:

     La relación de equivalencia es una expresión lambda que devuelve
     `true' o `false',

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                                lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     La relación de equivalencia es el nombre de una función relacional
     en la que `is' evalúa a `true' o `false',

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     Las clases de equivalencia son números que difieren en un múltiplo
     de 3.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                        lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Función: every (<f>, <s>)
 -- Función: every (<f>, <L_1>, ..., <L_n>)
     Devuelve `true' si el predicado <f> vale `true' para todos los
     argumentos dados.

     Dado un conjunto como segundo argumento, `every(<f>, <s>)'
     devuelve `true' si `is(<f>(<a_i>))' devuelve `true' para todos los
     <a_i> pertenecientes <s>.  La función `every' puede evaluar o no
     <f> para todos los <a_i> pertenecientes <s>.  Puesto que los
     conjuntos no están ordenados, `every' puede evaluar `<f>(<a_i>)'
     en cualquier orden.

     Dada una o más listas como argumentos, `every(<f>, <L_1>, ...,
     <L_n>)' devuelve `true' si `is(<f>(<x_1>, ..., <x_n>))' devuelve
     `true' para todo <x_1>, ..., <x_n> en <L_1>, ..., <L_n>,
     respectivamente.  La función `every' puede evaluar o no <f> para
     cualquier combinación de <x_1>, ..., <x_n>; además, `every' evalúa
     las listas en el orden creciente del índice.

     Dado un conjunto vacío `{}' o lista vacía `[]' como argumentos,
     `every' devuelve `false'.

     Si la variable global `maperror' vale `true', todas las listas
     <L_1>, ..., <L_n> deben ser de igual longitud.  Si `maperror' vale
     `false', los argumentos en forma de listas se truncan para igualar
     sus longitudes a la de la lista más corta.

     Los valores que devuelve el predicado <f> cuando toman (mediante
     `is') un valor diferente a `true' y `false' se controlan con la
     variable global `prederror'.  Si `prederror' vale `true', tales
     valores se consideran como `false' y la respuesta de `every' es
     `false'.  Si `prederror' vale `false', tales valores se consideran
     como desconocidos (`unknown') y la respuesta de `every' es
     `unknown'.

     Ejemplos:

     Se aplica `every' a un único conjunto.  El predicado es una
     función de un argumento.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     Se aplica `every' a dos listas.  El predicado es una función de
     dos argumentos.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Las respuestas del predicado <f> que se evalúan a cualquier cosa
     diferente de `true' y `false' están controlados por la variable
     global `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                             [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false

 -- Función: extremal_subset (<s>, <f>, max)
 -- Función: extremal_subset (<s>, <f>, min)
     Calcula el subconjunto de <s> para el cual la función <f> toma sus
     valores mayor y menor.

     La sentencia `extremal_subset(<s>, <f>, max)' devuelve el
     subconjunto del conjunto o lista <s> para el cual la función real
     <f> toma su valor máximo.

     La sentencia `extremal_subset(<s>, <f>, min)' devuelve el
     subconjunto del conjunto o lista <s> para el cual la función real
     <f> toma su valor mínimo.

     Ejemplos

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- Función: flatten (<expr>)
     Recoge los argumentos de subexpresiones con el mismo operador que
     <expr> y construye con ellas otra expresión a partir de estos
     argumentos.

     Aquellas subexpresiones en las que el operador es diferente del
     operador principal de `expr' se copian sin modificarse, incluso
     cuando ellas mismas contengan subexpresiones en las que el
     operador sea el mismo que el de `expr'.

     Es posible que `flatten' construya expresiones en las que el número
     de argumentos difiera del número admitido por el operador, lo cual
     hará que se emita un mensaje de error. La función `flatten' no
     intentará detectar estas situaciones.

     Las expresiones que tengan representaciones especiales, por
     ejemplo las racionales canónicas (CRE), no admiten que se aplique
     sobre ellas la función `flatten'; en tales casos se devuelve el
     argumento sin modificación.

     Ejemplos:

     Aplicada a una lista, `flatten' reune todos los elementos que son
     a su vez listas.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Aplicado a un conjunto, `flatten' reune todos los elementos que
     son a su vez conjuntos.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     La función `flatten' es similar a la declaración del operador
     principal como n-ario. Sin embargo, `flatten' no tiene efecto
     alguno sobre subexpresiones que tengan un operador diferente del
     principal, mientras que sí lo tiene una declaración n-aria.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     La función `flatten' trata las funciones subindicadas como a
     cualquier otro operador.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     Es posible que `flatten' construya expresiones en las que el número
     de argumentos difiera del número admitido por el operador.

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Función: full_listify (<a>)
     Sustituye los operadores de conjunto presentes en <a> por
     operadores de listas, devolviendo el resultado.  La función
     `full_listify' sustituye operadores de conjuntos en subexpresiones
     anidadas, incluso cuando el operador principal no es `set'.

     La función `listify' sustituye únicamente el operador principal.

     Ejemplos:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))

 -- Función: fullsetify (<a>)
     Si <a> es una lista, sustituye el operador de lista por el de
     conjunto, aplicando posteriormente `fullsetify' a todos los
     elementos que son a su vez conjuntos.  Si <a> no es una lista, se
     devuelve sin cambio alguno.

     La función `setify' sustituye solamente el operador principal.

     Ejemplos:

     En la salida `(%o2)' el argumento de `f' no se convierte en
     conjunto porque el operador principal de `f([b])' no es una lista.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

 -- Función: identity (<x>)
     La función `identity' devuelve su argumento cualquiera que sea
     éste.

     Ejemplos:

     La función `identity' puede utilizarse como predicado cuando los
     argumentos ya son valores booleanos.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Función: integer_partitions (<n>)
 -- Función: integer_partitions (<n>, <len>)
     Devuelve particiones enteras de <n>, esto es, listas de enteros
     cuyas sumas son <n>.

     La sentencia `integer_partitions(<n>)' devuelve el conjunto de
     todas las particiones del entero <n>.  Cada partición es una lista
     ordenada de mayor a menor.

     La sentencia `integer_partitions(<n>, <len>)' devuelve todas las
     particiones de longitud <len> o menor; en este caso, se añaden
     ceros a cada partición con menos de <len> términos para que todas
     ellas sean de longitud <len>. Las particiones son listas ordenadas
     de mayor a menor.

     Una lista [a_1, ..., a_m] es una partición de un entero no
     negativo n si (1) cada a_i es entero no nulo y (2) a_1 + ... + a_m
     = n. Así, 0 no tiene particiones.

     Ejemplos:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Para encontrar todas las particiones que satisfagan cierta
     condición, utilícese la función `subset'; he aquí un ejemplo que
     encuentra todas las particiones de 10 formadas por números primos.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

 -- Función: intersect (<a_1>, ..., <a_n>)
     Es una forma abreviada de la función `intersection'.

 -- Función: intersection (<a_1>, ..., <a_n>)
     Devuelve el conjunto de todos los elementos que son comunes a los
     conjuntos  <a_1> a <a_n>.

     Emite un mensaje de error en caso de que cualquiera de los <a_i>
     no sea un conjunto.

     Ejemplos:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}

 -- Función: kron_delta (<x>, <y>)
     Es la función delta de Kronecker.

     La función `kron_delta' devuelve 1 cuando <x> e <y> son idénticos
     o equivalentes, devolviendo 0 si <x> e <y> no son idénticos.
     Cuando no está claro si ambas expresiones son equivalentes,
     `kron_delta' devuelve una forma nominal. Si la diferencia `<x> -
     <y>' es un número decimal en coma flotante, `kron_delta' dará como
     resultado una expresión nominal, aún cuando <x> e <y> sean
     aparentemente equivalentes.

     Concretando, `kron_delta(<x>, <y>)' devuelve 1 si `is(x = y)'
     retorna `true'; `kron_delta' también devuelve 1 si `sign(abs(<x> -
     <y>))' retorna `zero' y `<x> - <y>' no es un decimal en coma
     flotante (ni ordinario ni bigfloat); `kron_delta' devuelve 0 si
     `sign(abs(<x> - <y>))' retorna `pos'.

     Cuando `sign(abs(<x> - <y>))' es cualquier otra cosa diferente a
     `pos' o `zero', o si es `zero' siendo `<x> - <y>' un decimal en
     coma flotante, entonces `kron_delta' devuelve una expresión
     nominal.

     La función `kron_delta' está declarada como simétrica, esto es,
     `kron_delta(<x>, <y>)' es igual a `kron_delta(<y>, <x>)'.

     Ejemplos:

     Si los argumentos de `kron_delta' son idénticos, `kron_delta'
     devuelve 1,

          (%i1) kron_delta (a, a);
          (%o1)                           1
          (%i2) kron_delta (x^2 - y^2, x^2 - y^2);
          (%o2)                           1
          (%i3) float (kron_delta (1/10, 0.1));
          (%o3)                           1

     Si los argumentos de `kron_delta' son equivalentes y su diferencia
     no es un decimal en coma flotante, `kron_delta' devuelve 1,

          (%i1) assume (equal (x, y));
          (%o1)                     [equal(x, y)]
          (%i2) kron_delta (x, y);
          (%o2)                           1

     Si los argumentos de `kron_delta' no son equivalentes,
     `kron_delta' devuelve 0,

          (%i1) kron_delta (a + 1, a);
          (%o1)                           0
          (%i2) assume (a > b)$
          (%i3) kron_delta (a, b);
          (%o3)                           0
          (%i4) kron_delta (1/5, 0.7);
          (%o4)                           0

     Si no es posible determinar la equivalencia de los argumentos de
     `kron_delta', ésta devuelve una forma nominal,

          (%i1) kron_delta (a, b);
          (%o1)                   kron_delta(a, b)
          (%i2) assume(x >= y)$
          (%i3) kron_delta (x, y);
          (%o3)                   kron_delta(x, y)

     Si los argumentos de `kron_delta' son equivalentes, pero su
     diferencia es un decimal en coma flotante, `kron_delta' devuelve
     forma nominal,

          (%i1) 1/4 - 0.25;
          (%o1)                          0.0
          (%i2) 1/10 - 0.1;
          (%o2)                          0.0
          (%i3) 0.25 - 0.25b0;
          Warning:  Float to bigfloat conversion of 0.25
          (%o3)                         0.0b0
          (%i4) kron_delta (1/4, 0.25);
                                            1
          (%o4)                  kron_delta(-, 0.25)
                                            4
          (%i5) kron_delta (1/10, 0.1);
                                            1
          (%o5)                  kron_delta(--, 0.1)
                                            10
          (%i6) kron_delta (0.25, 0.25b0);
          Warning:  Float to bigfloat conversion of 0.25
          (%o6)               kron_delta(0.25, 2.5b-1)

     La función `kron_delta' es simétrica.

          (%i1) kron_delta (x, y);
          (%o1)                   kron_delta(x, y)
          (%i2) kron_delta (y, x);
          (%o2)                   kron_delta(x, y)
          (%i3) kron_delta (x, y) - kron_delta (y, x);
          (%o3)                           0
          (%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
          (%o4)                         true
          (%i5) is (kron_delta (x, y) = kron_delta (y, x));
          (%o5)                         true

 -- Función: listify (<a>)
     Si <a> es un conjunto, devuelve una lista con los elementos de <a>;
     si  <a> no es un conjunto, devuelve <a>.

     La función `full_listify' sustituye todos los operadores de
     conjunto en <a> por operadores de lista.

     Ejemplos:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})

 -- Función: lreduce (<f>, <s>)
 -- Función: lreduce (<f>, <s>, <init>)
     Amplía la función binaria <F> a n-aria mediante composición,
     siendo <s> una lista.

     La sentencia  `lreduce(<F>, <s>)' devuelve `F(... F(F(s_1, s_2),
     s_3), ... s_n)'.  Si se incluye el argumento opcional <s_0>, el
     resultado equivale a `lreduce(<F>, cons(<s_0>, <s>))'.

     La función <F> se aplica primero a los elementos del extremo
     izquierdo de la lista, de ahí el nombre `lreduce', (left reduce).

     Véanse también `rreduce', `xreduce' y `tree_reduce'.

     Ejemplos:

     La función `lreduce' sin el argumento opcional,

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     La función `lreduce' con el argumento opcional,

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     La función `lreduce' aplicada a operadores binarios de Maxima.  El
     símbolo `/' es el operador división.

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d


 -- Función: makeset (<expr>, <x>, <s>)
     Genera un conjunto cuyos miembros se generan a partir de la
     expresión <expr>, siendo <x> una lista de variables de <expr> y
     <s> un conjunto o lista de listas.  Para generar los elementos del
     conjunto, se evalúa <expr> asignando a las variables de <x> los
     elementos de <s> en paralelo.

     Los elementos de <s> deben tener la misma longitud que <x>.  La
     lista de variables <x> debe ser una lista de símbolos sin
     subíndices. Cuando se trate de un único símbolo, <x> debe
     expresarse como una lista de un elemento y cada elemento de <s>
     debe ser una lista de un sólo elemento.

     Véase también `makelist'.

     Ejemplos:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- Función: moebius (<n>)
     Representa la función de Moebius.

     Si <n> es el producto de k números primos diferentes,
     `moebius(<n>)' devuelve (-1)^k, retornando 1 si <n> = 1 y 0 para
     cualesquiera otros enteros positivos.

     La función de Moebius se distribuye respecto de ecuaciones,
     listas, matrices y conjuntos.

     Ejemplos:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}

 -- Función: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Función: multinomial_coeff ()
     Calcula el coeficiente multinomial.

     Si todos los <a_k> son enteros no negativos, el coeficiente
     multinomial es el número de formas de colocar  `<a_1> + ... +
     <a_n>' objetos diferentes en  n cajas con <a_k> elementos en la
     k-ésima caja. En general, `multinomial_coeff (<a_1>, ..., <a_n>)'
     calcula `(<a_1> + ... + <a_n>)!/(<a_1>! ... <a_n>!)'.

     Si no se dan argumentos, `multinomial_coeff()' devuelve 1.

     Se puede usar `minfactorial' para simplificar el valor devuelto
     por `multinomial_coeff'.

     Ejemplos:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Función: num_distinct_partitions (<n>)
 -- Función: num_distinct_partitions (<n>, <list>)
     Si <n> es un entero no negativo, devuelve el número de particiones
     enteras distintas de <n>, en caso contrario
     `num_distinct_partitions' devuelve una forma nominal.

     La sentencia `num_distinct_partitions(<n>, list)' devuelve una
     lista con el número de particiones distintas de 1, 2, 3, ..., <n>.

     Una partición distinta de <n> es una lista de números enteros
     positivos distintos k_1, ..., k_m tales que <n> = k_1 + ... + k_m.

     Ejemplos:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)

 -- Función: num_partitions (<n>)
 -- Función: num_partitions (<n>, <list>)
     Si <n> es un entero no negativo, devuelve el número de particiones
     enteras de <n>, en caso contrario `num_partitions' devuelve una
     expresión nominal.

     La sentencia `num_partitions(<n>, list)' devuelve una lista con
     los números de particiones enteras de 1, 2, 3, ..., <n>.

     Siendo <n> un entero no negativo, `num_partitions(<n>)' es igual a
     `cardinality(integer_partitions(<n>))'; sin embargo,
     `num_partitions' no construye el conjunto de particiones, por lo
     que es más rápido.

     Ejemplos:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

 -- Función: partition_set (<a>, <f>)
     Particiona el conjunto <a> respecto del predicado <f>.

     La función `partition_set' devuelve una lista con dos conjuntos;
     el primer conjunto es el subconjunto de <a> para el cual el
     predicado <f> devuelve `false' y el segundo contiene al resto de
     elementos de <a>.

     La función `partition_set' no aplica `is' al valor devuelto por
     <f>.

     La función `partition_set' emite un mensaje de error si <a> no es
     un conjunto literal.

     Véase también `subset'.

     Ejemplos:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                            lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Función: permutations (<a>)
     Devuelve un conjunto con todas las permutaciones distintas de los
     miembros de la lista o conjunto  <a>. Cada permutación es una
     lista, no un conjunto.

     Si <a> es una lista, sus miembros duplicados no son eliminados
     antes de buscar sus permutaciones.

     Si <a> no es una lista o conjunto, `permutations' emite un mensaje
     de error.

     Véase también `random_permutation'.

     Ejemplos:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

 -- Función: powerset (<a>)
 -- Función: powerset (<a>, <n>)
     Devuelve el conjunto de todos los subconjuntos del conjunto <a> o
     un sunconjunto de ellos.

     La sentencia `powerset(<a>)' devuelve el conjunto de todos los
     subconjuntos de <a>, que contendrá `2^cardinality(<a>)' elementos.

     La sentencia `powerset(<a>, <n>)' devuelve el conjunto de todos
     los subconjuntos de <a> de cardinalidad <n>.

     La función `powerset' emite un mensaje de error si <a> no es un
     conjunto literal o si <n> no es un entero no negativo.

     Ejemplos:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}

 -- Función: random_permutation (<a>)
     Devuelve una permutación aleatoria del conjunto o lista <a>,
     siguiendo el algoritmo de Knuth.

     El valor devuelto es una lista nueva distinta del argumento,
     incluso cuando todos los elementos son iguales. Sin embargo, los
     elementos del argumento no se copian.

     Ejemplos:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]


 -- Función: rreduce (<f>, <s>)
 -- Función: rreduce (<f>, <s>, <init>)
     Amplía la función binaria <F> a n-aria mediante composición,
     siendo <s> una lista.

     La sentencia  `rreduce(<F>, <s>)' devuelve `F(s_1, ... F(s_{n -
     2}, F(s_{n - 1}, s_n)))'.  Si se incluye el argumento opcional
     <s_{n + 1}>, el resultado equivale a `rreduce(<F>, endcons(<s_{n +
     1}>, <s>))'.

     La función <F> se aplica primero a los elementos del extremo
     derecho de la lista, de ahí el nombre `rreduce', (right reduce).

     Véanse también `lreduce', `xreduce' y `tree_reduce'.

     Ejemplos:

     La función `rreduce' sin el argumento opcional,

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     La función `rreduce' con el argumento opcional,

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     La función `rreduce' aplicada a operadores binarios de Maxima.  El
     símbolo `/' es el operador división.

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d

 -- Función: setdifference (<a>, <b>)
     Devuelve el conjunto con los elementos del conjunto <a> que no
     pertenecen al conjunto <b>.

     La función `setdifference' emite un mensaje de error si <a> o <b>
     no son conjuntos.

     Ejemplos:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}

 -- Función: setequalp (<a>, <b>)
     Devuelve  `true' si los conjuntos <a> y <b> tienen el mismo número
     de elementos y `is (<x> = <y>)' vale `true' para `x' perteneciente
     a <a> e `y' perteneciente a <b>, considerados en el orden que
     determina la función `listify'. En caso contrario, `setequalp'
     devuelve `false'.

     Ejemplos:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false

 -- Función: setify (<a>)
     Construye un conjunto con los miembros de la lista <a>.  Los
     elementos duplicados de la lista <a> son borrados y ordenados de
     acuerdo con el predicado `orderlessp'.

     La función `setify' emite un mensaje de error si <a> no es un
     conjunto literal.

     Ejemplos:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}

 -- Función: setp (<a>)
     Devuelve `true' si y sólo si <a> es un conjunto de Maxima.

     La función `setp' devuelve `true' tanto cuando el conjunto tiene
     como cuando no tiene elementos repetidos.

     La función `setp' is equivalent to the Maxima function `setp(a) :=
     not atom(a) and op(a) = 'set'.

     Ejemplos:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true

 -- Función: set_partitions (<a>)
 -- Función: set_partitions (<a>, <n>)
     Devuelve el conjunto de todas las particiones de <a> o un
     subconjunto de ellas.

     La sentencia `set_partitions(<a>, <n>)' devuelve un conjunto con
     todas las descomposiciones de <a> en <n> conjuntos no vacíos
     disjuntos.

     La sentencia `set_partitions(<a>)' devuelve el conjunto de todas
     las particiones.

     La función `stirling2' devuelve la cardinalidad del conjunto de
     las particiones de un conjunto.

     Se dice que un conjunto P es una partición del conjunto S si
     verifica

       1. cada elemento de P es un conjunto no vacío,

       2. los elementos de P son disjuntos,

       3. la unión de los elementos de P es igual a  S.

     Ejemplos:

     El conjunto vacío forma una partición de sí mismo,

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     La cardinalidad del conjunto de particiones de un conjunto puede
     calcularse con `stirling2',

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Cada elemento de `p' debería tener <n> = 3 miembros,

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Por último, para cada miembro de `p', la unión de sus elementos
     debe ser igual a `s',

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- Función: some (<f>, <a>)
 -- Función: some (<f>, <L_1>, ..., <L_n>)
     Devuelve `true' si el predicado <f> devuelve `true' para al menos
     uno de sus argumentos.  Si el segundo argumento es un conjunto,
     `some (<f>, <a>)' devuelve `true' si `<f>(<a_i>)' devuelve también
     `true' para alguno de los <a_i> en <a>; puede ser que `some' no
     evalúe <f> para todos los <a_i> de <s>.  Puesto que los conjuntos
     no están ordenados, `some' puede evaluar `<f>(<a_i>)' en cualquier
     orden.

     Dada una o más listas como argumentos, `some (<f>, <L_1>, ...,
     <L_n>)' devuelve `true' si `<f>(<x_1>, ..., <x_n>)' devuelve
     también `true' para al menos un  <x_1>, ..., <x_n> de <L_1>, ...,
     <L_n>, respectivamente; puede ser que `some' no evalúe <f> para
     todos las combinaciones <x_1>, ..., <x_n>. La función `some' evalúa
     las listas en el orden creciente de su índice

     Dado un conjunto vacío `{}' o una lista vacía como argumentos,
     `some' devuelve `false'.

     Si la variable global `maperror' vale `true', todas las listas
     <L_1>, ..., <L_n> deben tener igual número de elementos. Si
     `maperror' vale `false', los argumentos se truncan para tener todos
     el número de elementos de la lista más corta.

     Los valores que devuelve el predicado <f> cuando toman (mediante
     `is') un valor diferente a `true' y `false' se controlan con la
     variable global `prederror'.  Si `prederror' vale `true', tales
     valores se consideran como `false'.  Si `prederror' vale `false',
     tales valores se consideran como desconocidos (`unknown').

     Ejemplos:

     La función `some' aplicada a un único conjunto.  El predicado es
     una función de un argumento,

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     La función `some' aplicada a dos listas.  El predicado es una
     función de dos argumentos,

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Las respuestas del predicado <f> que se evalúan a cualquier cosa
     diferente de `true' y `false' están controlados por la variable
     global `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                               [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- Función: stirling1 (<n>, <m>)
     Es el número de Stirling de primera especie.

     Si tanto <n> como <m> son enteros no negativos, el valor que toma
     `stirling1 (<n>, <m>)' es el número de permutaciones de un
     conjunto de <n> elementos con <m> ciclos. Para más detalles, véase
     Graham, Knuth and Patashnik Concrete Mathematics.  Maxima utiliza
     una relación recursiva para definir `stirling1 (<n>, <m>)' para
     <m> menor que 0; no está definida para <n> menor que 0 ni para
     argumentos no enteros.

     La función `stirling1' es simplificadora. Maxima reconoce las
     siguientes identidades:

       1. stirling1(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling1(n, n) = 1 (Ref. [1])

       3. stirling1(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling1(n + 1, 0) = 0 (Ref. [1])

       5. stirling1(n + 1, 1) = n! (Ref. [1])

       6. stirling1(n + 1, 2) = 2^n  - 1 (Ref. [1])

     Estas identidades se aplican cuando los argumentos son enteros
     literales o símbolos declarados como enteros y el primer argumento
     es no negativo. La función `stirling1' no simplifica para
     argumentos no enteros.

     Referencias:

     [1] Donald Knuth, The Art of Computer Programming, Tercera
     Edición, Volumen 1, Sección 1.2.6, Ecuaciones 48, 49 y 50.

     Ejemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     La función `stirling1' no simplifica en caso de argumentos no
     enteros,

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima aplicas algunas identidades a `stirling1',

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Función: stirling2 (<n>, <m>)
     Es el número de Stirling de segunda especie.

     Si <n> y <m> son enteros no negativos, `stirling2 (<n>, <m>)' es
     el número de formas en las que se puede particionar un conjunto de
     cardinal <n> en <m> subconjuntos disjuntos.  Maxima utiliza una
     relación recursiva para definir `stirling2 (<n>, <m>)' con <m>
     menor que 0; la función no está definida para  <n> menor que 0  ni
     para argumentos no enteros.

     La función `stirling2' es simplificadora. Maxima reconoce las
     siguientes identidades:

       1. stirling2(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling2(n, n) = 1 (Ref. [1])

       3. stirling2(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling2(n + 1, 1) = 1 (Ref. [1])

       5. stirling2(n + 1, 2) = 2^n  - 1 (Ref. [1])

       6. stirling2(n, 0) = kron_delta(n, 0) (Ref. [2])

       7. stirling2(n, m) = 0 when m > n (Ref. [2])

       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m!  si m y n son enteros y n no negativo. (Ref. [3])

     Estas identidades se aplican cuando los argumentos son enteros
     literales o símbolos declarados como enteros y el primer argumento
     es no negativo. La función `stirling2' no simplifica para
     argumentos no enteros.

     Referencias:

     [1] Donald Knuth. The Art of Computer Programming, Tercera
     Edición, Volumen 1, Sección 1.2.6, Ecuaciones 48, 49 y 50.

     [2] Graham, Knuth y Patashnik. Concrete Mathematics, Tabla 264.

     [3] Abramowitz y Stegun. Handbook of Mathematical Functions,
     Sección 24.1.4.

     Ejemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     La función `stirling2' no simplifica en caso de argumentos no
     enteros,

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima aplicas algunas identidades a `stirling2',

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Función: subset (<a>, <f>)
     Devuelve el subconjunto del conjunto <a> que satisface el
     predicado <f>.

     La función `subset' devuelve el conjunto que contiene a los
     elementos de <a> para los cuales <f> devuelve un resultado
     diferente de `false'. La función `subset' no aplica `is' al valor
     retornado por <f>.

     La función `subset' emite un mensaje de error si <a> no es un
     conjunto literal.

     Véase también `partition_set'.

     Ejemplos:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}

 -- Función: subsetp (<a>, <b>)
     Devuelve `true' si y sólo si el conjunto <a> es un subconjunto de
     <b>.

     La función `subsetp' emite un mensaje de error si cualesquiera <a>
     o <b> no es un conjunto literal.

     Ejemplos:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false

 -- Función: symmdifference (<a_1>, ..., <a_n>)
     Devuelve el conjunto de elementos que pertenecen a un único
     conjunto de los  <a_k>.

     Dados dos argumentos, `symmdifference (<a>, <b>)' equivale a
     `union (setdifference (<a>, <b>), setdifference (<b>, <a>))'.

     La función `symmdifference' emite un mensaje de error si alguno de
     su argumentos no es un conjunto literal.

     Ejemplos:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1, z}

 -- Función: tree_reduce (<F>, <s>)
 -- Función: tree_reduce (<F>, <s>, <s_0>)
     Amplía la función binaria <F> a n-aria, siendo <s> una lista.

     La función `tree_reduce' equivale a lo suguiente: Aplicar <F> a
     pares sucesivos de elementos para formar una nueva lista
     `[<F>(<s_1>, <s_2>), <F>(<s_3>, <s_4>), ...]', llevando el
     elemento final sin cambiar si el número de elementos es impar;
     después repetir hasta que la lista se reduzca a un único elemento,
     que es el valor de retorno.

     Cuando está presente el argumento opcional <s_0>, el resultado
     equivale a `tree_reduce(<F>, cons(<s_0>, <s>)'.

     Para la suma de números decimales en coma flotante, `tree_reduce'
     puede devolver una suma que tenga un error de redondeo menor que
     el conseguido por `rreduce' o `lreduce'.

     Los elementos de <s> y los resultados parciales pueden colocarse
     en un árbol binario de mínima profundidad, de ahí el nombre de
     tree_reduce.

     Ejemplos:

     La función `tree_reduce' aplicada a una lista con un número par de
     elementos,

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     La función `tree_reduce' aplicada a una lista con un número impar
     de elementos,

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

 -- Function: union (<a_1>, ..., <a_n>)
     Devuelve la unión de los conjuntos <a_1> hasta <a_n>.

     La sentencia `union()' (sin argumentos) devuelve el conjunto vacío.

     La función `union' emite un mensaje de error si alguno de sus
     argumentos no es un conjunto literal.

     Ejemplos:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}

 -- Función: xreduce (<F>, <s>)
 -- Función: xreduce (<F>, <s>, <s_0>)
     Amplía la función <F> a n-aria mediante composición; si <F> ya es
     n-aria, aplica <F> a <s>.  Si <F> no es n-aria, `xreduce' equivale
     a `lreduce'.  El argumento <s> debe ser una lista.

     Funciones n-arias reconocidas por Maxima son la suma `+', la
     multiplicación `*', `and', `or', `max', `min' y `append'. Las
     funciones también se pueden declarar n-arias mediante
     `declare(<F>, nary)'; para estas funciones, `xreduce' será más
     rápida que `rreduce' o `lreduce'.

     Cuando está presente el argumento opcional <s_0>, el resultado
     equivale a `xreduce(<s>, cons(<s_0>, <s>))'.

     La suma de números decimales en coma flotante no es exactamente
     asociativa; aún así, `xreduce' aplica la suma n-aria cuando <s>
     contiene números en coma flotante.

     Ejemplos:

     La función `xreduce' aplicada a una función n-aria; `F' es
     invocada una sóla vez, con todos sus argumentos,

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     La función `xreduce' aplicada a una función que se desconoce si es
     n-aria; `G' es invocada varias veces, con dos argumentos de cada
     vez,

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]


File: maxima.info,  Node: Definición de Funciones,  Next: Programación,  Prev: Conjuntos,  Up: Top

39 Definición de Funciones
**************************

* Menu:

* Introducción a la definición de funciones::
* Funciones::
* Macros::
* Funciones y variables para la definición de funciones::


File: maxima.info,  Node: Introducción a la definición de funciones,  Next: Funciones,  Prev: Definición de Funciones,  Up: Definición de Funciones

39.1 Introducción a la definición de funciones
==============================================


File: maxima.info,  Node: Funciones,  Next: Macros,  Prev: Introducción a la definición de funciones,  Up: Definición de Funciones

39.2 Funciones
==============

39.2.1 Funciones ordinarias
---------------------------

Para definir una función en Maxima es necesario utilizar el operador
':='.

   Por ejemplo,

     f(x) := sin(x)
   define una función `f'. También se pueden definir funciones anónimas
utilizando `lambda'; por ejemplo,

     lambda ([i, j], ...)

puede utilizarse en lugar de `f' donde

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

devolvería una lista con todos sus elementos aumentados en una unidad.

   También se puede definir una función con un número variable de
argumentos, sin más que añadir un argumento final al que se le asigna
una lista con todos los argumentos adicionales.:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   El miembro derecho de una función debe ser una expresión. Así, si se
quiere una secuencia de expresiones, se debe hacer

     f(x) := (expr1, expr2, ...., exprn);

   siendo el valor que alcance exprn el devuelto por la función.

   Si se quiere hacer un `return' desde alguna de las expresiones de la
función, se debe utilizar la estructura  `block' junto con `return'.
Por ejemplo,

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   es una expresión de pleno derecho, por lo que puede ocupar el lado
derecho de la definición de una función. Aquí puede ocurrir que el
retorno se produzca antes que se alcance la última expresión.

   Los primeros corchetes del bloque (`[]') pueden contener una lista
de variables junto con posibles asignaciones, tal como `[a: 3, b, c:
[]]', lo que provocará que las tres variables `a',`b' y `c' se
consideren locales y sean independientes de otras globales con el mismo
nombre; las variables locales sólo estarán activas mientras se ejecute
el código que está dentro de la estructura `block', o dentro de
funciones que son llamadas desde dentro de `block'. A esto se le llama
asignación dinámica, pues las variables sobreviven desde el inicio del
bloque hasta que éste deje de estar operativo. Una vez se salga del
bloque los valores originales de las variables, si es que los había,
quedan restaurados. Es recomendable proteger las variables de esta
forma. Se tendrá en cuenta que las asignaciones a las variables del
bloque se hacen en paralelo, lo que significa que si como en el ejemplo
anterior se hace `c: a' en el momento de entrar en el bloque, el valor
de `c' será el que tenía `a' antes de entrar en el bloque, es decir,
antes de la asignación `a: 3'. Así, haciendo lo siguiente

     block ([a: a], expr1, ... a: a+3, ..., exprn)

   se prevendría de que el valor externo de `a' fuese alterado, pero
permitiría acceder a él desde dentro del bloque. La parte derecha de
las asignaciones se evalúa dentro de su contexto antes de hacer
efectiva la asignación. Utilizando únicamente `block([x],..' haría que
`x' se tuviese a sí misma como valor, justo como si se acabase de
iniciar una nueva sesión de Maxima.

   Los valores de los argumentos de una funcón se tratan exactamente de
la misma forma que las variables de un bloque. Así, con

     f(x) := (expr1, ..., exprn);

   y

     f(1);

   se estaría en un contexto similar para la evaluación de las
expresiones como si se hubiera hecho

     block ([x: 1], expr1, ..., exprn)

   Dentro de las funciones, cuando el lado derecho de la definición
deba ser evaluado será útil hacer uso de `define' y posiblemente de
`buildq'.

39.2.2 Funciones array
----------------------

Una función array almacena el valor de la función la primera vez que es
invocada con un argumento dado, devolviendo el valor almacenado sin
recalcularlo cuando es llamada con ese mismo argumento.  Estas
funciones reciben también el nombre de funciones memorizadoras.

   Los nombres de las funciones array son añadidos a la lista global
`arrays', no a la lista global `functions'.  La función `arrayinfo'
devuelve la lista de argumentos para los que hay valores almacenados y
`listarray' devuelve precisamente estos valores almacenados.  Las
funciones `dispfun' y `fundef' devuelven la definición de la función
array.

   La función `arraymake' construye una llamada a una función array, de
forma similar a como lo hace `funmake' para las funciones ordinarias.
Por otro lado, `arrayapply' aplica una función array a sus argumentos,
tal como lo hace `apply' con las funciones ordinarias. No existe para
las funciones array nada similar a `map', aunque `map(lambda([<x>],
<a>[<x>]), <L>)' o `makelist(<a>[<x>], <x>, <L>)', siendo <L> una
lista, podrían suplantar esta carencia.

   La función `remarray' borra la definición de una función array, así
como cualesquiera valores almacenados que tenga asociados, tal como
`remfunction' lo hace con las funciones ordinarias.

   La llamada `kill(<a>[<x>])' borra el valor de la función array <a>
almacenado para el argumento <x>; la próxima vez que se llame a <a> con
el argumento <x>, se recalculará el valor correspondiente.  Sin
embargo, no hay forma de borrar todos los valores almacenados de una
sola vez, excepto mediante `kill(<a>)' o `remarray(<a>)', con lo que se
borra también la definición de la propia función.


File: maxima.info,  Node: Macros,  Next: Funciones y variables para la definición de funciones,  Prev: Funciones,  Up: Definición de Funciones

39.3 Macros
===========

 -- Función: buildq (<L>, <expr>)
     Sustituye en paralelo las variables nombradas en la lista <L> en
     la expresión <expr>, sin evaluar ésta.  La expresión resultante se
     simplifica pero no se evalúa hasta que `buildq' termine de hacer
     las sustituciones.

     Los elementos de <L> son símbolos o expresiones de asignación del
     tipo `<symbol>: <value>', evaluadas en paralelo. Esto es, el valor
     de una variable en la parte derecha de una asignación es el valor
     que toma dicha variable en el contexto desde el que se invoca a
     `buildq'. En caso de que a una variable de <L> no se le haga una
     signación explícita, su valor en `buildq' es el mismo que tiene en
     el contexto desde el que se llama a `buildq'.

     Las variables referenciadas en <L> se sustituyen en <expr> en
     paralelo. Esto es, la sustitución para cada variable se determina
     antes de que se hagan las sustituciones, de forma que la
     sustitución de una variable no tiene efecto alguno sobre las otras.

     Si alguna variable <x> aparece como `splice (<x>)' en <expr>,
     entonces a <x> se le debe asignar una lista, la cual será
     interpolada en <expr> en lugar de hacer una simple sustitución;
     ver ejemplo más abajo.

     Cualesquiera otras variables de <expr> que no aparezcan en <L> se
     traspasan al resultado tal cual, incluso cuando tienen asignados
     valores en el contexto desde el que se llama a `buildq'.

     Ejemplos:

     `a' queda asociada explícitamente a `x', mientras que `b' tiene la
     misma asociación (29) que en el contexto de llamada y `c' es
     traspasado al resultado sin ser sustituido. La expresión
     resultante no se evalúa hasta que no se le obligue a ello mediante
     la evaluación explícita `''%'.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     En este ejemplo, `e' se asocia a una lista, la cual aparece como
     tal en los argumentos de `foo' e interpolada en los argumentos de
     `bar'.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     Como se ve a continuación, el resultado se simplifica tras las
     sustituciones. Si la simplificación se realizase antes que las
     sustituciones, ambos resultados serían iguales.

          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     Las variables de <L> se asocian en paralelo; si se hiciese
     secuencialmente, el primer resultado sería `foo (b, b)'. Las
     sustituciones se llevan a cabo en paralelo. Compárese el segundo
     resultado con el resultado de `subst', que hace las sustituciones
     de forma secuencial.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
                        bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
                       bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Se construye a continuación un sistema de ecuaciones con algunas
     variables o expresiones en el lado izquierdo y sus valores en el
     derecho; `macroexpand' muestra la expresión devuelta por
     `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)          [a = 17, b = 29, c - b - a = 1683]
          (%i4) macroexpand (show_values (a, b, c - a - b));
          (%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])

     Dada una función con varios argumentos, se crea otra función en la
     cual algunos argumentos son fijos.

          (%i1) curry (f, [a]) :=
                  buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
          (%i2) by3 : curry ("*", 3);
          (%o2)        lambda([[x]], apply(*, append([3], x)))
          (%i3) by3 (a + b);
          (%o3)                       3 (b + a)

 -- Función: macroexpand (<expr>)
     Devuelve la macroexpansión de <expr>, sin evaluarla, cuando `expr'
     es una llamada a una función macro; en caso contrario,
     `macroexpand' devuelve <expr>.

     Si la expansión de <expr> devuelve otra llamada a una función
     macro, esta llamada también se expande.

     La función `macroexpand' no evalúa su argumento.  Sin embargo, si
     la expansión de una llamada a función macro tiene efectos
     laterales, éstos se ejecutan.

     Véanse también `::=', `macros' y `macroexpand1'.

     Ejemplos:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Función: macroexpand1 (<expr>)
     Devuelve la macroexpansión de <expr>, sin evaluarla, cuando `expr'
     es una llamada a una función macro; en caso contrario,
     `macroexpand1' devuelve <expr>.

     La función `macroexpand1' no evalúa su argumento.  Sin embargo, si
     la expansión de una llamada a función macro tiene efectos
     laterales, éstos se ejecutan.

     Si la expansión de <expr> devuelve otra llamada a una función
     macro, esta llamada no se expande.

     Véanse también `::=', `macros' y `macroexpand'.

     Ejemplos:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Variable global: macros
     Valor por defecto: `[]'

     La variable `macros' es la lista de las funciones macro definidas
     por el usuario.  El operador de definición de funciones macro
     `::=' coloca la nueva función macro en esta lista, mientras que
     `kill', `remove' y `remfunction' eliminan las funciones macro de
     la lista.

     Véase también `infolists'.


 -- Función: splice (<a>)
     Interpola la lista nombrada por el átomo  <a> dentro de una
     expresión, pero sólo si `splice' aparece dentro de `buildq'; en
     otro caso, `splice' se considera una función no definida. Si <a>
     aparece dentro de `buildq' sin `splice', entonces queda sustituida
     por una lista dentro del resultado. El argumento de `splice' debe
     ser un átomo, no pudiendo ser una lista literal ni una expresión
     que devuelva una lista.

     Normalmente `splice' suministra los argumentos para una función u
     operador. Para una función `f', la expresión `f (splice (<a>))'
     dentro de `buildq' se convierte en `f (<a>[1], <a>[2], <a>[3],
     ...)'. Dado un operador `o', la expresión `"o" (splice (<a>)'
     dentro de `buildq' se convierte en `"o" (<a>[1], <a>[2], <a>[3],
     ...)', donde `o' puede ser cualquier tipo de operador, normalmente
     uno que admita varios argumentos. Nótese que el operador debe ir
     encerrado entre comillas dobles `"'.

     Ejemplos:

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>




Local Variables:
coding: iso-8859-1
End:
