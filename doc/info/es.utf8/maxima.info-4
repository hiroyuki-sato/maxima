This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definiciones para Opciones Misceláneas,  Prev: Share,  Up: Opciones Misceláneas

36.3 Definiciones para Opciones Misceláneas
===========================================

 -- Variable del sistema: aliases
     Valor por defecto: `[]'

     La variable `aliases' es la lista de átomos que tienen un "alias"
     definido por el usuario (establecido mediante las funciones
     `alias', `ordergreat' o `orderless' o declarando el átomo como un
     `noun' (nombre) con `declare'.

 -- Declaración: alphabetic
     La llamada `declare (<char>, alphabetic)' añade  `char' al
     alfabeto de Maxima, el cual contiene inicialmente las letras de la
     `A' a la  `Z', de la `a' a la `z', `%' y `_'. La variable <char>
     se especifica como una cadena alfanumérica de longitud 1, como
     `"~"'.

          (%i1) declare ("~", alphabetic);
          (%o1)                         done
          (%i2) foo~bar;
          (%o2)                        foo~bar
          (%i3) atom (foo~bar);
          (%o3)                         true


 -- Función: apropos (<cadena>)
     Busca nombres en Maxima en los cuales aparezca <cadena> en
     cualquier lugar dentro de ellos. Así, `apropos (exp)' devuelve una
     lista con todas las variables y funciones que tengan  `exp'
     formando parte de sus nombres, como  `expand', `exp' y
     `exponentialize'. De esta forma, si el usuario tan solo recuerda
     parte del nombre de algo, puede utilizar este comando para
     encontrar el resto del nombre. De manera semejante, también se
     puede hacer `apropos (tr_)' para encontrar una lista de muchas de
     las variables relacionadas con el traductor, buena parte de las
     cuales comienzan con `tr_'.


 -- Función: args (<expr>)
     Devuelve la lista de argumentos de `expr', que puede ser cualquier
     tipo de expresión a excepción de un átomo. Tan solo se muestran
     los argumentos del operador principal; subexpresiones de `expr'
     aparecen como elementos o subexpresiones de elementos de la lista
     de argumentos.

     El orden de los miembros de la lista puede depender de la variable
     global `inflag'.

     La llamada `args (<expr>)' es equivalente a `substpart ("[",
     <expr>, 0)'.  Véase también `substpart'.

     Véase asimismo `op'.


 -- Variable optativa: genindex
     Valor por defecto: `i'

     La variable `genindex' es el prefijo alfabético utilizado para
     generar la siguiente variable de sumación en caso de necesidad.


 -- Variable optativa: gensumnum
     Valor por defecto: 0

     La variable `gensumnum' es el sufijo numérico utilizado para
     generar la siguiente variable de sumación. Si vale  `false'
     entonces el índice consistirá solamente de  `genindex', sin sufijo
     numérico.


 -- Constante: inf
     Símbolo que identifica al infinito positivo dentro de un contexto
     de números reales.


 -- Constante: infinity
     Símbolo que identifica al infinito complejo, una magnitud infinita
     con ángulo de fase arbitrario.  Véanse también `inf' y `minf'.


 -- Variable del sistema: infolists
     Valor por defecto: `[]'

     La variable `infolists' es una lista con los nombres de todas las
     listas que guardan información sobre Maxima. Estas son:

    `labels'
          Todas las etiquetas `%i', `%o' y `%t' con valores asignados.

    `values'
          Todos los átomos que son variables de usuario, no opciones de
          Maxima creadas con  `:' o `::'.

    `functions'
          Todas las funciones de usuario creadas con `:=' o `define'.

    `arrays'
          Arreglos declarados y no declarados, creados por `:', `::' o
          `:='.

    `macros'
          Cualquier macro definida por el usuario.

    `myoptions'
          Todas las opciones inicializadas por el usuario,
          independientemente de que posteriormente hayan sido devueltas
          a sus valores por defecto.

    `rules'
          Reglas de patrones y simplificación definidas por el usuario,
          creadas con `tellsimp', `tellsimpafter', `defmatch' o
          `defrule'.

    `aliases'
          Átomos que tienen un "alias" definido por el usuario, creado
          por las funciones `alias', `ordergreat' o `orderless' o por
          haber declarado el átomo como `noun' (nombre) con `declare'.

    `dependencies'
          Átomos que tienen dependencias funcionales, creados por las
          funciones `depends' o `gradef'.

    `gradefs'
          Funciones que tienen derivadas definidas por el usuario,
          creadas por la función `gradef'.

    `props'
          Todos los átomos que tengan cualquier propiedad que no sea de
          las mencionadas hasta ahora, como las establecidas por
          `atvalue', `matchdeclare', etc., así como propiedadas
          especificadas en la función `declare'.

    `let_rule_packages'
          Todos los paquetes de reglas `let' definidos por el usuario,
          junto con el paquete especial `default_let_rule_package';
          `default_let_rule_package' es el nombre del paquete de reglas
          utilizado cuando no se use ningún otro especificado por el
          usuario.


 -- Función: integerp (<expr>)
     Devuelve `true' si <expr> es un número entero y `false' en
     cualquier otro caso.

     La función `integerp' devuelve `false' si su argumento es un
     símbolo, incluso cuando éste ha sido declarado como entero.

     Ejemplos:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false


 -- Variable optativa: m1pbranch
     Valor por defecto: `false'

     La variable `m1pbranch' es la rama principal de `-1' elevado a una
     potencia. Cantidades como `(-1)^(1/3)' (esto es, un exponente
     racional impar) y `(-1)^(1/4)' (esto es, un exponente racional
     par) son tratados como sigue:

                        dominio real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       dominio complejo
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2


 -- Función: numberp (<expr>)
     Devuelve `true' si <expr> es un enúmero entero, racional, de coma
     flotante o "bigfloat", en caso contrario devuelve `false'.

     La función `numberp' devuelve `false' si su argumento es un
     símbolo, incluso cuando el argumento es un número simbólico como
     `%pi' o `%i', o aunque haya sido declarado como "even" (par),
     "odd" (impar), "integer" (entero), "rational" (racional),
     "irrational" (irracional), "real" (real), "imaginary" (imaginario)
     o "complex" (complejo).

     Ejemplos:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]


 -- Función: properties (<a>)
     Devuelve una lista con los nombres de propiedades asociadas con el
     átomo <a>.


 -- Símbolo especial: props
     `props' son átomos que tienen cualquier propiedad diferente de las
     mencionadas explícitamente en `infolists', tales como atvalues,
     matchdeclares, etc., así como las propiedades especificadas en la
     función  `declare'.


 -- Función: propvars (<prop>)
     Devuelve una lista con aquellos átomos de la lista `props' que
     tienen la propiedad indicada por <prop>.


 -- Función: put (<átomo>, <valor>, <indicador>)
     Asigna el <valor> a la propiedad  (especificada por <indicador>)
     de <átomo>; <indicador> puede ser el nombre de cualquier propiedad
     y no solamente de aquellas definidas por el sistema.

     La función `put' evalúa sus argumentos y devuelve <valor>.

     Ejemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello


 -- Función: qput (<átomo>, <valor>, <indicador>)
     Asigna <valor> a la propiedad de <átomo> que especifique
     <indicador>. Actúa del mismo modeo que `put', excepto que sus
     argumentos no son evaluados.

     Ejemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar


 -- Función: rem (<átomo>, <indicador>)
     Elimina del <átomo> la propiedad indicada por <indicador>.


 -- Función: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Función: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Función: remove ("<a>", operator)
 -- Función: remove (<a>, transfun)
 -- Función: remove (all, <p>)
     Elimina propiedades asociadas con átomos.

     La llamada `remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' elimina la
     propiedad `p_k' del átomo `a_k'.

     La llamada `remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)'
     elimina las propiedades `<p_1>, ..., <p_n>' de los átomos <a_1>,
     ..., <a_m>. Puede tener más de un par de listas.

     La llamada `remove (all, <p>)' elimina la propiedad <p> de todos
     los átomos que la tengan.

     Las propiedades eliminadas pueden ser de las que define el
     sistema, como `function', `macro' o `mode_declare', o de las que
     define el usuario.

     La llamada `remove ("<a>", operator)' o su equivalente `remove
     ("<a>", op)' elimina de  <a> las propiedades de operador
     declaradas por `prefix', `infix', `nary', `postfix', `matchfix' o
     `nofix'. Nótese que el nombre del operador debe escribirse como
     cadena precedida de apóstrofo.

     La llamada `remove' devuelve siempre `done' independientemente que
     haya algún átomo con la propiedad especificada.


 -- Función: remvalue (<nombre_1>, ..., <nombre_n>)
 -- Función: remvalue (all)
     Elimina del sistema los valores de las variable de usuario
     <nombre_1>, ..., <nombre_n> (incluso las que tienen subíndices).

     La llamada `remvalue (all)' elimina los valores de todas las
     variables en `values', la lista de todas las variables a las que
     el usuario a dado algún nombre, pero no de aquéllas a las que
     Maxima asigna automáticamente un valor.

     Véase también `values'.


 -- Función: rncombine (<expr>)
     Transforma <expr> combinando todos los términos de <expr> que
     tengan denominadores idénticos o que difieran unos de otros por
     factores numéricos. Su comportamiento es diferente al de la
     función `combine', que combina términos con iguales denominadores.

     Haciendo `pfeformat: true' y utilizando `combine' se consiguen
     resultados similares a aquéllos que se pueden obtener con
     `rncombine', pero `rncombine' realiza el paso adicional de
     multiplicar denominadores numéricos. Esto da como resultado
     expresiones en las que se pueden reconocer algunas cancelaciones.


 -- Función: scalarp (<expr>)
     Devuelve `true' si <expr> is un número, constante  o variable
     declarada como `scalar' con `declare', o compuesta completamente
     de tales números, constantes o variables, pero que no contengan
     matrices ni listas.


 -- Función: setup_autoload (<nombre_fichero>, <función_1>, ...,
          <función_n>)
     Especifica que si alguna de las funciones <function_1>, ...,
     <function_n> es referenciada pero todavía no ha sido definida, se
     cargará <nombre_fichero> mediante una llamada a `load'. El
     <nombre_fichero> normalmente contendrá las definiciones de las
     funciones especificadas, aunque esto no es imperativo.

     La función `setup_autoload' no opera con arreglos de funciones.

     La función `setup_autoload' no evalúa sus argumentos.

     Ejemplo:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma function ultraspherical
          Warning - you are redefining the Macsyma function legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2



File: maxima.info,  Node: Reglas y patrones,  Next: Listas,  Prev: Opciones Misceláneas,  Up: Top

37 Reglas y patrones
********************

* Menu:

* Introducción a reglas y patrones::
* Definiciones sobre reglas y patrones::


File: maxima.info,  Node: Introducción a reglas y patrones,  Next: Definiciones sobre reglas y patrones,  Prev: Reglas y patrones,  Up: Reglas y patrones

37.1 Introducción a reglas y patrones
=====================================

Esta sección describe las reglas de simplificación y los patrones de
comparación definidos por el usuario. Hay dos grupos de funciones que
implementan diferentes esquemas de comparación de patrones. En un grupo
están `tellsimp', `tellsimpafter', `defmatch', `defrule', `apply1',
`applyb1' y `apply2'. En el otro, se encuentran `let' y `letsimp'.
Ambos esquemas definen patrones en términos de variables de patrones
declaradas mediante  `matchdeclare'.

   Las reglas de comparación de patrones definidas por `tellsimp' y
`tellsimpafter' se aplican automáticamente por el simplificador de
Maxima. Las reglas definidas por `defmatch', `defrule' y `let' se
aplican previa llamada a una función.

   Hay otros mecanismos para las reglas; las relativas a polinomios se
controlan mediante `tellrat' y las del álgebra conmutativa y no
conmutativa se definen en el paquete `affine'.


File: maxima.info,  Node: Definiciones sobre reglas y patrones,  Prev: Introducción a reglas y patrones,  Up: Reglas y patrones

37.2 Definiciones sobre reglas y patrones
=========================================

 -- Función: apply1 (<expr>, <regla_1>, ..., <regla_n>)
     Aplica de forma repetida la <regla_1> a <expr> hasta que falla, a
     continuación aplica repetidamente la misma regla a todas las
     subexpresiones de <expr>, de izquierda a derecha, hasta que la
     <regla_1> haya fallado en todas las subexpresiones. Llámese
     <expr_2> al resultado de transformar <expr> de esta forma.
     Entonces la <regla_2> se aplica de la misma manera comenzando en
     el nivel superior de <expr_2>. Cuando la <regla_n> falla en la
     última expresión, se devuelve el resultado.

     `maxapplydepth' es el nivel de las subexpresiones más internas
     procesadas por `apply1' y `apply2'.

     Véase también `applyb1', `apply2' y `let'.


 -- Función: apply2 (<expr>, <regla_1>, ..., <regla_n>)
     Si la <regla_1> falla en una subexpresión dada, entonces se aplica
     la <regla_2> repetidamente, etc. Sólo si todas las reglas fallan
     en una subexpresión serán aplicadas todas las reglas de forma
     repetida a la siguiente subexpresión. Si alguna de las reglas
     tiene éxito entonces la misma subexpresión es reprocesada,
     comenzando por la primera regla.

     `maxapplydepth' es el nivel de las subexpresiones más internas
     procesadas por `apply1' y `apply2'.

     Véase también `applyb1' y `let'.


 -- Función: applyb1 (<expr>, <regla_1>, ..., <regla_n>)
     Aplica la <regla_1> reiteradamente hasta la subexpresión más
     interna de <expr> hasta que falle, a continuación pasa a aplicar
     la misma regla en un nivel superior (esto es, en subexpresiones
     más grandes), hasta que la <regla_1> falle en la expresión de
     nivel más alto. Después se aplica la <regla_2> de la misma manera
     al resultado obtenido de <regla_1>. Tras la aplicación de la
     <regla_n> a la expresión de mayor nivel, se devuelve el resultado.

     La función `applyb1' es similar a `apply1' pero opera de
     abajo-arriba, en lugar de arriba-abajo.

     `maxapplyheight' es la máxima altura a la que llega `applyb1'
     antes de terminar su cometido.

     Véase también `apply1', `apply2' y `let'.


 -- Variable opcional: current_let_rule_package
     Valor por defecto: `default_let_rule_package'

     La variable `current_let_rule_package' es el nombre del paquete de
     reglas que están utilizando las funciones del paquete `let'
     (`letsimp', etc.), a menos que se especifique otro paquete de
     reglas. A esta variable se le puede asignar el nombre de cualquier
     paquete de reglas definido por medio de la instrucción `let'.

     Si se hace la llamada `letsimp (expr, rule_pkg_name)', el paquete
     de reglas `rule_pkg_name' será utilizado únicamente para esa
     llamada y el valor de `current_let_rule_package' no cambia.


 -- Variable opcional: default_let_rule_package
     Valor por defecto: `default_let_rule_package'

     La variable `default_let_rule_package' es el nombre del paquete de
     reglas utilizado cuando el usuario no especifica otro
     explícitamente con `let' o cambiando el valor de
     `current_let_rule_package'.


 -- Función: defmatch (<nombre_prog>, <patrón>, <x_1>, ..., <x_n>)
     Crea una función `<nombre_prog> (<expr>, <y_1>, ..., <y_n>)' que
     analiza si <expr> coincide con el <patrón>.

     El <patrón> es una expresión que contiene las variables de patrón
     <x_1>, ..., <x_n> así como parámetros de patrón, si los hubiere.
     Las variables de patrón se dan de forma explícita como argumentos
     a `defmatch' mientras que los parámetros de patrón son declarados
     por la función `matchdeclare'.

     El primer argumento de la función creada <nombre_prog> es una
     expresión a ser comparada con el patrón y los demás argumentos son
     las variables <y_1>, ..., <y_n> en la expresión que se
     corresponden con las variables ficticias <x_1>, ..., <x_n> del
     patrón.

     Si el resultado de la comparación es positivo, <nombre_prog>
     devuelve una lista de ecuaciones cuyos miembros izquierdos son las
     variables patrones y los parámetros de patrón, y cuyos miembros
     derechos son las expresiones en las que se han producido las
     coincidencias con patrones y parámetros. A los parámetros de
     patrón, no a las variables, se les asignan las subexpresiones con
     las que coinciden. Si la comparación falla, <nombre_prog> devuelve
     `false'.

     Cualquier variable no declarada como parámetro de patrón en
     `matchdeclare' o como variable en `defmatch' solamente coinciden
     con ellas mismas.

     Un patrón que no contenga variables o parámetros de patrón
     devuelve `true' en caso de coincidencia.

     Véase también `matchdeclare', `defrule', `tellsimp' y
     `tellsimpafter'.

     Ejemplos:

     Este `defmatch' define la función `linearp (expr, y)', la cual
     analiza `expr' para comprobar si es de la forma `a*y + b' y que ni
     `a' ni `b' contengan a `y'.

          (%i1) matchdeclare (a, freeof(x), b, freeof(x))$
          (%i2) defmatch (linearp, a*x + b, x)$
          (%i3) linearp (3*z + (y+1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y

     Si el tercer argumento de `defmatch' en la entrada (%i2) hubiese
     sido omitido, entonces  `linear' solamente trataría de hacer
     coincidir expresiones lineales en <x>, pero no respecto de
     cualquier otra variable.

          (%i1) matchdeclare ([a, f], true)$
          (%i2) constinterval (l, h) := constantp (h - l)$
          (%i3) matchdeclare (b, constinterval (a))$
          (%i4) matchdeclare (x, atom)$
          (%i5) (remove (integrate, outative),
                    defmatch (checklimits, 'integrate (f, x, a, b)),
                    declare (integrate, outative))$
          (%i6) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o6)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i7) checklimits (%);
          (%o7)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
          (%i8) a;
          (%o8)                        x + %pi
          (%i9) b;
          (%o9)                       x + 2 %pi
          (%i10) f;
          (%o10)                       sin(t)
          (%i11) x;
          (%o11)                          t


 -- Función: defrule (<nombre_regla>, <patrón>, <reemplazamiento>)
     Define y da nombre a una regla de reemplazamiento para el patrón
     dado. Si la regla <nombre_regla> es aplicada a una expresión (por
     `apply1', `applyb1' o `apply2'), cada subexpresión que coincida
     con el patrón será reemplazada por el contenido de
     <reemplazamiento>.

     Las propias reglas pueden ser tratadas como funciones que
     transforman una expresión mediante una operación consistente en la
     búsqueda de una coincidencia y posterior aplicación de un
     reemplazamiento. Si la comparación falla se devuelve la expresión
     original.


 -- Función: disprule (<nombre_regla_1>, ..., <nombre_regla_n>)
 -- Función: disprule (all)
     Muestra las reglas de <nombre_regla_1>, ..., <nombre_regla_n>, tal
     como son devueltas por `defrule', `tellsimp' o `tellsimpafter', o
     un patrón definido por `defmatch'.  Cada regla se muestra con una
     etiqueta de expresión intermedia (`%t').

     La llamada `disprule (all)' muestra todas las reglas.

     La función `disprule' no evalúa sus argumentos y devuelve la lista
     de etiquetas de expresiones intermedias correspondientes a las
     reglas mostradas.

     Véase también `letrules', que muestra las reglas definidas por
     `let'.

     Ejemplos:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
               +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]


 -- Función: let (<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>)
 -- Función: let ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
          <nombre_paquete>)
     Define una regla de sustitución para `letsimp' tal que <prod> es
     sustituido por <repl>, donde <prod> es un producto de potencias
     positivas o negativas de los términos siguientes:

        * Átomos que `letsimp' buscará a menos que antes de llamar a
          `letsimp' se utilice la función `matchdeclare' para asociar
          un predicado con el átomo. En este caso `letsimp' hará
          coincidir el átomo con cualquier término del producto que
          satisfaga el predicado.

        * Expresiones básicas como `sin(x)', `n!', `f(x,y)', etc.  Como
          en el caso anterior, `letsimp' buscará coincidencias exactas,
          a menos que se utilice `matchdeclare' para asociar un
          predicado con el argumento de la expresión básica (`sin(x)',
          `n!', `f(x,y)', ...).

     Si se incluye un predicado en la función `let' seguido de una
     lista de argumentos, una coincidencia aceptable  (es decir, una
     que fuese aceptada si se hubiese omitido el predicado) se aceptará
     sólo si `predname (arg_1', ..., arg_n')' vale `true', donde
     <arg_i'> es el valor coincidente con <arg_i>.  El argumento
     <arg_i> puede ser el nombre de cualquier átomo o el argumento de
     cualquier expresión básica que aparezca en <prod>.  <repl> puede
     ser cualquier expresión racional. Si cualquiera de los átomos o
     argumentos de <prod> aparece en <repl> se llevan a cabo las
     sustituciones correspondientes.

     La variable global `letrat' controla la simplificación de los
     cocientes por `letsimp'. Cuando `letrat' vale  `false', `letsimp'
     simplifica separadamente el numerador y denominador de  <expr> y
     no simplifica el cociente. Sustituciones como que `n!/n' se
     reduzca a `(n-1)!' ya no se realizarán. Cuando  `letrat' vale
     `true', entonces se simplifican el numerador, el denominador y el
     cociente, en este orden.

     Estas funciones de sustitución permiten al usuario trabajar con
     varios paquetes de reglas al mismo tiempo. Cada paquete de reglas
     puede contener cierto número de reglas `let' que son referenciadas
     por un nombre dado por el usuario.  `let ([<prod>, <repl>,
     <predname>, <arg_1>, ..., <arg_n>], <nombre_paquete>)' añade la
     regla  <predname> al paquete de reglas  <nombre_paquete>. `letsimp
     (<expr>, <package_name>)' aplica las reglas de <nombre_paquete>.
     La llamada `letsimp (<expr>, <nombre_paquete1>, <nombre_paquete2>,
     ...)' es equivalente a `letsimp (<expr>, <nombre_paquete1>)'
     seguida de `letsimp (%, <nombre_paquete2>)', ....

     `current_let_rule_package' es el nombre del paquete de reglas que
     se está utilizando. A esta variable se le puede asignar el nombre
     de cualquier paquete de reglas definido mediante el comando `let'.
     Siempre que una de las funciones incluidas en el paquete  `let'
     sean invocadas sin nombre de paquete, se utilizará el paquete cuyo
     nombre se guarde en `current_let_rule_package'. Si se hace una
     llamada tal como `letsimp (<expr>, <rule_pkg_name>)', el paquete
     de reglas <rule_pkg_name> es utilizado solamente para ese comando
     `letsimp', sin efectuarse cambios en `current_let_rule_package'. A
     menos que se indique otra cosa, `current_let_rule_package' toma
     por defecto el valor de `default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1


 -- Variable opcional: letrat
     Valor por defecto: `false'

     Cuando `letrat' vale `false', `letsimp' simplifica separadamente
     el numerador y denominador de una fracción sin simplificar luego
     el cociente.

     Cuando `letrat' vale `true', se simplifican el numerador,
     denominador y cociente, por este orden.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!


 -- Función: letrules ()
 -- Función: letrules (<nombre_paquete>)
     Muestra las reglas de un paquete de reglas. La llamada `letrules
     ()' muestra las reglas del paquete de reglas actual. La llamada
     `letrules (<nombre_paquete>)' muestra las reglas de
     `nombre_paquete'.

     El paquete de reglas actual tiene su nombre almacenado en by
     `current_let_rule_package'. A menos que se indique de otra manera,
     `current_let_rule_package' toma por defecto el valor de
     `default_let_rule_package'.

     Véase también `disprule', que muestra las reglas definidas por
     `tellsimp' y `tellsimpafter'.


 -- Función: letsimp (<expr>)
 -- Función: letsimp (<expr>, <nombre_paquete>)
 -- Función: letsimp (<expr>, <nombre_paquete_1>, ...,
          <nombre_paquete_n>)
     Aplica repetidamente las reglas definidas por `let' hasta que no
     se puedan hacer más cambios en <expr>.

     La llamada `letsimp (<expr>)' utiliza las reglas de
     `current_let_rule_package'.

     La llamada `letsimp (<expr>, <nombre_paquete>)' utiliza las reglas
     de <nombre_paquete> sin efectuar cambios en
     `current_let_rule_package'.

     La llamada `letsimp (<expr>, <nombre_paquete_1>, ...,
     <nombre_paquete_n>)' es equivalente a `letsimp (<expr>,
     <nombre_paquete_1>', seguida de  `letsimp (%, <nombre_paquete_2>)'
     y así sucesivamente.


 -- Variable opcional: let_rule_packages
     Valor por defecto: `[default_let_rule_package]'

     La variable `let_rule_packages' guarda una lista con todos los
     paquetes de reglas definidos por el usuario, junto con el paquete
     por defecto `default_let_rule_package'.


 -- Función: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Asocia un predicado <pred_k> con una variable o lista de variables
     <a_k>, de forma que  <a_k> se comparará con expresiones para las
     cuales el predicado devuelva algo que no sea `false'.

     El predicado es el nombre de una función, una llamada de función
     sin su último argumento, `true' o `all'.  Cualquier expresión se
     hace coincidir con `true' o `all'. Si el predicado se especifica
     como una llamada de función, la expresión a ser analizada es
     añadida a su lista de argumentos; siendo los argumentos evaluados
     en el momento de ser evaluada la comparación. En cambio, si el
     predicado se especifica como un nombre de función, la expresión a
     ser analizada será su único argumento. No es necesario definir una
     función de predicado cuando se hace una llamada a `matchdeclare';
     el predicado no se evalúa hasta que se ensaya  una comparación.

     Un predicado de `matchdeclare' debe ser necesariamente un nombre
     de función o una llamada a función. En particular, un predicado no
     puede ser función `lambda' o un `block'.

     Si una expresión satisface un predicado, se asigna a la variable
     de comparación la expresión, excepto cuando las variables de
     comparación son operandos de sumas `+' o multiplicaciones `*'.
     Solamente las sumas y multiplicaciones son tratadas de forma
     especial; los demás operadores n-arios (tanto los del sistema como
     los definidos por el usuario) son tratados como funciones
     ordinarias.

     En el caso de sumas y multiplicaciones, a la variable de
     comparación se le puede asignar una expresión simple que satisfaga
     el predicado de comparación, o una suma o producto,
     respectivamente, de tales expresiones. Los predicados son
     evaluados en el orden en el que sus variables asociadas aparecen
     en el patrón de comparación, y un término que satisfaga más de un
     predicado es tomado por el primer predicado que satisfaga. Cada
     predicado se compara con todos los operandos de la suma o producto
     antes de ser evaluado el siguiente predicado. Además, si 0 o 1,
     respectivamente, satisface un predicado de comparación, y no hay
     otros términos que lo satisfagan, se asignará el 0 o 1 a la
     variable de comparación asociada al predicado.

     El algoritmo para procesar patrones de suma y multiplicación hace
     que los resultados de algunas comparaciones dependan del orden de
     los términos en el patrón de comparación y en la expresión a ser
     comparada. Sin embargo, si todos los predicados de comparación son
     mutuamente excluyentes, el resultado de la comparación no depende
     para nada de la ordenación, puesto que un predicado de comparación
     no puede aceptar términos aceptados por otros predicados.

     Invocando `matchdeclare' con una variable <a> como argumento
     cambia la propiedad de `matchdeclare' para  <a>, si ya había una
     declarada; solamente el `matchdeclare' más reciente está activo
     cuando se define una regla. Cambios posteriores en la propiedad de
     `matchdeclare' (via `matchdeclare' o `remove') no afectan a las
     reglas existentes.

     `propvars (matchdeclare)' devuelve la lista de todas las variables
     para las cuales hay una propiedad de `matchdeclare'. La llamada
     `printprops (<a>, matchdeclare)' devuelve el predicado para la
     variable `a'.  La llamada `printprops (all, matchdeclare)'
     devuelve la lista de predicados de todas las variables de
     `matchdeclare'. La llamada `remove (<a>, matchdeclare)' borra la
     propiedad `matchdeclare' de <a>.

     Las funciones `defmatch', `defrule', `tellsimp', `tellsimpafter' y
     `let' construyen reglas que analizan expresiones mediante patrones.

     `matchdeclare' no evalúa sus argumentos y siempre devuelve `done'.

     Ejemplos:

        * `q' compara una expresión que no contiene `x' ni `%e'.

          (%i1) matchdeclare (q, freeof (x, %e))$


 -- Función: matchfix (<ldelimiter>, <rdelimiter>)
 -- Función: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)
     Declara un operador "matchfix" con delimitadores a la izquierda y
     derecha, <ldelimiter> y <rdelimiter>, respectivamente. Los
     delimitadores son cadenas alfanuméricas.

     Un operador "matchfix" es una función con un número arbitrario de
     argumentos, de manera que los argumentos se presentan entre los
     delimitadores de la izquierda y derecha. Los delimitadores pueden
     ser cualquier tipo de cadena, en tanto que el analizador
     sintáctico pueda distinguirlos de los operandos y de expresiones
     con operadores. En la práctica esto excluye delimitadores como
     `%', `,', `$' y `;',  necesitando aislar los delimitadores con
     espacios en blanco. El delimitador de la derecha puede ser igual o
     diferente del de la izquierda.

     Un delimitador de la izquierda sólo puede asociarse con un único
     delimitador de la derecha; dos operadores "matchfix" diferentes no
     pueden tener el mismo delimitador por la izquierda.

     Un operador ya existente puede declararse como operador "matchfix"
     sin necesidad de que cambie el resto de propiedades. En
     particular, los operadores de Maxima tales como la suma `+' pueden
     ser declarados como "matchfix".

     La llamada `matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>,
     <pos>)'  declara el argumento <arg_pos> y el resultado <pos>, así
     como los delimitadores  <ldelimiter> y <rdelimiter>.

     La función que ejecutará una operación "matchfix" será una típica
     función definida por el usuario. La función de operador se define
     por el método habitual con  `:=' o `define'. Los argumentos pueden
     escribirse entre los delimitadores, o con el delimitador izquierdo
     como una cadena precedida de apóstrofo y seguidamente los
     argumentos entre paréntesis. La llamada `dispfun (<ldelimiter>)'
     muestra la definición de la función.

     El único operador "matchfix" de Maxima es el constructor de listas
     `[ ]'. Los paréntesis  `( )' y las comillas dobles  `" "'  actúan
     como operadores "matchfix", pero son tratados como operadores
     "matchfix" por el analizador sintáctico de Maxima.

     Ejemplos:

        * Los delimitadores pueden ser practicamente cualquier cadena.

          (%i1) matchfix ("@", "~");
          (%o1)                          "@"
          (%i2) @ a, b, c ~;
          (%o2)                       @a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                         ">>"
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                         "foo"
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                       @p, q~

        * Los operadores "matchfix" son funciones definidas por el
          usuario.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15


 -- Función: remlet (<prod>, <nombre>)
 -- Función: remlet ()
 -- Función: remlet (all)
 -- Función: remlet (all, <nombre>)
     Elimina la última regla de sustitución prod -> repl que haya sido
     definida por la función `let'. Si se suministar el nombre la regla
     será borrada del paquete con ese mismo nombre.

     Las llamadas `remlet()' y `remlet(all)' eliminan todas las reglas
     de sustitución del paquete de reglas actual. Si se suministra el
     nombre de un paquete de reglas, como en `remlet (all, <nombre>)',
     el paquete de reglas con ese  <nombre> es también eliminado.

     Si es necesario cambiar una sustitución haciendo uso de la misma
     producción, no es necesario llamar a  `remlet', simplemente
     redefínase la sustitución utilizando la misma producción con la
     función  `let' junto con el nuevo reemplazamiento y/o nombre de
     predicado. De ser llamado nuevamente `remlet (<prod>)' la
     sustitución original sería recuperada.

     Véase también `remrule', que elimina una regla definida por
     `tellsimp' o `tellsimpafter'.


 -- Función: remrule (<op>, <nombre_regla>)
 -- Función: remrule (<op>, all)
     Elimina las reglas previamente definidas por `tellsimp' o
     `tellsimpafter'.

     La llamada `remrule (<op>, <nombre_regla>)' elimina la regla de
     nombre  `nombre_regla' del operador <op>.

     Independientemente de que  <op> sea un operador propio de Maxima o
     haya sido definido por el usario (como los establecidos por
     `infix', `prefix', etc.), tanto <op> como <rulename> deben ir
     encerrados entre comillas dobles.

     La llamada `remrule (<function>, all)' borra todas las reglas para
     el operador <op>.

     Véase también `remlet', que elimina una regla definida mediante
     `let'.

     Ejemplos:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@");
          (%o3)                          @
          (%i4) tellsimp (aa @ bb, bb/aa);
          (%o4)                   [@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @ bb, quux (%pi, %e), quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@", "@rule1");
          (%o10)                         @
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @ bb, quux (%pi, %e), quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @ bb, quux(%pi, %e),
                                                             quux(%e, %pi)]


 -- Función: tellsimp (<patrón>, <reemplazamiento>)
     La función `tellsimp' es similar a  `tellsimpafter' pero coloca
     nueva información antes que la antigua, de manera que se aplica
     antes que las reglas de simplificación de Maxima.

     La función `tellsimp' se utiliza cuando es importante utilizar la
     expresión antes de que el simplificador opere sobre ella; por
     ejemplo, cuando el simplificador ya "sabe" algo sobre una
     expresión, pero lo que devuelve no es lo que quiere el usuario. En
     cambio, cuando  el simplificador ya "sabe" algo sobre una
     expresión pero lo que devuelve no es lo suficiente para el
     usuario, entonces éste podrá estar interesado en utilizar
     `tellsimpafter'.

     El patrón no puede ser una suma, ni un producto, ni una variable
     ni un número.

     `rules' es la lista de reglas definidas por `defrule', `defmatch',
     `tellsimp' y `tellsimpafter'.

     Ejemplos:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)


 -- Función: tellsimpafter (<patrón>, <reemplazamiento>)
     Define una regla de simplificación que el simplificador aplicará
     después de las reglas de simplificación propias de de Maxima. El
     <patrón> es una expresión que contiene variables de patrón
     (declaradas por `matchdeclare') junto con otros átomos y
     operadores. El contenido de <reemplazamiento> sustituye una
     expresión que coincida con el patrón; a las variables de patrón en
     <reemplazamiento> se les asignan los valores coincidentes en la
     expresión.

     El <patrón> puede ser una expresión no atómica en la que el
     operador principal no sea una variable de patrón; la regla de
     simplificación se asocia con el operador principal. Los nombres de
     las funciones (con una excepción que se indica más abajo), listas
     y arrays pueden aparecer en el <patrón> como operador principal
     sólo como literales (no variables de patrones); esto excluye
     expresiones como  `aa(x)' y `bb[y]', si tanto `aa' como `bb' son
     patrones de variables. Nombres de funciones, listas y arrays que
     sean variables de patrón pueden aparecer como operadores que no
     sean el operador principal de  <patrón>.

     Hay una excepción a la regla indicada más arriba concerniente a
     los nombres de funciones. El nombre de una función subindicada en
     una expresión tal como `aa[x](y)' puede ser una variable de patrón
     porque el operador principal no es  `aa' sino el átomo de Lisp
     `mqapply'. Esta es una consecuencia de la representación de
     expresiones que contienen funciones subindicadas.

     Las reglas de simplificación se aplican tras las evaluaciones (a
     menos que se supriman con el apóstrofo o la variable `noeval').
     Las reglas establecidas por `tellsimpafter' se aplican en el orden
     en que han sido definidas y después de las reglas propias de
     Maxima. Las reglas se aplican de abajo arriba, esto es, se aplican
     primero a las subexpresiones antes que a toda la expresión. Puede
     ser necesario simplificar repetidamente un resultado (por ejemplo,
     mediante el operador de doble comilla simple `''' o la variable
     `infeval') para asegurar que se aplican todas las reglas.

     Las variables de patrón se tratan como variables locales en las
     reglas de simplificación. Una vez definida una regla, el valor de
     una variable de patrón no afecta a la regla, ni se ve influenciada
     poe ésta. Una asignación a una variable de patrón que resulta de
     la aplicación exitosa de una regla no afecta a la asignación
     actual de la variable de patrón. Sin embargo, como cualquier otro
     átomo de Maxima, las propiedades de las variables de patrón (tal
     como se definen con `put' y sus funciones relacionadas) son
     globales.

     La regla construida por  `tellsimpafter' es nombrada detrás del
     operador principal de `patrón'. Reglas para operadores de Maxima y
     operadores definidos por el usuario con `infix', `prefix',
     `postfix', `matchfix' y `nofix', tienen nombres que son cadenas
     alfanuméricas de Maxima. Reglas para otras funciones tienen
     nombres que son identificadores ordinarios de Maxima.

     El tratamiento de formas nominales y verbales es hasta cierto
     punto confuso. Si se define una regla para una forma nominal (o
     verbal)  y ya existe una regla para la correspondiente forma
     verbal (o nominal), la regla recién definida se aplica a ambas
     formas (nominal y verbal). Si no existe regla para una forma
     verbal (o nominal) la regla recién definida se aplica únicamente a
     la forma nominal (o verbal).

     La regla construida por  `tellsimpafter' es una típica función de
     Lisp. Si el nombre de la regla es `$foorule1', la sentencia `:lisp
     (trace $foorule1)' hace una traza de la función y  `:lisp
     (symbol-function '$foorule1' muestra su definición.

     La función `tellsimpafter' no evalúa sus argumentos y devuelve la
     lista de reglas para el operador principal de  <patrón>, incluida
     la regla recién establecida.

     Véanse también `matchdeclare', `defmatch', `defrule', `tellsimp',
     `let', `kill', `remrule' y `clear_rules'.

     Ejemplos:

     <pattern> puede ser cualquier expresión no atómica en la que el
     operador principal no sea una variable de patrón.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Las reglas se aplican en el orden en que se definen. Si dos reglas
     coinciden con una expresión, se aplica aquélla que haya sido
     definida en primer lugar.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     Las variables de patrón se tratan como variables locales en las
     reglas de simplificación.  (Compárese con `defmatch', que trata
     las variables de patrón como globales.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Como cualquier otro átomo, las propiedades de las variables de
     patrón son globales, incluso cuando sus valores sean locales. En
     este ejemplo se declara una propiedad de asignación a treavés de
     `define_variable'. Esta es una propiedad del átomo  `bb' en todo
     Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Las reglas se nombran después de los operadores principales. Los
     nombres de reglas tanto para las funciones de Maxima como para las
     definidas por el usuario son cadenas alfanuméricas, mientras que
     los nombres de las otras funciones son identificadores típicos.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4,
          htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1,
          foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
          (%o10)                    [false, true]
          (%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
          (%o11)                    [true, true]
          (%i12) remrule (foo, foorule1);
          (%o12)                         foo
          (%i13) remrule ("^", "^rule1");
          (%o13)                          ^


 -- Función: clear_rules ()
     Ejecuta `kill (rules)' y después inicializa el siguiente número de
     regla a 1 para la adición `+', multiplicación `*' y exponenciación
     `^'.



File: maxima.info,  Node: Listas,  Next: Conjuntos,  Prev: Reglas y patrones,  Up: Top

38 Listas
*********

* Menu:

* Introducción a las listas::
* Definiciones para listas::


File: maxima.info,  Node: Introducción a las listas,  Next: Definiciones para listas,  Prev: Listas,  Up: Listas

38.1 Introducción a las listas
==============================

Las listas son bloques de construcción básica para Maxima y Lisp. Todos
los tipos de datos diferentes a los arreglos, tablas mixtas o números
son representados como listas Lisp, estas listas Lisp tienen la forma

     ((MPLUS) $A 2)

para indicar la expresión `a+2'. Al nivel de Maxima se observará la
notación infija `a+2'. Maxima también tiene listas con el formato

     [1, 2, 7, x+y]

para una lista de 4 elementos. Internamente esto se corresponde con una
lista Lisp de la forma

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

El elemento que denota el tipo de expresión en Maxima es también una
lista, la cual tras ser analizada y simplificada tomará la forma

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Definiciones para listas,  Prev: Introducción a las listas,  Up: Listas

38.2 Definiciones para listas
=============================

 -- Función: append (<lista_1>, ..., <lista_n>)
     Devuelve una lista cuyos elementos son los de la lista <lista_1>
     seguidos de los de <lista_2>, ...  La función `append' también
     opera con expresiones generales, como la llamada `append (f(a,b),
     f(c,d,e));', de la que se obtiene `f(a,b,c,d,e)'.

     Tecléese `example(append);' para ver un ejemplo.


 -- Función: assoc (<clave>, <lista>, <valor_por_defecto>)
 -- Function: assoc (<clave>, <lista>)
     Esta función busca la <clave> en el lado derecho de la  <lista>,
     la cual es de la forma `[x,y,z,...]', donde cada elemento  es una
     expresión formada por un operador binario y dos elementos. Por
     ejemplo, `x=1', `2^3', `[a,b]' etc.  La <clave> se compara con el
     primer operando. La función `assoc' devuelve el segundo operando
     si se encuentra con que la `clave' coincide.  Si la `clave' no
     coincide entonces devuelve el valor <valor_por_defecto>. El
     argumento <valor_por_defecto> es opcional; en caso de no estar
     presente, se devolverá `false'.


 -- Función: atom (<expr>)
     Devuelve `true' si <expr> es un átomo (número, nombre o cadena
     alfanumérica) y `false' en caso contario. Así, `atom(5)' devolverá
     `true', mientras que `atom(a[1])' y `atom(sin(x))' darán como
     resultado `false' (dando por hecho que tanto `a[1]' como `x' no
     tienen valores asignados).


 -- Función: cons (<expr>, <lista>)
     Devuelve una nueva lista en la que el elemento <expr> ocupa la
     primera posición, seguido de los elementos de <lista>. La función
     `cons' también opera con otro tipo de expresiones, como  `cons(x,
     f(a,b,c));'  ->  `f(x,a,b,c)'.


 -- Función: copylist (<lista>)
     Devuelve una copia de la <lista>.


 -- Función: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)
     Crea una lista mediante la evaluación de <form> con <x_1> tomando
     cada uno de los valores de <list_1>, para cada uno de estos
     valores liga <x_2> con cada elemento de <list_2>, .... El número
     de elementos en el resultado será el producto del número de
     elementos en cada lista. Cada variable <x_i> debe ser un símbolo y
     no será evaluado. La lista de argumentos será evaluada una vez al
     comienzo de la iteración.

     Por ejemplo:
          (%i1) create_list(x^i,i,[1,3,7]);
                           3   7
          (%o1)       [x, x , x ]

     Con una doble iteración:

          (%i1) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o1) [[a, e], [a, f], [a, h], [b, e], [b, f], [b, h]]

     En lugar de <list_i> se pueden suministrar dos argumentos cada uno
     de los cuales debería poder evaluarse a un número, los cuales
     serán los límites inferior y superior, ambos inclusive, para cada
     iteración.

     Por ejemplo:
          (%i1) create_list([i,j],i,[1,2,3],j,1,i);
          (%o1) [[1, 1], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]]

     Nótese que los límites o lista para la variable <j> pueden depender
     del valor actual de <i>.

 -- Función: delete (<expr_1>, <expr_2>)
 -- Función: delete (<expr_1>, <expr_2>, <n>)
     Elimina las expresiones <expr_1> de <expr_2>. La expresión
     <expr_1> a eliminar puede ser un sumando de <expr_2> (en caso de
     que ésta sea una suma) o un factor de <expr_2> (si se trata de un
     producto).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     La llamada `delete(<expr_1>, <expr_2>, <n>)' elimina las primeras
     <n> apariciones de <expr_1> en  <expr_2>.  En caso de que <expr_1>
     aparezca menos de <n> veces dentro de la expresión de referencia
     <expr_2> entonces se eliminan todas ellas.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)


 -- Función: eighth (<expr>)
     Devuelve el octavo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: endcons (<expr>, <lista>)
     Devuelve una nueva lista formada por los elementos de `lista'
     seguidos de los de <expr>. La función `endcons' también opera con
     expresiones generales, por ejemplo `endcons(x, f(a,b,c));'  ->
     `f(a,b,c,x)'.


 -- Función: fifth (<expr>)
     Devuelve el quinto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: first (<expr>)
     Devuelve la primera parte de <expr>, que puede consistir en el
     primer elemento de una lista, la primera fila de una matriz, el
     primer término de una suma, etc. Nótese que tanto `first' como sus
     funciones relacionadas, `rest' y `last', operan sobre la forma en
     la que <expr> es mostrada por Maxima, no sobre la forma en la que
     es introducida la expresión. Sin embargo, cuando la variable
     `inflag' toma el valor `true' estas funciones tendrán en cuenta el
     formato interno de <expr>. Téngase en cuenta que el simplificador
     reordena las expresiones.  Así, `first(x+y)' devolverá `x' si
     `inflag' vale `true' y `y' cuando `inflag' tome el valor `false'
     (`first(y+x)' devuelve el mismo resultado). Las funciones `second'
     ... `tenth' devuelven desde el segundo hasta el décimo elemento
     del argumento de entrada.


 -- Función: fourth (<expr>)
     Devuelve el cuarto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: get (<a>, <i>)
     Recupera la propiedad de usuario indicada por <i> asociada al
     átomo <a> o devuelve `false' si <a> no tiene la propiedad <i>.

     La función `get' evalúa sus argumentos.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]


 -- Función: join (<l>, <m>)
     Crea una nueva lista con los elementos de las listas <l> y <m>
     alternados.  El resultado tiene como elementos `[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]'.  Las listas <l> y <m> pueden contener
     cualquier tipo de elementos.

     Si las listas son de diferente longitud, `join' ignora los
     elementos sobrantes de la lista más larga.

     Maxima da error si o bien <l> o <m> no son listas.

     Ejemplos:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]


 -- Función: last (<expr>)
     Devuelve la última parte (término, fila, elemento, etc.) de <expr>.


 -- Función: length (<expr>)
     Devuelve (por defecto) el número de partes de que consta <expr> en
     la versión correspondiente a la que muestra.  En el caso de
     listas, se devuelve el número de elementos, si se trata de
     matrices el número de filas y se se trata de sumas el número de
     términos o sumandos (véase `dispform').

     La función `length' se ve afectada por el valor de la variable
     `inflag'.  Así, `length(a/(b*c));' devuelve 2 si `inflag' vale
     `false' (dando por hecho que `exptdispflag' vale `true'), pero
     devuelve 3 si `inflag' vale `true' (ya que la representación
     interna es `a*b^-1*c^-1').


 -- Variable opcional: listarith
     Valor por defecto: `true'

     Cuando vale `false' provoca que no se realicen operaciones
     aritméticas con listas;  cuando vale `true', las operaciones con
     listas y matrices son contagiosas, en el sentido de que las listas
     se transforman en matrices, retornando resultados de este último
     tipo. Sin embargo, operaciones que involucren listas con listas
     devolverán también listas.


 -- Función: listp (<expr>)
     Devuelve el valor `true' si <expr> es una lista, y `false' en caso
     contrario.


 -- Función: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Función: makelist (<expr>, <x>, <list>)
     Construye y devuelve una lista, siendo cada uno de sus elementos
     generados por <expr>.

     La llamada `makelist (<expr>, <i>, <i_0>, <i_1>)' devuelve una
     lista cuyo `j'-ésimo elemento es igual a `ev (<expr>, <i>=j)',
     tomando  `j' los valores enteros entre  <i_0> y <i_1>.

     La llamada `makelist (<expr>, <x>, <list>)' devuelve una lista
     cuyo `j'-ésimo elemento es igual a `ev (<expr>, <x>=<list>[j])',
     tomando  `j' los valores enteros entre  1 through `length
     (<list>)'.

     Ejemplos:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]


 -- Función: member (<expr>, <lista>)
     Devuelve el valor `true' si <expr> resulta ser un miembro de la
     <lista> (no que forme parte de uno de sus miembros). En caso
     contrario se devuelve `false'. La función  `member' también opera
     sobre expresiones que no son necesariamente listas, como por
     ejemplo `member(b,f(a,b,c));'  ->  `true'.


 -- Función: ninth (<expr>)
     Devuelve el noveno elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: rest (<expr>, <n>)
 -- Función: rest (<expr>)
     Devuelve <expr> sin sus primeros <n> elementos si <n> es positivo,
     o sus últimos `- <n>' elementos si <n> es negativo. En caso de que
     <n> tome el valor 1 puede ser omitido. La expresión  <expr> puede
     ser una lista, una matriz o cualquier otra expresión.


 -- Función: reverse (<lista>)
     Invierte el orden de los elementos de la <lista> (no los propios
     elementos). La función `reverse' también opera sobre expresiones
     generales, como en  `reverse(a=b);' gives `b=a'.


 -- Función: second (<expr>)
     Devuelve el segundo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: seventh (<expr>)
     Devuelve el séptimo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: sixth (<expr>)
     Devuelve el sexto elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: tenth (<expr>)
     Devuelve el décimo elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.


 -- Función: third (<expr>)
     Devuelve el tercer elemento de la lista o expresión <expr>. Véase
     `first' para más detalles.



File: maxima.info,  Node: Conjuntos,  Next: Definición de Funciones,  Prev: Listas,  Up: Top

39 Conjuntos
************

* Menu:

* Introducción a los conjuntos::
* Definiciones para los conjuntos::


File: maxima.info,  Node: Introducción a los conjuntos,  Next: Definiciones para los conjuntos,  Prev: Conjuntos,  Up: Conjuntos

39.1 Introducción a los conjuntos
=================================

Maxima dispone de funciones para realizar operaciones con conjuntos,
como la intersección o la unión. Los conjuntos deben ser finitos y
definidos por enumeración. Maxima trata a los conjuntos y a las listas
como objectos de distinta naturaleza, lo que permite trabajar con
conjuntos cuyos elementos puedan ser también conjuntos o listas.

   Además de funciones para operar con conjuntos finitos, Maxima
dispone también de algunas funciones sobre combinatoria, como los
números de Stirling de primera y segunda especie, números de Bell,
coeficientes multinomiales, particiones de enteros no negativos y
algunos otros. Maxima también define la función delta de Kronecker.

39.1.1 Utilización
------------------

Para construir un conjunto cuyos elementos sean `a_1, ..., a_n', se
utiliza la instrucción  `set(a_1, ..., a_n)' o `{a_1, ..., a_n}'; para
formar un conjunto vacío, basta con hacer `set()' o `{}'. Para
introducir conjuntos en Maxima, `set (...)' y `{ ... }' son
equivalentes. Los conjuntos se muestran siempre con llave.

   Si un elemento se indica más de una vez, el proceso de
simplificación elimina los elementos redundantes.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Dos elementos candidatos a formar parte de un conjunto, <x> e <y>,
son redundantes, esto es, se consideran el mismo elemento a efectos de
consruir el conjunto, si y sólo si `is (<x> = <y>)' devuelve el valor
`true'. Nótese que `is (equal (<x>, <y>))' puede devolver `true' y `is
(<x> = <y>)' retornar `false'; en cuyo caso los elementos <x> e <y> se
considerarían distintos.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) set (x, y, z);
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   Para formar un conjunto a partir de los miembros de una lista úsese
`setify'.

     (%i1) setify([b, a]);
     (%o1)                        {a, b}

   Los elementos `x' e `y' de un conjunto se consideran iguales si
`is(x = y)' devuelve el valor `true'. Así, `rat(x)' y `x' se consideran
el mismo elemento de un conjunto; consecuentemente,

     (%i1) set(x, rat(x));
     (%o1)                          {x}

   Además, puesto que  `is((x-1)*(x+1) = x^2 - 1)' devuelve `false',
`(x-1)*(x+1)' y `x^2-1' se consideran elementos diferentes; así

     (%i1) set((x - 1)*(x + 1), x^2 - 1);
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   Para reducir este conjunto a otro unitario, aplicar `rat' a cada
elemento del conjunto:

     (%i1) set((x - 1)*(x + 1), x^2 - 1);
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map(rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   Para eliminar redundancias con otros conjuntos, será necesario
utilizar otras funciones de simplificación. He aquí un ejemplo que
utiliza  `trigsimp':

     (%i1) set(1, cos(x)^2 + sin(x)^2);
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map(trigsimp, %);
     (%o2)                          {1}

   Se entiende que un conjunto está simplificado cuando entre sus
elementos no hay redundancias y se hayan ordenados. La versión actual
de las funciones para conjuntos utiliza la función `orderlessp' de
Maxima para ordenar sus elementos; sin embargo, futuras versiones de
las funciones para operar con conjuntos podrán utilizar otras funciones
de ordenación.

   Algunas operaciones con conjuntos, tales como la sustitución,
fuerzan automáticamente una re-simplificación; por ejemplo,

     (%i1) s: set (a, b, c)$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima considera a las listas y conjuntos como objetos diferentes;
funciones tales como `union' y `intersection' provocarán un error si
alguno de sus argumentos es una lista. Si se necesita aplicar una
función de conjunto a una lista, se deberá utilizar la función `setify'
para convertirla previamente en conjunto. Así,

     (%i1) union ([1, 2], set (a, b));
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), set (a, b));
     (%o2)                     {1, 2, a, b}

   Para extraer todos los elementos de un conjunto `s' que satisfagan
un predicado `f', úsese `subset(s,f)'. (Un predicado es una función
booleana.) Por ejemplo, para encontrar las ecuaciones en un conjunto
dado que no dependan de la variable `z', se hará

     (%i1) subset (set (x + y + z, x - y + 4, x + y - 5), lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   La sección `Definiciones para los conjuntos' incluye una lista
completa de funciones para operar con conjuntos en  Maxima.

39.1.2 Iteraciones con elementos
--------------------------------

Hay dos formas para operar iterativamente sobre los elementos de un
conjunto. Una es utilizar `map'; por ejemplo:

     (%i1) map (f, set (a, b, c));
     (%o1)                  {f(a), f(b), f(c)}

   La otra forma consiste en hacer uso de la construcción `for <x> in
<s> do'

     (%i1) s: set (a, b, c);
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   Las funciones de Maxima  `first' y `rest' funcionan también con
conjuntos.  En este caso, `first' devuelve el primer elemento que se
muestra del conjunto, el cual puede depender de la implementación del
sistema. Si `s' es un conjunto, entonces `rest(s)' equivale a `disjoin
(first(s), s)'. Hay otras funciones que trabajan correctamente con
conjuntos. En próximas versiones de las funciones para operar con
conjuntos es posible que `first' y `rest' trabajen de modo diferente o
que ya no lo hagan en absoluto.

39.1.3 Fallos
-------------

Las funciones para operar con conjuntos utilizan la función
`orderlessp' de Maxima para ordenar los elementos de los conjuntos, así
como la función `like' de Lisp para decidir sobre la igualdad de dichos
elementos. Ambas funciones tienen fallos que son conocidos y que pueden
aflorar si se trabaja con conjuntos que tengan elementos en formato de
listas o matrices y que contengan expresiones CRE. Un ejemplo es

     (%i1) set ([x], [rat (x)]);
     Maxima encountered a Lisp error:

      CAR: #:X13129 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Esta instrucción provoca una parada de Maxima junto con la emisión
de un mensaje de error, el cual dependerá de la versión de Lisp que
utilice Maxima. Otro ejemplo es

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

      CAR: #:A13129 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Estos fallos son causados por fallos en  `orderlessp' y `like', no
por fallos cuyo origen se encuentre en las funciones para conjuntos.
Para ilustrarlo, se pueden ejecutar las siguientes instrucciones

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

      CAR: #:B13130 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Hasta que estos errores no se corrijan, no es aconsejable construir
conjuntos que tengan por elementos listas o matrices que contengan
expresiones en forma CRE; sin embargo, un conjunto con elementos de la
forma CRE no deberían dar problemas:

     (%i1) set (x, rat (x));
     (%o1)                          {x}

   La función `orderlessp' de Maxima tiene otro fallo que puede causar
problemas con las funciones para conjuntos, en concreto, que el
predicado de ordenación `orderlessp' no es transitivo. El ejemplo más
simple que ilustra este punto es

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   El fallo puede causar problemas con todas las funciones para
conjuntos, así como también con otras funciones de Maxima. Es probable,
pero no seguro, que si todos los elementos del conjunto están en la
forma CRE o han sido simplificados con `ratsimp', entonces el fallo no
se manifiesta.

   Los mecanismos `orderless' y `ordergreat' de Maxima son
incompatibles con las funciones para conjuntos. Si se necesitan
utilizar `orderless' o `ordergreat', hágase antes de construir los
conjuntos y no se utilice la instrucción `unorder'.

   La función `sign' de Maxima tiene un fallo que puede causar que la
función delta de Kronecker trabaje incorrectamente; por ejemplo:

     (%i1) kron_delta (1/sqrt(2), sqrt(2)/2);
     (%o1)                           0

   El valor correcto es 1. El fallo está causado por el de la función
`sign'

     (%i1) sign (1/sqrt(2) - sqrt(2)/2);
     (%o1)                          pos

   Se ruega a todo usuario que crea haber encontrado un fallo en las
funciones para conjuntos que lo comunique en la base de datos de
Maxima. Véase `bug_report'.

39.1.4 Autores
--------------

Stavros Macrakis de Cambridge, Massachusetts y Barton Willis de la
University of Nebraska at Kearney (UNK).


File: maxima.info,  Node: Definiciones para los conjuntos,  Prev: Introducción a los conjuntos,  Up: Conjuntos

39.2 Definiciones para los conjuntos
====================================

 -- Función: adjoin (<x>, <a>)
     Incorpora <x> al conjunto <a> y devuelve el nuevo conjunto. Así,
     `adjoin(<x>, <a>)' y `union(set(x),a)' son equivalentes; sin
     embargo, haciendo `adjoin' puede ser algo más rápido que
     utilizando `union'. Si <a> no es un conjunto, se emite un error.

          (%i1) adjoin (c, set (a, b));
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, set (a, b));
          (%o2)                        {a, b}

     Véase también `disjoin'.

 -- Función: belln (<n>)
     Para el entero no negativo integers <n>, devuelve el n-ésimo
     número de Bell. Si `s' es un conjunto con `n' elementos,
     `belln(n)' es el número de particiones de `s'. Por ejemplo:

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions (set ())) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions (set (1, 2, 3, 4, 5, 6))) = belln (6));
          (%o3)                         true

     Si <n> no es un entero no negativo, la función `belln(n)' no hace
     cálculo alguno.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

 -- Función: cardinality (<a>)
     Devuelve el número de elementos del conjunto <a>.

          (%i1) cardinality (set ());
          (%o1)                           0
          (%i2) cardinality (set (a, a, b, c));
          (%o2)                           3
          (%i3) cardinality (set (a, a, b, c)), simp: false;
          (%o3)                           3

     En la salida (%o3) se observa que la cardinalidad trabaja
     correctamente incluso cuando la simplificación se ha desactivado.

 -- Función: cartesian_product (<b_1>, ... , <b_n>)
     Devuelve un conjunto formado por listas de la forma `[<x_1>, ...,
     <x_n>]', donde `<x_1> in <b_1>', ..., `<x_n> in <b_n>'. Envía un
     error si cualquiera de los <b_k> no es un conjunto.

          (%i1) cartesian_product (set (0, 1));
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product (set (0, 1), set (0, 1));
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product (set (x), set (y), set (z));
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product (set (x), set (-1, 0, 1));
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Función: disjoin (<x>, <a>)
     Elimina <x> del conjunto <a> y devuelve un conjunto. Si <x> no es
     elemento de <a>, devuelve <a>. Cada una de las siguientes llamadas
     hace lo mismo: `disjoin(<x>, <a>)', `delete(<x>, <a>)' y
     `setdifference(<a>,set(<x>))'; sin embargo, `disjoin' es
     generalmente el método más rápido para eliminar un elemento de un
     conjunto. Devuelve un error en caso de que <a> no sea un conjunto.

 -- Función: disjointp (<a>, <b>)
     Devuelve `true' si los conjuntos <a> y <b> son disjuntos. Envía un
     mensaje de error si bien <a> o bien <b> no son conjuntos.

 -- Función: divisors (<n>)
     Si <n> es un entero no nulo, devuelve el conjunto de sus
     divisores.  El conjunto de divisores incluye los elementos  1 y
     <n>. Los divisores de un entero negativo son los divisores de su
     valor absoluto.

     Se puede comprobar que 28 es un número perfecto.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     La función `divisors' opera por simplificación; no es necesario
     volver a evaluar tras una sustitución. Por ejemplo:

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     La función `divisors' se distribuye respecto de igualdades,
     listas, matrices y conjuntos.  He aquí un ejemplo de distribución
     sobre una lista y una igualdad.

          (%i1) divisors ([a, b, c=d]);
          (%o1) [divisors(a), divisors(b), divisors(c) = divisors(d)]

 -- Función: elementp (<x>, <a>)
     Devuelve `true' si y sólo si <x> es un elemento del conjunto <a>.
     Envía un error si <a> no es un conjunto.

 -- Función: emptyp (<a>)
     Devuelve `true' si y sólo si <a> es el conjunto vacío o la lista
     vacía.

          (%i1) map (emptyp, [set (), []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, set (set ()), %pi]);
          (%o2)                 [false, false, false]

 -- Función: equiv_classes (<s>, <f>)
     Devuelve el conjunto de las clases de equivalencia de  <s>
     respecto de la relación de equivalencia <f>. La función <f> debe
     ser booleana y definida sobre el producto cartesiano de <s> por
     <s>. Además, la función <f> debe ser una relación de equivalencia,
     debiéndose tener en cuenta que `equiv_classes' no chequea esta
     propiedad.

          (%i1) equiv_classes (set (a, b, c), lambda ([x, y], is (x=y)));
          (%o1)                    {{a}, {b}, {c}}

     En este momento, `equiv_classes (<s>, <f>)' aplica automáticamente
     la función `is' de Maxima después de aplicar la función <f>; por
     lo tanto, se puede volver a hacer el ejemplo anterior de forma más
     breve.

          (%i1) equiv_classes (set (a, b, c), "=");
          (%o1)                    {{a}, {b}, {c}}

     Aquí otro ejemplo.

          (%i1) equiv_classes (set (1, 2, 3, 4, 5, 6, 7), lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Función: every (<f>, <a>)
 -- Función: every (<f>, <L_1>, ..., <L_n>)
     El primer argumento <f> debe ser un predicado (es decir, una
     función que toma cualquiera de los valores `true', `false', or
     `unknown').

     Dado un conjunto como segundo argumento, `every (<f>, <a>)'
     devuelve `true' si `<f>(<a_i>)' devuelve también `true' para todo
     <a_i> de <a>. Puesto que los conjuntos no están ordenados, `every'
     puede evaluar `<f>(<a_i>)' en cualquier orden. La función `every'
     puede que no evalúe <f> para todo <a_i> de <a>. Devido a que el
     orden de evaluación no está especificado, el predicado <f> no debe
     tener efectos secundarios ni emitir señales de error para ninguna
     entrada.

     Dada una o más listas como argumentos, `every (<f>, <L_1>, ...,
     <L_n>)' devuelve `true' si `<f>(<x_1>, ..., <x_n>)' devuelve
     `true' para cada <x_1>, ..., <x_n> de <L_1>, ..., <L_n>,
     respectivamente. La función `every' puede que no evalúe <f> para
     todas las combinaciones <x_1>, ..., <x_n>. Puesto que las listas
     están ordenadas, `every' evalúa en el orden del índice creciente.

     Para usar `every' con múltiples conjuntos como argumentos,
     deberían convertirse primero en una secuencia ordenada, de manera
     que su alineación relativa quede bien definida.

     Si la variable global `maperror' vale `true' (su valor por
     defecto), todas las listas <L_1>, ..., <L_n> deben tener igual
     número de miembros; en otro caso, `every' envia un mensaje de
     error. Cuando `maperror' vale `false', las listas son truncadas
     cada una a la longitud de la lista más corta.

     La función  `is' se aplica automáticamente tras cada evaluación
     del predicado <f>.

          (%i1) every ("=", [a, b], [a, b]);
          (%o1)                         true
          (%i2) every ("#", [a, b], [a, b]);
          (%o2)                         false

 -- Función: extremal_subset (<s>, <f>, max)
 -- Función: extremal_subset (<s>, <f>, min)
     Cuando el tercer argumento es `max', devuelve el subconjunto del
     conjunto o lista <s> para cuyos elementos la función real  <f>
     toma su valor mayor; cuando el tercer argumento es `min', devuelve
     el subconjunto para el cual <f> toma su valor menor.

          (%i1) extremal_subset (set (-2, -1, 0, 1, 2), abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset (set (sqrt(2), 1.57, %pi/2), sin, min);
          (%o2)                       {sqrt(2)}

 -- Función: flatten (<e>)
     La función `flatten' evalúa una expresión como si su operador
     principal hubiese sido declarado n-ario; hay sin embargo una
     diferencia, `flatten' no es recursiva para otros argumentos de la
     función. Por ejemplo:

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     Aplicada a un conjunto, `flatten' reune todos los elementos de los
     conjuntos que son a su vez elementos; por ejemplo:

          (%i1) flatten (set (a, set (b), set (set (c))));
          (%o1)                       {a, b, c}
          (%i2) flatten (set (a, set ([a], set (a))));
          (%o2)                       {a, [a]}

     La función `flatten' trabaja correctamente cuando el operador
     principal es una función con subíndices

          (%i1) flatten (f[5] (f[5] (x)));
          (%o1)                         f (x)
                                         5

     Para alisar (flatten) una expresión, el operador principal debe
     estar definido para cero o más argumentos; si no es éste el caso,
     Maxima se detendrá con un error. Expresiones con representaciones
     especiales, como expresiones CRE, no pueden ser alisadas; en este
     caso, `flatten' devuelve su argumento sin cambios.

 -- Función: full_listify (<a>)
     Si <a> es un conjunto, convierte <a> en una lista y aplica
     `full_listify' a cada miembro de la lista.

     Para convertir sólo el operador de mayor nivel de un conjunto a
     una lista, véase `listify'.

 -- Función: fullsetify (<a>)
     Si <a> es una lista, convierte <a> en un conjunto y aplica
     `fullsetify' a cada elemento del conjunto.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

     En la salida (%o2) el argumento de `f' no se convierte en conjunto
     porque el operador principal de `f([b])' no es una lista.

     Para convertir el operador de mayor nivel de una lista a un
     conjunto véase `setify'.

 -- Función: identity (<x>)
     La función `identity' devuelve su argumento cualquiera que sea
     éste.  Para determinar si todos los elementos de un conjunto son
     `true', se puede hacer lo siguiente

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Función: integer_partitions (<n>)
 -- Función: integer_partitions (<n>, <len>)
     Si el segundo argumento opcional <len> no se especifica, devuelve
     el conjunto de todas las particiones del entero <n>. Cuando se
     especifica <len>, devuelve todas las particiones de longitud
     <len> o menor; en este caso, se añaden ceros a cada partición con
     menos de  <len> términos, a fin de que cada partición tenga
     exactamente los  <len> términos. En cualquier caso las particiones
     son listas ordenadas de mayor a menor.

     Se dice que la lista [a_1, ..., a_m] es una partición del entero
     no negativo n si (1) cada a_i es un entero no nulo y (2) a_1 + ...
     + a_m  = n.  De donde se deduce que 0 carece de particiones.

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Para encontrar todas las particiones que satisfagan cierta
     condición, utilícese la función `subset'; he aquí un ejemplo que
     encuentra todas las particiones de 10 formadas por números primos.

          (%i1) s: integer_partitions (10)$
          (%i2) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i3) subset (s, lambda ([x], every (xprimep, x)));
          (%o3) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}


 -- Función: intersect (<a_1>, ..., <a_n>)
     Es una forma abreviada de la función `intersection'.

 -- Función: intersection (<a_1>, ..., <a_n>)
     Devuelve el conjunto de todos los elementos que son comunes a los
     conjuntos  <a_1> a <a_n>. La función  `intersect' debe recibir uno
     o más argumentos. Muestra un mensaje de error en caso de que
     cualquiera de los <a_i> no sea un conjunto.  Véase también
     `intersection'.

 -- Función: kron_delta (<x>, <y>)
     Es la función delta de Kronecker; la llamada  `kron_delta (<x>,
     <y>)' devuelve la unidad cuando `is(x = y)' es verdadero y cero
     cuando `sign (|<x> - <y>|)' vale `pos' (es decir, cuando es
     positivo).  Si `sign (|<x> - <y>|)' es nulo y `<x> - <y>' no es un
     número en coma flotante (ni de doble precisión ni del tipo
     `bfloat'), devuleve 0. En otro caso devuelve una forma nominal.

     La función `kron_delta' es simétrica; así por ejemplo,
     `kron_delta(x, y) - kron_delta(y, x)' devuelve cero.

     A continuación algunos ejemplos.

          (%i1) [kron_delta (a, a), kron_delta (a + 1, a)];
          (%o1)                        [1, 0]
          (%i2) kron_delta (a, b);
          (%o2)                   kron_delta(a, b)

     Bajo la hipótesis `a > b' se obtiene que  `sign (|a - b|)' sea
     `pos' (positivo),

          (%i1) assume (a > b)$
          (%i2) kron_delta (a, b);
          (%o2)                           0

     Si se da por válida la hipótesis `x >= y', entonces `sign (|x -
     y|)' se vuelve `pz' (es decir, cero o positivo); en este caso,
     `kron_delta (x, y)' no devuelve resultado alguno,

          (%i1) assume(x >= y)$
          (%i2) kron_delta (x, y);
          (%o2)                   kron_delta(x, y)

     Por último, puesto que `1/10 - 0.1' devuelve un número en coma
     flotante, se tiene

          (%i1) kron_delta (1/10, 0.1);
                                            1
          (%o1)                  kron_delta(--, 0.1)
                                            10

     Si se quiere que `kron_delta (1/10, 0.1)' devuelva la unidad,
     hágase uso de `float'.

          (%i1) float (kron_delta (1/10, 0.1));
          (%o1)                           1

 -- Función: listify (<a>)
     Si <a> es un conjunto, devuelve una lista con los elementos de
     <a>; si  <a> no es un conjunto, devuelve <a>.  Para convertir un
     conjunto y todos sus elementos a listas, véase  `full_listify'.


 -- Función: lreduce (<f>, <s>)
 -- Función: lreduce (<f>, <s>, <init>)
     La función  `lreduce' (left reduce, o reducir por la izquierda)
     convierte una función binaria en  n-aria por composición; un
     ejemplo hará esto más claro. Cuando no se define el argumento
     opcional <init> se tiene

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     Nótese que la función <f> se aplica en primer lugar a los
     elementos que están más a la izquierda (de ahí el nombre
     `lreduce').  Cuando se define <init>, se tiene

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     La función `lreduce' facilita calcular el producto o suma de los
     miembros de una lista.

          (%i1) lreduce ("+", args (set (a, b)));
          (%o1)                         b + a
          (%i2) lreduce ("*", args (set (1, 2, 3, 4, 5)));
          (%o2)                          120

     Véase también `rreduce', `xreduce' y `tree_reduce'.

 -- Función: makeset (<e>, <v>, <s>)
     Esta función es similar a  `makelist', con la salvedad de que
     `makeset' permite sustituciones múltiples. El primer argumento
     <e> es una expresión, el segundo argumento <v> es una lista de
     variables y  <s> es una lista o conjunto de valores para las
     variables  <v>. Cada miembro de  <s> debe tener la misma longitud
     que  <v>. Así se tiene que  `makeset (<e>, <v>, <s>)' es el
     conjunto `{z | z = substitute(v -> s_i) and s_i in s}'.

          (%i1) makeset (i/j, [i, j], [[a, b], [c, d]]);
                                        a  c
          (%o1)                        {-, -}
                                        b  d
          (%i2) ind: set (0, 1, 2, 3)$
          (%i3) makeset (i^2 + j^2 + k^2, [i, j, k], cartesian_product (ind, ind, ind));
          (%o3) {0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 17, 18,
                                                                19, 22, 27}

 -- Función: moebius (<n>)
     Es la función de Moebius; si <n> es el producto de k primos
     diferentes, `moebius(<n>)' devuelve (-1)^k, retornando 1 si <n> =
     1 0 para cualesquiera otros enteros positivos. La función de
     Moebius se distribuye respecto de igualdades, listas, matrices y
     conjuntos.

 -- Función: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Función: multinomial_coeff ()
     Devuelve el coeficiente multinomial. Si todos los <a_k> son
     enteros no negativos, el coeficiente multinomial es el número de
     formas de colocar  `<a_1> + ... + <a_n>' objetos diferentes en  n
     cajas con <a_k> elementos en la k-ésima caja. En general,
     `multinomial (<a_1>, ..., <a_n>)' calcula  `(<a_1> + ... +
     <a_n>)!/(<a_1>! ... <a_n>!)'. Si no se dan argumentos,
     `multinomial()' devuelve 1. Se puede usar `minfactorial' para
     simplificar el valor devuelto por `multinomial_coeff'; por ejemplo,

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Función: num_distinct_partitions (<n>)
 -- Función: num_distinct_partitions (<n>, <a>)
     Si <n> es un entero no negativo, devuelve el número de particiones
     enteras diferentes de <n>.

     Si el argumento opcional  <a> es `list', devuelve a su vez una
     lista del número de particiones de  1,2,3, ... , n. Si <n> no es
     un entero no negativo, devuelve una forma nominal.

     Definición: si <n> = k_1 + ... + k_m, siendo los k_1 a  k_m
     enteros positivos distintos, se llama a k_1 + ... + k_m una
     partición de <n>.

 -- Función: num_partitions (<n>)
 -- Función: num_partitions (<n>, <a>)
     Si <n> es un entero no negativo, devuelve el número de particiones
     de <n>. Si el argumento opcional  <a> es `list', devuelve a su vez
     otra lista con los números de particiones de  1,2,3, ... , n.  Si
     <n> no es un entero no negativo, devuelve una forma nominal.

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

     Para un entero no negativo <n>, `num_partitions (<n>)' equivale a
     `cardinality (integer_partitions (<n>))'; sin embargo,
     `num_partitions'  es más rápido.

 -- Función: partition_set (<a>, <f>)
     Devuelve una lista con dos conjuntos; el primer conjunto es el
     subconjunto de <a> para el cual el predicado  <f> devuelve `false'
     y el segundo es el subconjunto de <a> para el cual <f> devuelve
     `true'. Si  <a> no es un conjunto, se envía un mensaje de error.
     Véase también `subset'.

          (%i1) partition_set (set (2, 7, 1, 8, 2, 8), evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set (set (x, rat(y), rat(y) + z, 1), lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Función: permutations (<a>)
     Devuelve un conjunto con todas las permutaciones distintas de los
     miembros de la lista o conjunto  <a>. (Cada permutación es una
     lista, no un conjunto.)  Si <a> es una lista, sus miembros
     duplicados no son eliminados antes de buscar sus permutaciones.
     Así,

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

     Si <a> no es una lista o conjunto, se muestra un mensaje de error.

 -- Función: powerset (<a>)
 -- Función: powerset (<a>, <n>)
     Si no se define el segundo argumento opcional <n>, devuelve el
     conjunto de todos los subconjuntos del conjunto <a>.  La llamada
     `powerset(<a>)' tiene `2^cardinality(<a>)' miembros. Dado un
     segundo argumento, `powerset(<a>,<n>)' devuelve el conjunto de
     todos los subconjuntos de  <a> que tienen cardinalidad <n>.
     Muestra un error si <a> no es un conjunto; muestra otro error si
     <n> no es un positivo entero.

 -- Función: rreduce (<f>, <s>)
 -- Función: rreduce (<f>, <s>, <init>)
     La función  `rreduce' (right reduce, reducir por la derecha)
     extiende una función binaria a n-aria por composición; un ejemplo
     hará esto m'as claro. Si el argumento opcional <init> no está
     definido, se tiene

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     Nótese que la función <f> se aplica en primer lugar al elemento
     que está más a la derecha en la lista, de ahí el nombre `rreduce'.
     Si <init> está definido,

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     La función `rreduce' permite calcular fácilmente el producto o
     suma de los miembros de una lista.

          (%i1) rreduce ("+", args (set (a, b)));
          (%o1)                         b + a
          (%i2) rreduce ("*", args (set (1, 2, 3, 4, 5)));
          (%o2)                          120

     Véase también `lreduce', `tree_reduce' y `xreduce'.

 -- Función: setdifference (<a>, <b>)
     Devuelve in conjunto con los elementos del conjunto <a> que no
     pertenecen al conjunto <b>. Envía un mensaje de error si  <a> o
     <b> no son conjuntos.


 -- Función: setequalp (<a>, <b>)
     Devuelve  `true' si los conjuntos <a> y <b> tienen el mismo número
     de elementos y `is (<x> = <y>)' vale `true' para `x' perteneciente
     a <a> e `y' perteneciente a <b>, considerados en el orden que
     determina la función `listify'. En caso contrario, `setequalp'
     devuelve `false'.

     La función `setequalp' muestra un mensaje de error si cualquiera de
     las expresiones <a> o <b> no es conjunto.


 -- Función: setify (<a>)
     Construye un conjunto con los miembros de la lista <a>.  Los
     elementos duplicados de la lista <a> son borrados y lordenados de
     acuerdo con el predicado `orderlessp'.  Envía un mensaje de error
     si `a' no es una lista.

 -- Función: setp (<a>)
     Devuelve `true' si y sólo si <a> es un conjunto de Maxima. La
     función `setp' chequea si el operador de su argumento es el de los
     conjuntos; no chequea si el argumento es un conjunto simplificado.
     Así,

          (%i1) setp (set (a, a)), simp: false;
          (%o1)                         true

     La función `setp' podría haberse programado en Maxima como
     `setp(a) := is (inpart (a, 0) = set)'.


 -- Función: set_partitions (<a>)
 -- Función: set_partitions (<a>, <n>)
     Si est'a definido el argumento opcional <n>, devuelve el conjunto
     de todas las descomposiciones de <a> en <n> subconjuntos disjuntos
     no vacíos. Si <n> no está definido, devuelve el conjunto de todas
     las particiones.

     Se dice que un conjunto P es una partición del conjunto S si
     verifica

       1. cada elemento de P es un conjunto no vacío,

       2. los elementos de P son disjuntos,

       3. la unión de elementos de P es igual a  S.

     El conjunto vacío forma una partición de sí mismo, así,

          (%i1) set_partitions (set ());
          (%o1)                         {{}}

     El cardinal del conjunto de particiones de un conjunto puede
     calcularse con `stirling2'; así

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                        90 = 90
          (%i4) cardinality(p) = stirling2 (6, 3);

     Cada elemento de `p' debería tener 3 miembros:

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                          {3}
          (%i4) map (cardinality, p);

     Por último, para cada elemento de `p', la unión de sus miembros
     debe ser igual a `s':

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                 {{0, 1, 2, 3, 4, 5}}
          (%i4) map (lambda ([x], apply (union, listify (x))), p);

 -- Función: some (<f>, <a>)
 -- Función: some (<f>, <L_1>, ..., <L_n>)
     El primer argumento de <f> debe ser un predicado (esto es, una
     función que devuelve `true', `false', or `unknown').

     Si el segundo argumento es un conjunto, `some (<f>, <a>)' devuelve
     `true' si `<f>(<a_i>)' devuelve también `true' para alguno de los
     <a_i> en <a>.  Puesto que los conjuntos no están ordenados, `some'
     puede evaluar  `<f>(<a_i>)' en cualquier orden. La función `some'
     puede que no evalúe <f> para todos los <a_i> de <a>. Devido a que
     el orden de evaluación no está especificado, el predicado <f> no
     debería tener efectos secundarios ni mostrar mensajes de error.

     Dada una o más listas como argumentos, `some (<f>, <L_1>, ...,
     <L_n>)' devuelve `true' si `<f>(<x_1>, ..., <x_n>)' devuelve
     también `true' para al menos un  <x_1>, ..., <x_n> de <L_1>, ...,
     <L_n>, respectivamente. La función `some' puede que no evalúe <f>
     para todas las combinaciones <x_1>, ..., <x_n>.

     Si la variable global `maperror' vale `true' (su valor por
     defecto), todas las listas <L_1>, ..., <L_n> deben tener igual
     número de elementos, en caso contrario, `some' muestra un error.
     Si `maperror' vale `false', los argumentos se truncan para tener
     todos el número de elementos de la lista más corta.

     La función `is' de Maxima se aplica automáticamente tras la
     evaluación del predicado <f>.

          (%i1) some ("<", [a, b, 5], [1, 2, 8]);
          (%o1)                         true
          (%i2) some ("=", [2, 3], [2, 7]);
          (%o2)                         true

 -- Función: stirling1 (<n>, <m>)
     Es el número de Stirling de primera especie. Si tanto <n> como <m>
     son enteros no negativos, el valor que toma `stirling1 (<n>, <m>)'
     es el número de permutaciones de un conjunto de  <n> elementos con
     <m> ciclos.  Para más detalles, véase Graham, Knuth and Patashnik
     Concrete Mathematics. Se utiliza una relación recursiva para
     definir `stirling1 (<n>, <m>)' para <m> menor que 0; no está
     definida para <n> menor que 0 ni para argumentos no enteros.

     La función `stirling1' opera por simplificación, utilizando
     valores básicos especiales (véase Donald Knuth, The Art of
     Computer Programming, tercera edición, Volumen 1,  Sección 1.2.6,
     ecuaciones 48, 49 y 50).  Para que Maxima aplique estas reglas,
     los argumentos deben declararse como enteros y el primer argumento
     debe ser no negativo. Por ejemplo:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     La función `stirling1' no se evalúa para argumentos no enteros.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima conoce algunos valores especiales,

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Función: stirling2 (<n>, <m>)
     Es el número de Stirling de segunda especia. Si <n> y <m> son
     enteros no negativos,  `stirling2 (<n>, <m>)' es el número de
     formas en las que se puede particionar un conjunto de cardinal <n>
     en <m> subconjuntos disjuntos. Se utiliza una relación recursiva
     para definir  `stirling2 (<n>, <m>)' con <m> menor que 0; la
     función no está definida para  <n> menor que 0  ni para argumentos
     no enteros.

     La función `stirling1' opera por simplificación, utilizando
     valores básicos especiales (véase Donald Knuth, The Art of
     Computer Programming, tercera edición, Volumen 1,  Sección 1.2.6,
     ecuaciones 48, 49 y 50).  Para que Maxima aplique estas reglas,
     los argumentos deben declararse como enteros y el primer argumento
     debe ser no negativo. Por ejemplo:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     La función `stirling2' no se evalúa para argumentos no enteros.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima conoce algunos valores especiales,

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Función: subset (<a>, <f>)
     Devuelve el subconjunto del conjunto <a> que satisface el
     predicado <f>.  Por ejemplo:

          (%i1) subset (set (1, 2, x, x + y, z, x + y + z), atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset (set (1, 2, 7, 8, 9, 14), evenp);
          (%o2)                      {2, 8, 14}

     El segundo argumento de `subset' debe ser un predicado (una
     función booleana con un argumento); si el primer argumento de
     `subset' no es un conjunto, envía un mensaje de error. Véase
     también `partition_set'.

 -- Función: subsetp (<a>, <b>)
     Devuelve `true' si y sólo si el conjunto <a> es un subconjunto de
     <b>. Muestra un mensaje de error si  <a> o <b> no son conjuntos.

 -- Función: symmdifference (<a_1>, ..., <a_n>)
     Devuelve el conjunto de elementos que pertenecen a un único
     conjunto de los  <a_k>. Muestra un mensaje de error si cualquiera
     de los argumentos <a_k> no es un conjunto. Con dos argumentos,
     `symmdifference (<a>, <b>)' equivale a `union (setdifference (<a>,
     <b>), setdifference (<b>, <a>))'.

 -- Función: tree_reduce (<f>, <s>)
 -- Función: tree_reduce (<f>, <s>, <init>)
     La función `tree_reduce' amplía un operador binario asociativo f :
     S x S -> S a otro de cualquier número de argumentos utilizando un
     árbol de mínima profundidad. Un ejemplo aclarará esto,

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     Dado un número impar de argumentos, `tree_reduce' favorecerá la
     parte izquierda del árbol; por ejemplo,

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

     Para la suma de números en coma flotante, la utilización de
     `tree_reduce' puede redundar en una disminución del error de
     redondeo frente a funciones como `rreduce' o `lreduce'.

 -- Function: union (<a_1>, ..., <a_n>)
     Return the union of the sets <a_1> through <a_n>.  When `union'
     receives no arguments, it returns the empty set. Signal an error
     when one or more arguments to `union' is not a set.

 -- Función: xreduce (<f>, <s>)
 -- Función: xreduce (<f>, <s>, <init>)
     Esta función es similar a  `lreduce' y a `rreduce', excepto que
     `xreduce' puede utilizar tanto la asociatividad por la izquierda
     como por la derecha; en particular, si <f> es una función
     asociativa y Maxima la tiene implementada, `xreduce' puede
     utilizar la función n-aria, como la suma `+', la multiplicación
     `*', `and', `or', `max', `min' y `append'. Para estos operadores,
     se espera que en general que `xreduce' sea mas rápida que
     `rreduce' o `lreduce'.  Si <f> no es n-aria, `xreduce' utiliza la
     asociatividad por la izquierda.

     La suma de números en coma flotante no es asociativa; sin embargo,
     `xreduce' utiliza la suma n-aria de Maxima cuando el conjunto o
     lista <s> contiene números en coma flotante.



File: maxima.info,  Node: Definición de Funciones,  Next: Programación,  Prev: Conjuntos,  Up: Top

40 Definición de Funciones
**************************

* Menu:

* Introducción a la definición de funciones::
* Funciones::
* Macros::
* Definiciones para la definición de funciones::


File: maxima.info,  Node: Introducción a la definición de funciones,  Next: Funciones,  Prev: Definición de Funciones,  Up: Definición de Funciones

40.1 Introducción a la definición de funciones
==============================================


File: maxima.info,  Node: Funciones,  Next: Macros,  Prev: Introducción a la definición de funciones,  Up: Definición de Funciones

40.2 Funciones
==============

Para definir una función en Maxima es necesario utilizar el operador
':='.

   Por ejemplo,

     f(x) := sin(x)
   define una función `f'. También se pueden definir funciones anónimas
utilizando `lambda'; por ejemplo,

     lambda ([i, j], ...)

puede utilizarse en lugar de `f' donde

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

devolvería una lista con todos sus elementos aumentados en una unidad.

   También se puede definir una función con un número variable de
argumentos, sin más que añadir un argumento final al que se le asigna
una lista con todos los argumentos adicionales.:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   El miembro derecho de una función debe ser una expresión. Así, si se
quiere una secuencia de expresiones, se debe hacer

     f(x) := (expr1, expr2, ...., exprn);

   siendo el valor que alcance exprn el devuelto por la función.

   Si se quiere hacer un `return' desde alguna de las expresiones de la
función, se debe utilizar la estructura  `block' junto con `return'.
Por ejemplo,

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   es una expresión de pleno derecho, por lo que puede ocupar el lado
derecho de la definición de una función. Aquí puede ocurrir que el
retorno se produzca antes que se alcance la última expresión.

   Los primeros corchetes del bloque (`[]') pueden contener una lista
de variables junto con posibles asignaciones, tal como `[a: 3, b, c:
[]]', lo que provocará que las tres variables `a',`b' y `c' se
consideren locales y sean independientes de otras globales con el mismo
nombre; las variables locales sólo estarán activas mientras se ejecute
el código que está dentro de la estructura `block', o dentro de
funciones que son llamadas desde dentro de `block'. A esto se le llama
asignación dinámica, pues las variables sobreviven desde el inicio del
bloque hasta que éste deje de estar operativo. Una vez se salga del
bloque los valores originales de las variables, si es que los había,
quedan restaurados. Es recomendable proteger las variables de esta
forma. Se tendrá en cuenta que las asignaciones a las variables del
bloque se hacen en paralelo, lo que significa que si como en el ejemplo
anterior se hace `c: a' en el momento de entrar en el bloque, el valor
de `c' será el que tenía `a' antes de entrar en el bloque, es decir,
antes de la asignación `a: 3'. Así, haciendo lo siguiente

     block ([a: a], expr1, ... a: a+3, ..., exprn)

   se prevendría de que el valor externo de `a' fuese alterado, pero
permitiría acceder a él desde dentro del bloque. La parte derecha de
las asignaciones se evalúa dentro de su contexto antes de hacer
efectiva la asignación. Utilizando únicamente `block([x],..' haría que
`x' se tuviese a sí misma como valor, justo como si se acabase de
iniciar una nueva sesión de Maxima.

   Los valores de los argumentos de una funcón se tratan exactamente de
la misma forma que las variables de un bloque. Así, con

     f(x) := (expr1, ..., exprn);

   y

     f(1);

   se estaría en un contexto similar para la evaluación de las
expresiones como si se hubiera hecho

     block ([x: 1], expr1, ..., exprn)

   Dentro de las funciones, cuando el lado derecho de la definición
deba ser evaluado será útil hacer uso de `define' y posiblemente de
`buildq'.


File: maxima.info,  Node: Macros,  Next: Definiciones para la definición de funciones,  Prev: Funciones,  Up: Definición de Funciones

40.3 Macros
===========

 -- Función: buildq (<L>, <expr>)
     Sustituye en paralelo las variables nombradas en la lista <L> en
     la expresión <expr>, sin evaluar ésta.  La expresión resultante se
     simplifica pero no se evalúa hasta que `buildq' termine de hacer
     las sustituciones.

     Los elementos de <L> son símbolos o expresiones de asignación del
     tipo `<symbol>: <value>', evaluadas en paralelo. Esto es, el valor
     de una variable en la parte derecha de una asignación es el valor
     que toma dicha variable en el contexto desde el que se invoca a
     `buildq'. En caso de que a una variable de <L> no se le haga una
     signación explícita, su valor en `buildq' es el mismo que tiene en
     el contexto desde el que se llama a `buildq'.

     Las variables referenciadas en <L> se sustituyen en <expr> en
     paralelo. Esto es, la sustitución para cada variable se determina
     antes de que se hagan las sustituciones, de forma que la
     sustitución de una variable no tiene efecto alguno sobre las otras.

     Si alguna variable <x> aparece como `splice (<x>)' en <expr>,
     entonces a <x> se le debe asignar una lista, la cual será
     interpolada en <expr> en lugar de hacer una simple sustitución;
     ver ejemplo más abajo.

     Cualesquiera otras variables de <expr> que no aparezcan en <L> se
     traspasan al resultado tal cual, incluso cuando tienen asignados
     valores en el contexto desde el que se llama a `buildq'.

     Ejemplos:

     `a' queda asociada explícitamente a `x', mientras que `b' tiene la
     misma asociación (29) que en el contexto de llamada y `c' es
     traspasado al resultado sin ser sustituido. La expresión
     resultante no se evalúa hasta que no se le obligue a ello mediante
     la evaluación explícita `''%'.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     En este ejemplo, `e' se asocia a una lista, la cual aparece como
     tal en los argumentos de `foo' e interpolada en los argumentos de
     `bar'.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     Como se ve a continuación, el resultado se simplifica tras las
     sustituciones. Si la simplificación se realizase antes que las
     sustituciones, ambos resultados serían iguales.

          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     Las variables de <L> se asocian en paralelo; si se hiciese
     secuencialmente, el primer resultado sería `foo (b, b)'. Las
     sustituciones se llevan a cabo en paralelo. Compárese el segundo
     resultado con el resultado de `subst', que hace las sustituciones
     de forma secuencial.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Se construye a continuación un sistema de ecuaciones con algunas
     variables o expresiones en el lado izquierdo y sus valores en el
     derecho; `macroexpand' muestra la expresión devuelta por
     `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)              [a = 17, b = 29, c = 1729]


 -- Función: macroexpand (<expr>)
     Devuelve la macroexpansión de <expr>, sin evaluarla, cuando `expr'
     es una llamada a una función macro; en caso contrario,
     `macroexpand' devuelve <expr>.

     Si la expansión de <expr> devuelve otra llamada a una función
     macro, esta llamada también se expande.

     La función `macroexpand' no evalúa su argumento.  Sin embargo, si
     la expansión de una llamada a función macro tiene efectos
     laterales, éstos se ejecutan.

     Véanse también `::=', `macros' y `macroexpand1'.

     Ejemplos:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Función: macroexpand1 (<expr>)
     Devuelve la macroexpansión de <expr>, sin evaluarla, cuando `expr'
     es una llamada a una función macro; en caso contrario,
     `macroexpand1' devuelve <expr>.

     La función `macroexpand1' no evalúa su argumento.  Sin embargo, si
     la expansión de una llamada a función macro tiene efectos
     laterales, éstos se ejecutan.

     Si la expansión de <expr> devuelve otra llamada a una función
     macro, esta llamada no se expande.

     Véanse también `::=', `macros' y `macroexpand'.

     Ejemplos:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Variable global: macros
     Valor por defecto: `[]'

     La variable `macros' es la lista de las funciones macro definidas
     por el usuario.  El operador de definición de funciones macro
     `::=' coloca la nueva función macro en esta lista, mientras que
     `kill', `remove' y `remfunction' eliminan las funciones macro de
     la lista.

     Véase también `infolists'.


 -- Función: splice (<a>)
     Interpola la lista nombrada por el átomo  <a> dentro de una
     expresión, pero sólo si `splice' aparece dentro de `buildq'; en
     otro caso, `splice' se considera una función no definida. Si <a>
     aparece dentro de `buildq' sin `splice', entonces queda sustituida
     por una lista dentro del resultado. El argumento de `splice' debe
     ser un átomo, no pudiendo ser una lista literal ni una expresión
     que devuelva una lista.

     Normalmente `splice' suministra los argumentos para una función u
     operador. Para una función `f', la expresión `f (splice (<a>))'
     dentro de `buildq' se convierte en `f (<a>[1], <a>[2], <a>[3],
     ...)'. Dado un operador `o', la expresión `"o" (splice (<a>)'
     dentro de `buildq' se convierte en `"o" (<a>[1], <a>[2], <a>[3],
     ...)', donde `o' puede ser cualquier tipo de operador, normalmente
     uno que admita varios argumentos. Nótese que el operador debe ir
     encerrado entre dobles comillas `"'.

     Ejemplos:

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>



File: maxima.info,  Node: Definiciones para la definición de funciones,  Prev: Macros,  Up: Definición de Funciones

40.4 Definiciones para la definición de funciones
=================================================

 -- Función: apply (<f>, [<x_1>, ..., <x_n>])
     Devuelve el resultado de aplicar la función <f> a la lista de
     argumentos  <x_1>, ..., <x_n>. El símbolo  <f> debe ser el nombre
     de una función o de una expresión lambda.

     Es útil en aquellos casos en los que se desea calcular los
     argumentos de una función antes de aplicárselos a ésta. Por
     ejemplo, si `l' es la lista `[1, 5, -10.2, 4, 3]', entonces `apply
     (min, l)' devuelve -10.2. La función `apply' es útil también
     cuando se llama a funciones que aún no tienen sus argumentos
     evaluados y se requiere que sí lo estén. Por ejemplo, si
     `filespec' es una variable cuyo valor es la lista `[test, case]'
     entonces `apply (closefile, filespec)'  es equivalente a
     `closefile (test, case)'. En general, el primer argumento de
     `apply' debería ir precedido de un apóstrofo (`'') para que se
     evalúe a sí mismo. Puesto que algunas variables atómicas tienen el
     mismo nombre que que ciertas funciones, el valor de la variable
     seería el utilizado antes que el de la función porque  `apply'
     tiene su dos argumentos evaluados.


 -- Función: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Función: block (<expr_1>, ..., <expr_n>)
     La función `block' evalúa <expr_1>, ..., <expr_n> secuencialmente
     y devuelve el valor de la última expresión evaluada. La secuencia
     puede alterarse con las funciones `go', `throw' y `return'. La
     última expresión es <expr_n> a menos que `return' o una expresión
     que contenga un `throw' sea evaluada. Las variables <v_1>, ...,
     <v_m> son locales en el bloque; éstas se distiguen de las globales
     que tengan el mismo nombre. Si no se declaran variables locales
     entonces se puede omitir la lista. Dentro del bloque, cualquier
     otra variable distinta de <v_1>, ..., <v_m> se considera global.

     La función `block' guarda los valores actuales de las variables
     <v_1>, ..., <v_m>, si los tienen, a la entrada del bloque y luego
     las evalúa a sí mismas, es decir les saca el valor temporalmente.
     A las variables locales se les puede asignar cualquier valor
     dentro del bloque, pero al salir de éste, los valores inicialmente
     almacenados quedan restaurados, al tiempo que los asignados dentro
     del bloque se pierden.

     Un `block' puede aparecer dentro de otro `block'. Las variables
     locales se inicializan cada vez que se entra dentro de un nuevo
     bloque. Las variables locales de un bloque se consideran globales
     dentro de otro anidado dentro del primero. Si una variable es no
     local dentro de un bloque, su valor es el que le corresponde en el
     bloque superior. Este criterio se conoce con el nombre de "alcance
     dinámico".

     Si se quieren guardar y restaurar otras propiedades locales además
     del `valor' de las variables, por ejemplo `arreglo' (excepto
     arreglos completos), `function', `dependencies', `atvalue',
     `matchdeclare', `atomgrad', `constant' y `nonscalar' entonces
     debería usarse la función `local' dentro del bloque, siendo sus
     argumentos los nombres de las variables.

     El valor del bloque es el de la última sentencia o el argumento de
     la función `return', que puede utilizarse para salir del bloque.
     La función `go' puede usarse para transferir el control a la
     sentencia del bloque que esté etiquetada con el argumento de `go'.
     Para etiquetar una sentencia basta que vaya precedida de un
     argumento atómico como cualquier otra sentencia dentro del bloque.
     Por ejemplo, `block ([x], x:1, tururu, x: x+1, ..., go(tururu),
     ...)'.  El argumento de `go' debe ser el nombre de una etiqueta
     colocada dentro del bloque. No se puede utilzar `go' para
     trasladarse a una etiqueta de un bloque que no sea el que contenga
     a `go'.

     Normalmente los bloques aparecerán al lado derecho de las
     definiciones de funciones, pero también pueden utilizarse en otros
     contextos.


 -- Función: break (<expr_1>, ..., <expr_n>)
     Calcula e imprime <expr_1>, ..., <expr_n> para luego provocar la
     detención de Maxima, de modo que el usuario pueda examinar y
     cambiar el entorno de ejecución. Pulsando posteriormente `exit;'
     el cálculo se reanuda.


 -- Función: catch (<expr_1>, ..., <expr_n>)
     Evalúa <expr_1>, ..., <expr_n> una a una;  si alguna de ellas
     conlleva la evaluación de una expresión de la forma `throw (arg)',
     entonces el valor de `catch' es el de `throw (arg)' y ya no se
     evalúan más expresiones. Esta respuesta pasa todos los niveles de
     anidamiento hasta el `catch' más próximo. Si no hay ningún `catch'
     que contenga un `throw' se emite un mensaje de error.

     Si la evaluación de los argumentos no conlleva la evaluación de
     ningún `throw', entonces el valor de `catch' es el devuelto por
     <expr_n>.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     La función `g' devuelve las imágenes por `f' de todos los
     elementos de la lista `l' si ésta contiene únicamente números no
     negativos; si no es este el caso, entonces `g' captura el primer
     negativo que encuentra y lo devuelve por medio del `throw'.


 -- Function: compfile (<nombre_fichero>, <f_1>, ..., <f_n>)
     Traduce las funciones de Maxima <f_1>, ..., <f_n> a código Lisp y
     lo guarda en el fichero <nombre_fichero>.

     El código Lisp traducido no se evalúa, ni el fichero de salida es
     procesado por el compilador de Lisp.  `translate' creates and
     evaluates Lisp translations.  `compile_file' translates Maxima
     into Lisp, and then executes the Lisp compiler.

     Véanse también `translate', `translate_file' y `compile_file'.


 -- Función: compile (<f_1>, ..., <f_n>)
 -- Función: compile (functions)
 -- Función: compile (all)
     Traduce las funciones de Maxima <f_1>, ..., <f_n> a Lisp,
     evaluando el código resultante, y llama a la función Lisp
     `COMPILE' para cada función traducida. La función `compile'
     devuelve una lista con los nombres de las funciones compiladas.

     Las llamadas `compile (all)' o `compile (functions)' compilan
     todas las funciones definidas por el usuario.

     La función `compile' no evalúa sus argumentos, pero con la
     colocación de dos comillas simple (`''') sí lo hace.


 -- Función: define (<f>(<x_1>, ..., <x_n>), <expr>)
     Define una función de nombre <f> con argumentos <x_1>, ..., <x_n>
     y cuerpo <expr>.

     `define' no evalúa su primer argumento en la mayor parte de los
     casos y evalúa su segundo argumento, a menos que vaya precedido de
     apóstrofo (`''). Sin embargo, si el primer argumento es una
     expresión de la forma `ev (<expr>)', `funmake (<expr>)'  o
     `arraymake (<expr>)', el primer argumento es evaluado, lo que
     permite calcular el nombre de la función junto con su cuerpo.

     `define' es similar al operador de definición de funciones `:=',
     pero cuando `define' aparece dentro de una función, la definición
     se crea usando el valor de `expr' en el momento de su ejecución,
     en lugar de la que tenía en el momento de la definición de la
     función que la contiene.

     Ejemplos:

          (%i1) foo: 2^bar;
                                         bar
          (%o1)                         2
          (%i2) g(x) := (f_1 (y) :=   foo*x*y,
                         f_2 (y) := ''foo*x*y,
                 define (f_3 (y),     foo*x*y),
                 define (f_4 (y),   ''foo*x*y));
                                                       bar
          (%o2) g(x) := (f_1(y) := foo x y, f_2(y) := 2    x y,
                                                                  bar
                         define(f_3(y), foo x y), define(f_4(y), 2    x y))
          (%i3) functions;
          (%o3)                        [g(x)]
          (%i4) g(a);
                                              bar
          (%o4)                  f_4(y) := a 2    y
          (%i5) functions;
          (%o5)        [g(x), f_1(y), f_2(y), f_3(y), f_4(y)]
          (%i6) dispfun (f_1, f_2, f_3, f_4);
          (%t6)                   f_1(y) := foo x y

                                            bar
          (%t7)                  f_2(y) := 2    x y

                                              bar
          (%t8)                  f_3(y) := a 2    y

                                              bar
          (%t9)                  f_4(y) := a 2    y

          (%o9)                         done

 -- Función: define_variable (<nombre>, <valor_por_defecto>, <modo>)
     Introduce una variable global en el entorno de Maxima.

     La función `define_variable' sigue los siguientes pasos:

       1. `mode_declare (<nombre>, <modo>)' declara el modo de <nombre>
          ala traductor. Véase en `mode_declare' un listado de los
          posibles modos.

       2. Si la variable no tiene asignado un valor,
          <valor_por_defecto> se le asigna a <nombre>.

       3. `declare (<nombre>, special)' la declara como especial.

       4. Asocia <nombre> con una función test para asegurar que a
          <name> sólo se le asignan valores del modo declarado.


 -- Función: dispfun (<f_1>, ..., <f_n>)
 -- Función: dispfun (all)
     Muestra la deficnión de las funciones de usuario <f_1>, ...,
     <f_n>. Cada argumento puede ser el nombre de una macro (definida
     mediante `::='), una función ordinaria (definida mediante `:=' o
     `define'), una función arreglo  (definida mediante `:=' o
     `define', pero encerrando los argumentos dentro de corchetes `[
     ]'), una función de subíndice (definida mediante `:=' o `define',
     pero encerrando algunos argumentos entre corchetes y otros entre
     paréntesis  `( )'), una función de subíndice seleccionada por un
     subíndice variable, o una función de subíndice definida con un
     subíndice constante.

     La llamada `dispfun (all)' muestra todas las funciones de usuario
     tal como las dan las listas `functions', `arrays' y `macros',
     omitiendo las funciones con subíndices definidas con subíndices
     constantes.

     La función `dispfun' crea una etiqueta (`%t1', `%t2', etc.) para
     cada función mostrada, y asigna la definición de la función a la
     etiqueta. En contraste, `fundef' devuelve las definiciones de las
     funciones.

     La función `dispfun' no evalúa sus argumentos; el operador de
     doble comilla simple `''' permite la evaluación.

     La función `dispfun' devuelve la lista de etiquetas de expresiones
     intermedias correspondientes a las funciones mostradas.

     Ejemplos:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10


 -- Variable del sistema: functions
     Valor por defecto: `[]'

     La variable `functions' es una lista que contiene las funciones
     definidas por el usuario en la sesión actual. Una función definida
     por el usuario es aquella que ha sido construida mediante
     cualquiera de los métodos `define' o `:='. Una función puede
     definirse durante una sesión de Maxima o en un fichero que
     posteriormente será cargado en memoria por `load' o `batch'.
     Téngase en cuenta que las funciones Lisp no se añaden a la lista
     `functions'.


 -- Función: fundef (<f>)
     Devuelve la definición de la función <f>.

     Cada argumento puede ser el nombre de una macro (definida mediante
     `::='), una función ordinaria (definida mediante `:=' o `define'),
     una función arreglo  (definida mediante `:=' o `define', pero
     encerrando los argumentos dentro de corchetes `[ ]'), una función
     de subíndice (definida mediante `:=' o `define', pero encerrando
     algunos argumentos entre corchetes y otros entre paréntesis  `(
     )'), una función de subíndice seleccionada por un subíndice
     variable, o una función de subíndice definida con un subíndice
     constante.

     La función `fundef' no evalúa sus argumentos; el operador de doble
     comilla simple `''' permite la evaluación.

     La llamada de función `fundef (<f>)' devuelve la definición de
     <f>. Por el contrario, `dispfun (<f>)' crea una etiqueta
     intermedia y le asigna la definición a la etiqueta.


 -- Función: funmake (<nombre>, [<arg_1>, ..., <arg_n>])
     Devuelve una expresión `<name> (<arg_1>, ..., <arg_n>)'. El valor
     así retornado es simplificado pero no evaluado, de forma que la
     función no es invocada.

     La función `funmake' evalúa sus argumentos.

     Ejemplos:

        * `funmake' evalúa sus argumentos, pero no el valor retornado.
               (%i1) det(a,b,c) := b^2 -4*a*c$
               (%i2) x: 8$
               (%i3) y: 10$
               (%i4) z: 12$
               (%i5) f: det$
               (%i6) funmake (f, [x, y, z]);
               (%o6)                    det(8, 10, 12)
               (%i7) ''%;
               (%o7)                         - 284

        * Maxima simplifica el valor retornado por `funmake'.
               (%i1) funmake (sin, [%pi/2]);
               (%o1)                           1


 -- Función: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Function: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Function: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ...,
          <expr_n>)
     Define y devuelve una expresión lambda (es decir, una función
     anónima).  La función puede tener argumentos <x_1>, ..., <x_m> y/o
     argumentos opcionales <L>, que aparecerán dentro del cuerpo de la
     función como una lista.  El valor que devuelve la función es
     <expr_n>.  Una expresión lambda puede asignarse a una variable y
     ser evaluada como si fuese una función ordinaria. Además, puede
     aparecer en algunos contextos en los que sea necesario un nombre
     de función.

     Cuando se evalúa la función, se crean las variables <x_1>, ...,
     <x_m> sin asignación de valores. Una función `lambda' puede
     aparecer dentro de un `block' o de otra `lambda'. Las variables
     locales se inicializan cada vez que se entra dentro de un nuevo
     bloque o de otra función `lambda'. Las variables locales se
     consideran globales dentro de un bloque o función `lambda' anidado
     dentro del primero. Si una variable es no local dentro de un
     bloque o función `lambda', su valor es el que le corresponde en el
     bloque o función `lambda' superior. Este criterio se conoce con el
     nombre de "alcance dinámico".

     Una vez establecidas las variables locales <expr_1> a <expr_n> son
     secuencialmente evaluadas. La variable especial  `%%' representa
     el valor de la expresión inmediata anterior. Las sentencias
     `throw' y `catch' pueden aparecer también en la lista de
     expresiones.

     La función `return' no puede aparecer en una expresión `lambda' a
     menos que se encuentre acotada dentro de un bloque (`block'), en
     cuyo caso `return' establece el valor de retorno del bloque, pero
     no de la expresión `lambda', a menos que el bloque resulte ser
     precisamente <expr_n>. De igual manera, `go' no puede aparecer en
     una expresión `lambda' si no es dentro de un `block'.

     Las funciones `lambda' no evalúan sus argumentos;  el operador de
     doble comilla simple `''' permite su evaluación.

     Ejemplo:

        * Una función lambda puede asignarse a una variable y ser
          evaluada como si fuese una función ordinaria.

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a

        * Una expresión lambda puede aparecer en algunos contextos en
          los que sea necesario un nombre de función.

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]

        * Los argumentos son variables locales. Otras variables se
          consideran globales. Las variables globales son evaluadas en
          el momento que lo es la expresión, a menos que la evaluación
          de las mismas sea forzada, como cuando se hace uso de `'''.

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2

        * Las expresiones lambda pueden anidarse. Las variables locales
          de expresiones lambda exteriores se consideran globales en
          expresiones internas, a menos que se enmascaren con variables
          locales de igual nombre.

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2

        * Puesto que `lambda' no evalúa sus argumentos, la expresión
          lambda `i' de más abajo no define una función del tipo
          "multiplicar por `a'". Tal tipo de función se puede definir a
          través de `buildq', como en la expresión lambda `i2' de más
          abajo.

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2

        * Una expresión lambda puede tener un número variable de
          argumentos, los cuales se indican mediante `[<L>]', bien sea
          solo o como un último argumento. Estos argumentos aparecerán
          dentro del cuerpo de la función en forma de lista.

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Función: local (<v_1>, ..., <v_n>)
     Declara las variables  <v_1>, ..., <v_n> locales respecto de todas
     las propiedades en la sentencia en la que aparece esta función.

     La función `local' no evalúa sus argumentos y devuelve `done'.

     La función `local' sólo puede usarse dentro de un `block', en el
     cuerpo de definición de funciones o de expresiones `lambda' o en
     la función `ev', siéndole permitido aparecer una sóla vez en cada
     una de ellas.

     La función `local' es independiente de `context'.


 -- Variable opcional: macroexpansion
     Valor por defecto: `false'

     La variable `macroexpansion' controla si la expansión (esto es, el
     valor de retorno) de una función macro se sustituye por la llamada
     a la función macro. Una sustitución puede acelerar futuras
     evaluaciones de la expresión, bajo el coste que implica tener que
     almacenar la expansión.

    `false'
          La expansión de una función macro no se sustituye por la
          llamada a la función macro.

    `expand'
          La primera vez que se evalúa una llamada a función macro se
          almacena la expansión. De esta manera la expansión no se
          recalcula en llamadas posteriores; cualesquiera efectos
          laterales (como `print' o asignaciones a variables globales)
          tan solo tienen lugar la primera vez que la función macro es
          evaluada. La expansión en una expresión no afecta a otras
          expresiones que llamen a la misma función macro.

    `displace'
          La primera vez que se evalúa una llamada a una función macro,
          la expansión se sustituye por la llamada, modificando así la
          expresión desde la que se hizo la llamada a la función macro.
          La expansión no se recalcula en llamadas posteriores;
          cualesquiera efectos laterales tan solo tienen lugar la
          primera vez que la función macro es evaluada. La expansión en
          una expresión no afecta a otras expresiones que llamen a la
          misma función macro.

     Ejemplos:

     Si `macroexpansion' vale `false', una función macro es llamada
     cada vez que la expresión de llamada es evaluada.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: false;
          (%o4)                         false
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Si `macroexpansion' vale `expand', una función macro tan solo es
     llamada una vez.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: expand;
          (%o4)                        expand
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Si `macroexpansion' vale `expand', una función macro es llamada
     una vez y la expresión de llamada se modifica.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: displace;
          (%o4)                       displace
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                           x - 99
          (%t6)                    f(x) := ------
                                           x + 99

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99


 -- Variable opcional: mode_checkp
     Valor por defecto: `true'

     Cuando `mode_checkp' vale `true', `mode_declare' chequea los modos
     de las variables con valores asignados.


 -- Variable opcional: mode_check_errorp
     Valor por defecto: `false'

     Cuando `mode_check_errorp' vale `true', `mode_declare' llama a
     error.


 -- Variable opcional: mode_check_warnp
     Valor por defecto: `true'

     Cuando `mode_check_warnp' vale `true', se detallan los errores de
     modo.


 -- Función: mode_declare (<y_1>, <modo_1>, ..., <y_n>, <modo_n>)
     La función `mode_declare' se utiliza para declarar los modos de
     variables y funciones para la ulterior traducción a Lisp o
     compilación de funciones. Se coloca habitualmente al comienzo de
     la definición de una función, de un script en Maxima o se ejecuta
     en tiempo real.

     Los argumentos de `mode_declare' son pares formados por una
     variable y un modo, el cual debe ser `boolean', `fixnum',
     `number', `rational' o `float'. Cada variable puede ser sustituida
     por una lista de variables, en cuyo caso todas ellas tendrán el
     mismo modo.

     Código numérico que utilice arreglos puede ejecutarse más rápido
     declarando el tamaño que va a ocupar el arreglo, como en:

          mode_declare (array (a [10, 10]), float)

     para un arreglo de números en coma flotante de dimensiones 10 x 10.

     Se puede declarar el modo del resultado de una función poniendo
     `function (f_1, f_2, ...)' como argumento; aquí `f_1', `f_2', ...
     son los nombres de las funciones. Por ejemplo, la expresión

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     declara que el valor a devolver por  `f_1', `f_2', ... son enteros
     de modo "single-word".

     El nombre `modedeclare' es sinónimo de `mode_declare'.


 -- Función: mode_identity (<arg_1>, <arg_2>)
     Es una forma especial usada con `mode_declare' y `macros' para
     declarar, por ejemplo, una lista de listas de números.


 -- Variable opcional: transcompile
     Valor por defecto: `true'

     Si `transcompile' vale `true', `translate' y `translate_file'
     generan declaraciones para hacer el código traducido más apto para
     la compilación.

     La función `compfile' hace la asignación `transcompile: true'.


 -- Función: translate (<f_1>, ..., <f_n>)
 -- Función: translate (functions)
 -- Función: translate (all)
     Traduce las funciones definidas por el usuario <f_1>, ..., <f_n>
     del lenguaje de Maxima a Lisp y evalúa las traducciones Lisp.
     Normalmente las funciones traducidas se ejecutan más rapidamente
     que las originales.

     Las llamadas `translate (all)' o `translate (functions)' traducen
     todas las funciones de usuario.

     Las funciones a ser traducidas deberían incluir una llamada a
     `mode_declare' al comienzo siempre que sea posible, a fin de
     producir código más eficiente. Por ejemplo:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, modo_1, v_2, modo_2, ...), ...)

     donde <x_1>, <x_2>, ... son los parámetros que se pasan a la
     función y <v_1>, <v_2>, ... son las variables locales.

     Los nombres de las funciones traducidas son eliminados de la lista
     `functions' si `savedef' vale `false' (ver más abajo) y son
     añadidos a las listas `props'.

     Las funciones no deberían ser traducidas hasta no estar
     completamente depuradas.

     Se supone que las expresiones están simplificadas; en caso de no
     estarlo, se generará código correcto pero ineficiente. Así, el
     usuario no debería asignar a `simp' el valor `false', el cual
     inhibe la simplificación de la expresión a ser traducida.

     Cuando la variable `translate' vale `true', se traducen
     automáticamente las funciones de usuario a Lisp.

     Nótese que las funciones traducidas puede que no se ejecuten
     exactamente igual a como lo hacían antes de la traducción, debido
     a posibles incompatibilidades entre las versiones de Maxima y
     Lisp. En general, la función `rat' con más de un argumento y la
     función `ratvars' no deberían utilizarse si algunas de las
     variables son declaradas como expresiones racionales canónicas
     (CRE) mediante `mode_declare'. Además, la asignación  `prederror:
     false' no traducirá.

     Si `savedef' vale `true', entonces la versión de Maxima de una
     función de usuario permanecerá cuando la función sea traducida por
     `translate'. Con esto se hace posible que se muestre la definición
     llamando a `dispfun' y que la función sea editada.

     Si `transrun' vale `false' entonces las versiones interpretadas de
     todas las funciones serán ejecutadas en lugar de las versiones
     traducidas.

     El resultado devuelto por `translate' es una lista con los nombres
     de las funciones traducidas.


 -- Función: translate_file (<nombre_fichero_maxima>)
 -- Función: translate_file (<nombre_fichero_maxima>,
          <nombre_fichero_lisp>)
     Traduce un fichero en código Maxima a un fichero en código Lisp.
     La función `translate_file' devuelve una lista con los nombres de
     tres ficheros: el nombre del ficheero en Maxima, el nombre del
     fichero en Lisp y el nombre del fichero que contiene información
     adicional sobre la traducción. La función `translate_file' evalúa
     sus argumentos.

     La llamada `translate_file ("foo.mac"); load("foo.LISP")' es lo
     mismo que `batch ("foo.mac")', excepto por la presencia de ciertas
     restricciones, como el uso de `''' y `%', por ejemplo.

     La llamada `translate_file (<nombre_fichero_maxima>)' traduce un
     fichero en Maxima, <nombre_fichero_maxima>, a otro en Lisp de
     nombre similar. Por ejemplo, `foo.mac' se traduce en `foo.LISP'.
     El nombre del fichero en Maxima puede incluir el nombre de un
     directorio, en cuyo caso el fichero de salida Lisp se guardará en
     el mismo directorio desde el que se leyó la fuente Maxima.

     La llamada `translate_file (<nombre_fichero_maxima>,
     <nombre_fichero_lisp>)' traduce el fichero Maxima
     <nombre_fichero_maxima> en el fichero Lisp <nombre_fichero_lisp>.
     La función `translate_file' ignora la extensión del fichero, en
     caso de que exista, de `nombre_fichero_lisp'; la extensión del
     fichero de salida Lisp  será invariablemente `LISP'. El nombre del
     fichero Lisp puede incluir la ruta del directorio, en cuyo caso se
     almacenará en el directorio especificado.

     La función `translate_file' también escribe un fichero de mensajes
     de avisos del traductor con diversos niveles de gravedad. La
     extensión de este fichero es `UNLISP'. Este fichero puede contener
     información valiosa, aunque de difícil interpretación, para
     detectar fallos en el código traducido. El fichero `UNLISP' se
     guarda siempre en el mismo directorio desde el que se leyó la
     fuente de Maxima.

     La función `translate_file' emite código Lisp que incluye algunas
     declaraciones y definiciones que entran en efecto tan pronto como
     el código Lisp es compilado. Véase `compile_file' para más
     información sobre este particular.

     Véanse también `tr_array_as_ref', `tr_bound_function_applyp',
     `tr_exponent', `tr_file_tty_messagesp',
     `tr_float_can_branch_complex', `tr_function_call_default',
     `tr_numer', `tr_optimize_max_loop', `tr_semicompile',
     `tr_state_vars', `tr_warnings_get', `tr_warn_bad_function_calls',
     `tr_warn_fexpr', `tr_warn_meval', `tr_warn_mode',
     `tr_warn_undeclared', `tr_warn_undefined_variable', y `tr_windy'.


 -- Variable opcional: transrun
     Valor por defecto: `true'

     Si `transrun' vale `false' entonces se ejecutarán las versiones
     interpretadas de todas las funciones, en lugar de las versiones
     traducidas.


 -- Variable opcional: tr_array_as_ref
     Valor por defecto: `true'

     Si `translate_fast_arrays' vale `false', referencias de arreglos
     en el código Lisp creadas por  `translate_file' se ven afectadas
     por `tr_array_as_ref'.

     El valor de la variable `tr_array_as_ref' no tiene ningún efecto
     cuando `translate_fast_arrays' vale `true'.


 -- Variable opcional: tr_bound_function_applyp
     Valor por defecto: `true'

     Si `tr_bound_function_applyp' vale `true', Maxima envía un aviso
     si encuentra una variable con valor asignado que está siendo
     utilizada como una función. `tr_bound_function_applyp' no influye
     en el código generado bajo estas circunstancias.

     Por ejemplo, una expresión como `g (f, x) := f (x+1)' provocará un
     mensaje de esta naturaleza.


 -- Variable opcional: tr_file_tty_messagesp
     Valor por defecto: `false'

     Si `tr_file_tty_messagesp' vale `true', los mensajes generados por
     `translate_file' durante la traducción de un fichero se muestran
     en la consola y se insertan en el fichero UNLISP.  Si vale
     `false', los mensajes sobre la traducción del fichero sólo se
     incorporan al fichero UNLISP.


 -- Variable opcional: tr_float_can_branch_complex
     Valor por defecto: `true'

     Le dice al traductor de Maxima a Lisp que las funciones `acos',
     `asin', `asec' y `acsc' pueden devolver valores complejos.


 -- Variable opcional: tr_function_call_default
     Valor por defecto: `general'

     El valor `false' significa llama a `meval', `expr' significa que
     Lisp asignó los argumentos de la función,  `general', el valor por
     defecto, devuelve código apropiado para `mexprs' y `mlexprs' pero
     no para `macros'. La opción `general' asegura que las asignaciones
     de las variables son correctas en el código compilado. En modo
     `general', cuando se traduce F(X), si F es una variable con valor,
     entonces se entiende que se quiere calcular `apply (f, [x])', y
     como tal se traduce, con el apropiado aviso. No es necesario
     desactivar esto. Con los valores por defecto la falta de mensajes
     de aviso implica compatibilidad completa entre el código traducido
     y compilado con el interpretado por Maxima.


 -- Variable opcional: tr_numer
     Valor por defecto: `false'

     Si `tr_numer' vale `true' se utilizan las propiedades numéricas en
     aquellos átomos que las posean, como en  `%pi'.


 -- Variable opcional: tr_optimize_max_loop
     Valor por defecto: 100

     El valor de `tr_optimize_max_loop' es el número máximo de veces
     que el traductor repetirá la macro-expansión y la optimización en
     el tratamiento de una expresión.


 -- Variable opcional: tr_semicompile
     Valor por defecto: `false'

     Si `tr_semicompile' vale `true', las salidas de `translate_file' y
     `compfile' serán macro-expandidas pero no compiladas a código
     máquina por el compilador de Lisp.


 -- Variable del sistema: tr_state_vars
     Valor por defecto:

          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     Es la lista de variables que afectan la forma en que se obtiene la
     salida del código traducido. Esta información es útil para
     desarrolladores que pretendan corregir posibles fallos del
     traductor. Comparando el código traducido con el que se debería
     obtener bajo unas ciertas condiciones, es posible hacer el
     seguimiento de los fallos.


 -- Función: tr_warnings_get ()
     Devuelve una lista con los avisos dados por el traductor.


 -- Variable opcional: tr_warn_bad_function_calls
     Valor por defecto: `true'

     Devuelve un aviso cuando se hacen llamadas a funciones que quizás
     no sean correctas debido a declaraciones inapropiadas realizadas
     durante la traducción.


 -- Variable opcional: tr_warn_fexpr
     Valor por defecto: `compfile'

     Devuelve un aviso si se encuentra con alguna FEXPR. Las FEXPR no
     deberían aparecer en el código traducido.


 -- Variable opcional: tr_warn_meval
     Valor por defecto: `compfile'

     Devuelve un aviso si la función `meval' es llamada.  Si `meval' es
     invocada, es señal de la presencia de problemas en la traducción.


 -- Variable opcional: tr_warn_mode
     Valor por defecto: `all'

     Devuelve un aviso cuando a las variables se les asignan valores
     incompatibles con su modo.


 -- Variable opcional: tr_warn_undeclared
     Valor por defecto: `compile'

     Determina cuando enviar mensajes sobre variables no declaradas.


 -- Variable opcional: tr_warn_undefined_variable
     Valor por defecto: `all'

     Devuelve un aviso cuando se detectan variables globales no
     definidas.


 -- Variable opcional: tr_windy
     Valor por defecto: `true'

     Genera comentarios de ayuda y consejos sobre programación.


 -- Función: compile_file (<nombre_fich>)
 -- Función: compile_file (<nombre_fich>, <nombre_fich_compilado>)
 -- Función: compile_file (<nombre_fich>, <nombre_fich_compilado>,
          <nombre_fich_lisp>)
     Traduce el fichero Maxima <nombre_fich> a Lisp, ejecuta el
     compilador de Lisp y, en caso de ser exitosa la compilación, carga
     el código compilado en Maxima.

     La función `compile_file' devuelve una lista con los nombres de
     tres ficheros: el fichero original en Maxima, la traducción Lisp,
     notas sobre la traducción y el código compilado. Si la compilación
     falla, el cuarto elemento es  `false'.

     Algunas declaraciones y definiciones entran en efecto tan pronto
     como el código Lisp es compilado (sin cargar el código compilado).
     Éstas incluyen funciones definidas con el operador `:=', macros
     definidas con el operador `::=', `alias', `declare',
     `define_variable',  `mode_declare' y `infix', `matchfix', `nofix',
     `postfix', `prefix' y `compfile'.

     Asignaciones y llamadas a funciones no se evalúan hasta que el
     código compilado es cargado. En particular, dentro del fichero
     Maxima, asignaciones a los controles ("flags") de traducción
     (`tr_numer', etc.) no tienen efecto durante la traducción.

     El <nombre_fich> no puede contener sentencias del tipo `:lisp'.

     La función `compile_file' evalúa sus argumentos.


 -- Función: declare_translated (<f_1>, <f_2>, ...)
     Cuando se traduce un fichero de código Maxima a Lisp, es
     importante para el traductor saber qué funciones de las que están
     en el fichero van a ser llamadas como traducidas o compiladas, y
     cuáles son simplemente funciones Maxima o que no están definidas.
     Se genera el código `(MFUNCTION-CALL fn arg1 arg2 ...)' cuando el
     traductor no sabe si fn va a ser una función lisp.



File: maxima.info,  Node: Programación,  Next: Depurado,  Prev: Definición de Funciones,  Up: Top

41 Programación
***************

* Menu:

* Introducción a la Programación::
* Definiciones para la Programación::


File: maxima.info,  Node: Introducción a la Programación,  Next: Definiciones para la Programación,  Prev: Programación,  Up: Programación

41.1 Introducción a la Programación
===================================

Maxima dispone de los bucles `do' para hacer iteraciones, así como
estructuras más primitivas del estilo de `go'.


File: maxima.info,  Node: Definiciones para la Programación,  Prev: Introducción a la Programación,  Up: Programación

41.2 Definiciones para la Programación
======================================

 -- Función: backtrace ()
 -- Función: backtrace (<n>)
     Devuelve la pila de llamadas, esto es, la lista de funciones que
     han llamado a la función actualmente activa.

     La llamada a `backtrace()' devuelve la pila completa de llamadas.

     Ejemplos:

          (%i1) h(x) := g(x/7)$
          (%i2) g(x) := f(x-11)$
          (%i3) f(x) := e(x^2)$
          (%i4) e(x) := (backtrace(), 2*x + 13)$
          (%i5) h(10);
          #0: e(x=4489/49)
          #1: f(x=-67/7)
          #2: g(x=10/7)
          #3: h(x=10)
                                        9615
          (%o5)                         ----
                                         49

     La llamada `backtrace (<n>)' devuelve las <n> funciones más
     recientes, incluyendo a la función actualmente activa.

     Ejemplos:

          (%i1) h(x) := (backtrace(1), g(x/7))$
          (%i2) g(x) := (backtrace(1), f(x-11))$
          (%i3) f(x) := (backtrace(1), e(x^2))$
          (%i4) e(x) := (backtrace(1), 2*x + 13)$
          (%i5) h(10);
          #0: h(x=10)
          #0: g(x=10/7)
          #0: f(x=-67/7)
          #0: e(x=4489/49)
                                        9615
          (%o5)                         ----
                                         49


 -- Operador especial: do
     La sentencia `do' se utiliza para realizar iteraciones.  Debido a
     su generalidad la sentencia `do' se describirá en dos partes. En
     primer lugar se mostrará su forma más usual, análoga a la de otros
     lenguajes de programación (Fortran, Algol, PL/I, etc.); después se
     mencionarán otras formas de uso.

     Hay tres variantes de esta sentencia que se diferencian entre sí
     únicamente por las condiciones de fin de bucle. Son las siguientes:

        * `for <variable>: <valor_inicial> step <incremento>       thru
          <límite> do <cuerpo>'

        * `for <variable>: <valor_inicial> step <incremento>
          while <condición> do <cuerpo>'

        * `for <variable>: <valor_inicial> step <incremento>
          unless <condición> do <cuerpo>'

     El <valor_inicial>, el <incremento>, el <límite> y el <cuerpo>
     pueden ser cualquier tipo de expresión válida de Maxima. Si el
     incremento es igual a la unidad (1) entonces "`step 1'" puede
     omitirse.

     La ejecución de la sentencia `do' se realiza asignando el
     valor_inicial a la variable (llamada de aquí en adelante
     variable-control). A continuación: (1) si la variable-control ha
     excedido el límite de la especificación dada por un `thru', o si
     la condición impuesta por `unless' es verdadera (`true'), o si la
     condición dada por `while' es falsa (`false') entonces la
     iteración `do' termina. (2) El cuerpo se evalúa.  (3) El
     incremento es sumado a la variable-control. El proceso de (1) a
     (3) se repite hasta que la condición de fin de iteración se
     satisfaga. También es posible especificar varias condiciones de
     terminación del bucle, en cuyo caso `do' terminará cuando se
     satisfaga alguna de ellas.

     En general la condición `thru' se satisfará cuando la
     variable-control sea mayor que el límite si el incremento es no
     negativo, o cuando la variable-control sea menor que el límite
     cuando el incremento es negativo. El incremento y el límite pueden
     ser expresiones no numéricas, tanto en cuanto esta desigualdad
     pueda quedar determinada. Sin embargo, a menos que el incremento
     sea un número negativo en el momento de comenzar el cómputo de
     `do', Maxima supondrá que se evaluará a una cantidad positiva. En
     caso de no ser efectivamente positivo, la sentencia `do' puede dar
     un resultado inesperado.

     Nótese que el límite, el incremento y la condición de terminación
     se evalúan en cada iteración del bucle. Así, si alguna de
     expresiones necesitan de muchos cálculos y devuelven un resultado
     que no va a cambiar durante toda la ejecución del cuerpo, será más
     eficiente dar este valor a una variable antes de comenzar la
     sentencia `do' y utilizarla luego durante su ejecución.

     El valor que habitualmente devuelva la sentencia `do' será el
     átomo `done'. Sin embargo, la función `return' puede usarse dentro
     del cuerpo para salir de `do' de forma prematura retornando un
     valor determinado.  Nótese no obstante que un `return' dentro de
     un `do' que está dentro de un bloque (`block') provocará una
     salida de `do' pero no de `block'. Repárese también en que la
     función `go' no puede usarse para salir de `do' e ir a algún lugar
     de `block'.

     La variable-control es siempre local respecto de `do', por lo que
     se puede utilizar cualquier nombre de variable sin afectar el
     valor de cualquier otra variable externa a `do' y que tenga el
     mismo nombre. La variable-control no tendrá asignado ningún valor
     una vez se haya concluido el `do'.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Nótese que la condición `while i <= 10' es equivalente a `unless i
     > 10' y a `thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     lo que da ocho términos del desarrollo de Taylor de la función
     `e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Este ejemplo calcula la raíz cuadrada negativa de 10 haciendo 10
     iteraciones del método de Newton-Raphson. De no haberse alcanzado
     el criterio de convergencia el valor devuelto hubiese sido `done'.

     En lugar de añadir siempre una cantidad a la variable-control a
     veces se puede querer que cambie en cada iteración siguiendo algún
     otro criterio. En tal caso se puede hacer uso de `next
     <expresión>' en lugar de `step <incremento>'. Esto hará que a la
     variable-control se le asigne el resultado de evaluar la expresión
     en cada iteración del bucle.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     En ocasiones puede interesar realizar una iteración en la que la
     variable-control no se utilice nunca. Se podrá entonces dar
     únicamente las condiciones de terminación del bucle omitiendo la
     inicialización y actualizando la información, tal como se hace en
     el siguiente ejemplo para calcular la raíz cuadrada de 5
     utilizando un valor inicial alejado de la solución.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Si así se quiere, incluso es posible omitir las condiciones de
     terminación completamente y escribir únicamente `do <body>', lo
     que provocará entrar en un bucle infinito. En tal caso, debería
     usarse la función `return' a fin de terminar con la ejecución de
     `do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (En este ejemplo, cuando se ejecuta `return' obliga a que sea `x'
     el valor devuelto por `do'. Al salirse del bloque, `x' es también
     el valor que devuelve `block' por ser `do' la última sentencia del
     bloque.)

     Hay todavía otra forma de `do' en Maxima. Su sintaxis es:

          for <variable> in <lista> <test_de_parada> do <cuerpo>

     Los elementos de <list> son cualesquiera expresiones que se irán
     asignando sucesivamente a la variable en cada repetición del
     cuerpo. El test de parada <end_tests> (que es opcional) puede
     usarse para terminar la ejecución de `do'; de otro modo las
     iteraciones se pararán cuando la lista se haya agotado o cuando se
     ejecute un `return' dentro del cuerpo.  (De hecho, la lista puede
     ser cualquier expresión no atómica, de la cual se irán extrayendo
     de forma sucesiva sus diferentes partes.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816


 -- Función: errcatch (<expr_1>, ..., <expr_n>)
     Evalúa las expresiones <expr_1>, ..., <expr_n> una a una y
     devuelve `[<expr_n>]' (una lista) en caso de que no ocurra ningún
     error. En caso de aparecer algún error durante el cálculo de
     alguno de los argumentos, `errcatch' evita que el error se
     propague y devuelve la lista vacía `[]' sin evaluar más argumentos.

     La función `errcatch' es útil en ficheros `batch' donde se
     sospeche que pueda aparecer algún error, el cual provocaría la
     terminación de la ejecución del `batch' de no ser previamente
     detectado.


 -- Función: error (<expr_1>, ..., <expr_n>)
 -- Variable del sistema: error
     Calcula y devuelve <expr_1>, ..., <expr_n>, enviando
     posteriormente una seãl de error a Maxima o al `errcatch' más
     cercano.

     A la variable `error' se le asigna una lista con la descripción
     del error. El primer elemento de `error' es una cadena de formato,
     la cual une todas las cadenas de los argumentos <expr_1>, ...,
     <expr_n>, siendo los demás elementos de la lista los valores de
     los argumentos que no son cadenas.

     La llamada a `errormsg()' formatea e imprime `error'. Se reimprime
     así el mensaje de error más reciente.


 -- Función: errormsg ()
     Reimprime el mensaje de error más reciente. La variable `error'
     guarda el mensaje y `errormsg' lo formatea e imprime.


 -- Operador especial: for
     Utilizado en las iteraciones. Véase `do' para una descripción de
     las técnicas de iteración en Maxima.


 -- Función: go (<etiqueta>)
     Se utiliza dentro de un bloque (`block') para transferir el
     control a la sentencia del bloque que esté etiquetada con el
     argumento de `go'. Una sentencia queda etiquetada cuando está
     precedida por un argumento de tipo átomo como cualquier otra
     sentencia de `block'.  Por ejemplo:

          block ([x], x:1, tururu, x+1, ..., go(tururu), ...)

     El argumento de `go' debe ser el nombre de una etiqueta que
     aparezca en el mismo bloque (`block'). No se puede utilizar `go'
     para transferir el control a un bloque que no sea aquel que
     contenga la sentencia `go'.


 -- Operador especial: if
     La sentencia `if' se utiliza para la ejecución condicionada.  Su
     sintaxis es:

          if <condición> then <expr_1> else <expr_2>

     El resultado de una sentencia `if' es <expr_1> si la condición es
     verdadera (`true') y <expr_2> si es falsa. Tanto <expr_1> como
     <expr_2> son expresiones correctas en Maxima (incluyendo
     sentencias `if' anidadas) y  <condition> es una expresión que
     puede ser verdadera (`true') o falsa (`false'), formada con los
     operadores relacionales y lógicos siguientes:

          Operación               Símbolo     Tipo

          menor que               <           operador relacional infijo
          menor o igual que       <=          operador relacional infijo
          igualdad (sintáctica)   =           operador relacional infijo
          negación de =           #           operador relacional infijo
          igualdad (por valor)    equal       operador relacional infijo
          negación de equal       notequal    operador relacional infijo
          mayor o igual que       >=          operador relacional infijo
          mayor que               >           operador relacional infijo
          y                       and         operador lógico infijo
          o                       or          operador lógico infijo
          no                      not         operador lógico prefijo


 -- Función: map (<f>, <expr_1>, ..., <expr_n>)
     Devuelve una expresión cuyo operador principal es el mismo que
     aparece en las expresiones <expr_1>, ..., <expr_n> pero cuyas
     subpartes son los resultados de aplicar <f> a cada una de las
     subpartes de las expresiones;  <f> puede ser tanto el nombre de
     una función de n argumentos o una forma `lambda' de n argumentos.

     Uno de los usos que tiene `map' es la de aplicar (o mapear) una
     función (por ejemplo, `partfrac') sobre cada término de una
     expresión extensa en la que normalmente no se podría utilizar la
     función debido a insuficiencias en el espacio de almacenamiento
     durante el curso de un cálculo.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]

 -- Función: mapatom (<expr>)
     Devuelve `true' si y sólo <expr> es tratado por las rutinas de
     mapeo como un átomo.


 -- Variable optativa: maperror
     Valor por defecto: `true'

     Cuando `maperror' toma el valor `false', hace que todas las
     funciones de mapeo, como por ejemplo

          map (f, expr_1, expr_2, ...))

     (1) paren cuando hayan terminado de procesar la expi más corta, a
     menos que todas ellas sean del mismo tamaño y (2) apliquen  `f' a
     `[expr_1, expr_2, ...]' si es el caso que las `expr_i' no son
     todas del mismo tipo de objeto.

     Cuando `maperror' toma el valor `true' entonces se emite un
     mensaje de error cuando se presenta cualquiera de los dos casos
     anteriores.


 -- Función: maplist (<f>, <expr_1>, ..., <expr_n>)
     Devuelve una lista con las aplicaciones de <f> a las partes de las
     expresiones <expr_1>, ..., <expr_n>; <f> es el nombre de una
     función ou una expresión lambda.

     La función `maplist' difiere de `map (<f>, <expr_1>, ...,
     <expr_n>)', la cual devuelve una expresión con el mismo operador
     principal que tenga <expr_i>, excepto en simplificaciones y en el
     caso en el que `map' hace un `apply'.


 -- Variable optativa: prederror
     Valor por defecto: `true'

     Cuando `prederror' toma el valor `true', se emite un mensaje de
     error siempre que el predicado de una sentencia  `if' o de una
     función `is' no se pueda evaluar ni a verdadero (`true') ni  a
     falso (`false').

     Si toma el valor `false', se devuelve bajo las mismas
     circunstancias anteriores el valor `unknown'. El modo `prederror:
     false' no está soportado en el código traducido; sin embargo,
     `maybe' está soportado en código traducido.

     Véanse también `is' y `maybe'.


 -- Función: return (valor)
     Puede utilizarse para salir de un bloque, devolviendo su.  Véase
     `block' para más información.


 -- Función: scanmap (<f>, <expr>)
 -- Función: scanmap (<f>, <expr>, bottomup)
     Aplica recursivamente <f> sobre <expr>, de arriba hacia abajo.
     Esto es más útil cuando se busca una factorización completa, por
     ejemplo:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Nótese que cómo `scanmap' aplica la función dada `factor' a las
     subexpresiones que forman a <expr>; si se presenta otra forma de
     <expr> a `scanmap' entonces el resultado puede ser diferente. Así,
     `%o2' no se restaura cuando `scanmap' se aplica a la forma
     expandida de exp:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Aquí hay otro ejemplo de la forma en que `scanmap' aplica
     recursivamente una función dada a todas las subexpresiones,
     incluyendo exponentes:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' aplica <f> a <expr> de abajo
     hacia arriba. Por ejemplo, para `f' no definida,

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     En este caso se obtiene la misma respuesta por cualquiera de los
     dos métodos.


 -- Función: throw (<expr>)
     Evalúa <expr> y devuelve el valor del `catch' más reciente. La
     función `throw' se utiliza junto con `catch' como un mecanismo de
     retorno no local.


 -- Función: outermap (<f>, <a_1>, ..., <a_n>)
     Aplica la función <f> a cada uno de los elementos del producto
     vectorial <a_1> por <a_2> ... por <a_n>.

     La función <f> tiene n argumentos o también puede tratarse de una
     función lambda de n argumentos.  Los argumentos <a_1>, ..., <a_n>
     pueden ser listas o no. Argumentos en forma de listas pueden tener
     longitudes diferentes. Argumentos que no son listas son tratados
     como listas de longitud 1 con el propósito de poder realizar el
     producto vectorial.

     El resultado de aplicar <f> al producto vectorial se organiza como
     una lista anidada. La profundidad del anidamiento es igual al
     número de argumentos en forma de lista (los argumentos que no son
     listas no contribuyen a sumar niveles).  Una lista con nivel de
     anidamiento k tiene la misma longitud que el k-ésimo argumento con
     forma de lista.

     La función `outermap' evalúa sus argumentos.

     Véanse también `map', `maplist' y `apply'.

     Ejemplos:

          (%i1) f (x, y) := x - y$
          (%i2) outermap (f, [2, 3, 5], [a, b, c, d]);
          (%o2) [[2 - a, 2 - b, 2 - c, 2 - d],
                [3 - a, 3 - b, 3 - c, 3 - d], [5 - a, 5 - b, 5 - c, 5 - d]]
          (%i3) outermap (lambda ([x, y], y/x), [55, 99], [Z, W]);
                                  Z   W     Z   W
          (%o3)                 [[--, --], [--, --]]
                                  55  55    99  99
          (%i4) g: lambda ([x, y, z], x + y*z)$
          (%i5) outermap (g, [a, b, c], %pi, [11, 17]);
          (%o5) [[a + 11 %pi, a + 17 %pi], [b + 11 %pi, b + 17 %pi],
                                                  [c + 11 %pi, c + 17 %pi]]
          (%i6) flatten (%);
          (%o6) [a + 11 %pi, a + 17 %pi, b + 11 %pi, b + 17 %pi,
                                                    c + 11 %pi, c + 17 %pi]



File: maxima.info,  Node: Depurado,  Next: Índice de Funciones y Variables,  Prev: Programación,  Up: Top

42 Depurado
***********

* Menu:

* Depuración del código fuente::
* Claves de depuración::
* Definiciones para Depurado::


File: maxima.info,  Node: Depuración del código fuente,  Next: Claves de depuración,  Up: Depurado

42.1 Depuración del código fuente
=================================

Maxima es capaz de dar asistencia en la depuración del código fuente.
Un usuario puede establecer un punto de referencia dentro del código de
una función a partir del cual se siga la ejecución línea a línea. La
compliación puede ser posteriormente examinada, conjuntamente con los
valores que se han ido asignando a las variables.

   La instrucción `:help', o `:h', muestra la lista de comandos para la
depuración. (En general, los comandos pueden abreviarse; en algunos
casos la lista de alternativas podrá ser listada.) Dentro del
depurador, el usuario podrá examinar también cualquier función propia
de Maxima, definirla y manipular variables y expresiones.

   El punto de referencia se establecerá con la instrucción `:br'. Ya
dentro del depurador, el usuario podrá avanzar una línea de cada vez
utilizando la instrucción `:n' (de "next", en inglés). La orden `:bt'
(de "backtrace") muestra la lista de la pila. Finalmente, con el
comando `:r' ("resume") se abandona el depurador continuando con la
ejecución. El uso de estas instrucciones se muestra en el siguiente
ejemplo.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                  <-- pulsando :bt se retrocede
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                   <-- pulsando :n se avanza una línea
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                   <-- pulsando :n se avanza otra línea
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                   <-- se pide el valor de u
     28

     (dbm:1) u: 33;               <-- se cambia el valor de u a 33
     33

     (dbm:1) :r                   <-- pulsando :r se termina la depuración

     (%o2)                                1094

   El fichero `/tmp/foobar.mac' contiene lo siguiente:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   USO DEL DEPURADOR EN EMACS

   Si el usuario está corriendo el código bajo GNU emacs en un entorno
de texto (dbl shell), o está ejecutando el  entorno gráfico `xmaxima',
entonces cuando una función pare en el punto de referencia, podrá
observar su posición actual en el archivo fuente, el cual será mostrado
en la otra mitad de la ventana, bien resaltada en rojo, o con una
pequeña flecha apuntando a la línea correcta. El usuario puede avanzar
líneas simples tecleando M-n (Alt-n).

   Bajo Emacs se debe ejecutar el programa en una ventana de texto
`dbl', la cual requiere el archivo `dbl.el' que está en el directorio
elisp. El usuario debe instalar los archivos elisp o agregar el
directorio elisp de Maxima a la ruta de búsqueda: por ejemplo, se puede
añadir lo siguiente al archivo `.emacs' o al `site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   entonces en emacs

     M-x dbl

   debería abrir una ventana del sistema en la cual se pueden ejecutar
programas, por ejemplo Maxima, gcl, gdb, etc.  En esta ventana también
se puede ejecutar el depurador, mostrando el código fuente en la otra
ventana.

   El usuario puede colocar un punto de referencia en una línea
determinada sin más que teclear `C-x space'. Con esto se le hace saber
al depurador en qué función está el cursor y en qué línea del mismo. Si
el cursor está en la línea 2 de `foo', entonces insertará en la otra
ventana la instrucción "`:br foo 2'", a fin de detener `foo' justo en
la segunda línea. Para tener esto operativo, el usuario debe tener
activo maxima-mode.el (modo-maxima.el) en la ventana en la que está
`foobar.mac'. Hay otros comandos disponibles en la ventana, como
evaluar la función dentro de Maxima tecleando `Alt-Control-x'.


File: maxima.info,  Node: Claves de depuración,  Next: Definiciones para Depurado,  Prev: Depuración del código fuente,  Up: Depurado

42.2 Claves de depuración
=========================

Las claves de depuración son palabras que no son interpretadas como
expresiones de Maxima. Una clave de depuración puede introducirse
dentro de Maxima o del depurador. Las claves de depuración comienzan
con dos puntos, ':'. Por ejemplo, para evaluar una expresión Lisp, se
puede teclear `:lisp' seguido de la expresión a ser evaluada.

     (%i1) :lisp (+ 2 3)
     5

   El número de argumentos depende del comando en particular. Además,
tampoco es necesario teclear el nombre completo de la instrucción, tan
solo lo justo para diferenciarla de las otras instrucciones. Así, `:br'
sería suficiente para `:break'.

   Las claves de depuración se listan a continuación.

`:break F n'
     Establece un punto de referencia en la función `F' en la línea `n'
     contando a partir del comienzo de la función. Si `F' es una
     cadena, entonces se entiende que se trata de un fichero, siendo
     entonces `n' el número de línea a partir del comienzo del fichero.
     El valor `n' es opcional; en caso de no ser suministrado, se
     entenderá que vale cero (primera línea de la función o fichero).

`:bt'
     Retrocede en la pila.

`:continue'
     Continua el cómputo de la función.

`:delete'
     Borra los punto de referencia especificados, o todos si no se
     especifica ninguno.

`:disable'
     Deshabilita los puntos de referencia especificados, o todos si no
     se especifica ninguno.

`:enable'
     Habilita los puntos de referencia especificados, o todos si no se
     especifica ninguno.

`:frame n'
     Imprime el elemento `n' de la pila, o el actualmente activo si no
     se especifica ninguno.

`:help'
     Imprime la ayuda sobre un comando del depurador, o de todos los
     comandos si no se especifica ninguno.

`:info'
     Imprime información sobre un elemento.

`:lisp expresión'
     Evalúa la `expresión' Lisp.

`:lisp-quiet expresión'
     Evalúa la `expresión' Lisp sin devolver el resultado.

`:next'
     Como `:step', excepto que `:next' se salta las llamadas a
     funciones.

`:quit'
     Sale del nivel actual del depurador sin completar el cómputo.

`:resume'
     Continúa con el cómputo.

`:step'
     Sigue con el cómputo de la función o fichero hasta que alcance una
     nueva línea fuente.

`:top'
     Retorna a Maxima desde cualquier nivel del depurador sin completar
     el cómputo.


File: maxima.info,  Node: Definiciones para Depurado,  Prev: Claves de depuración,  Up: Depurado

42.3 Definiciones para Depurado
===============================

 -- Variable opcional: refcheck
     Valor por defecto: `false'

     Cuando `refcheck' vale `true', Maxima imprime un mensaje cada vez
     que una variable es utilizada por vez primera en un cálculo.


 -- Variable opcional: setcheck
     Valor por defecto: `false'

     Cuando el valor de `setcheck' es una lista de variables (se admite
     que tengan subíndices) Maxima devuelve un mensaje indicando si los
     valores que han sido asignados a las variables lo han sido con el
     operador ordinario `:', o con el operador de asignación `::' o
     como resultado de haberse realizado una llamada de función, pero
     en ningún caso cuando la asignación haya sido hecha mediante los
     operadores `:=' o `::='. El mensaje contiene el nombre de la
     variable y su valor.

     La variable `setcheck' admite también los valores `all' o `true'
     con lo que el informe incluirá todas las variables.

     Cada nueva asignación de `setcheck' establece una nueva lista de
     variables a ser monitorizada, de forma que cualquier otra variable
     previamente asignada a `setcheck' es olvidada.

     Los nombres asignados a `setcheck' deben estar precedidos del
     apóstrofo `'' a fin de evitar que las variables sean evaluadas
     antes de ser almacenadas en `setcheck'. Por ejemplo, si `x', `y' y
     `z' ya guardan algún valor entoces se hará

          setcheck: ['x, 'y, 'z]$

     para colocarlas en la lista de variables a monitorizar.

     No se generará ninguna salida cuando una variable de la lista
     `setcheck' sea asignada a ella misma, como en `X: 'X'.


 -- Variable opcional: setcheckbreak
     Valor por defecto: `false'

     Si `setcheckbreak' es igual `true', Maxima se detendrá siempre que
     a una variable de la lista `setcheck' se le asigne un nuevo valor.
     La detención tendrá lugar justo antes de hacerse la asignación. En
     ese momento `setval' guarda el valor que se le va a dar a la
     variable. Entonces el usuario podrá darle un valor diferente
     pasándoselo a la variable `setval'.

     Véanse también `setcheck' y `setval'.


 -- Variable del sistema: setval
     Guarda el valor que va a ser asignado a una variable cuando
     `setcheckbreak' realiza una detención. Entonces se podrá asignarle
     otro valor pasándoselo previamente a `setval'.

     Véanse también `setcheck' y `setcheckbreak'.


 -- Función: timer (<f_1>, ..., <f_n>)
 -- Función: timer ()
     Dadas las funciones <f_1>, ..., <f_n>, `timer' coloca cada una de
     ellas en la lista de funciones para las cuales se generarán
     estadísticas relativas al tiempo de cómputo. Así, `timer(f)$
     timer(g)$' coloca a `f' y luego a `g' en dicha lista de forma
     acumulativa.

     Si no se le pasan argumentos a `timer' se obtendrá la lista de
     funciones cuyos tiempos de ejecución se quieren monitorizar.

     Maxima almacena la duración del cómputo de cada función de la
     lista, de forma que `timer_info' devolverá las estadísticas
     correspondientes, incluyendo el tiempo medio de cada llamada a la
     función, el número de llamadas realizadas y el tiempo total
     transcurrido. La instrucción `untimer' borra las funciones de la
     lista.

     La función `timer' no evalúa sus argumentos, de forma que `f(x) :=
     x^2$ g:f$ timer(g)$' no coloca a `f' en la lista.

     Si `trace(f)' está activada, entonces `timer(f)' está desactivada;
     `trace' y `timer' no pueden estar operativas al mismo tiempo.

     Véase también `timer_devalue'.


 -- Función: untimer (<f_1>, ..., <f_n>)
 -- Función: untimer ()
     Dadas las funciones <f_1>, ..., <f_n>, `untimer' las elimina de la
     lista de funciones cuyos tiempos de ejecución se quiere
     monitorizar.

     Si no se le suministran argumentos, `untimer' borra completamente
     la lista.

     Tras la ejecución de `untimer (f)', `timer_info (f)' aún devuelve
     las estadísticas de tiempo previamente registradas, pero
     `timer_info()' (sin argumentos) no devuelve información sobre
     aquellas funciones que ya no están en la lista. La ejecución de
     `timer (f)' inicializa todas las estadísticas a cero y coloca `f'
     nuevamente en la lista.


 -- Variable opcional: timer_devalue
     Valor por defecto: `false'

     Si `timer_devalue' es igual a `true', Maxima le resta a cada
     función cuyos tiempos de ejecución se quiere monitorizar el tiempo
     gastado en llamadas a otras funciones presentes también en la
     lista de monitorización. En caso contrario, los tiempos que se
     obtienen para cada función incluyen también los consumidos en
     otras funciones. Nótese que el tiempo consumido en llamadas a
     otras funciones que no están en la lista de monitorización no se
     resta del tiempo total.

     Véanse también `timer' y `timer_info'.


 -- Función: timer_info (<f_1>, ..., <f_n>)
 -- Función: timer_info ()
     Dadas las funciones <f_1>, ..., <f_n>, `timer_info' devuelve una
     matriz con información relativa a los tiempos de ejecución de cada
     una de estas funciones. Sin argumentos, `timer_info' devuelve la
     información asociada a todas las funciones cuyos tiempos de
     ejecución se quiere monitorizar.

     La matriz devuelta por `timer_info' incluye los nombres de las
     funciones, tiempo de ejecución en cada llamada, número de veces
     que ha sido llamada, tiempo total de ejecución y tiempo consumido
     en la recolección de basura, `gctime' (del inglés, "garbage
     collection time") en la versión original de Macsyma, aunque ahora
     toma el valor constante cero.

     Los datos con los que `timer_info' construye su respuesta pueden
     obtenerse también con la función `get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Véase también `timer'.


 -- Función: trace (<f_1>, ..., <f_n>)
 -- Función: trace ()
     Dadas las funciones <f_1>, ..., <f_n>, `trace' imprime información
     sobre depuración cada vez que estas funciones son llamadas;
     `trace(f)$ trace(g)$' coloca de forma acumulativa a `f' y luego a
     `g' en la lista de funciones a ser rastradas.

     Si no se suministran argumentos, `trace' devuelve una lista con
     todas las funciones a ser rastreadas.

     La función `untrace' desactiva el rastreo. Véase también
     `trace_options'.

     La función `trace' no evalúa sus argumentos, de forma que `f(x) :=
     x^2$ g:f$ trace(g)$' no coloca a `f' en la lista de rastreo.

     Cuando una función se redefine es eliminada de la lista de
     rastreo. Así, tras  `timer(f)$ f(x) := x^2$', la función `f'
     dejará de estar en dicha lista.

     Si `timer (f)' está activado, entonces `trace (f)' está
     desactivado, ya que `trace' y `timer' no pueden estar ambos
     activos para la misma función.


 -- Función: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Función: trace_options (<f>)
     Establece las opciones de rastreo para la función <f>. Cualquier
     otra opción previamente especificada queda reemplazada por las
     nuevas. La ejecución de `trace_options (<f>, ...)' no tiene ningún
     efecto, a menos que se haya invocado previamente a `trace (<f>)'
     (es indiferente que esta invocación sea anterior o posterior a
     `trace_options').

     `trace_options (<f>)' inicializa todas las opciones a sus valores
     por defecto.

     Las claves de opciones son:

        * `noprint': No se imprime mensaje alguno ni a la entrada ni a
          la salida de la función.

        * `break': Coloca un punto de referencia antes de que la
          función comience a ejecutarse y otro después de que termine
          su ejecución. Véase `break'.

        * `lisp_print': Muestra los argumentos y valores retornados
          como objetos de Lisp.

        * `info': Imprime `-> true' tanto a la entrada como a la salida
          de la función.

        * `errorcatch': Detecta errores, otorgando la posibilidad de
          marcar un error, reintentar la llamada a la función o
          especificar un valor de retorno.

     Las opciones de rastreo se especifican de dos formas. La única
     presencia de la clave de opción ya activa la opción. (Nótese que
     la opción <foo> no se activa mediante `<foo>: true' u otra forma
     similar; se tendrá en cuenta también que las claves no necesitan
     ir precedidas del apóstrofo.) Especificando la clave de opción
     junto con una función de predicado se hace que la opción quede
     condicionada al predicado.

     La lista de argumentos para las funciones de predicado es siempre
     `[level, direction, function, item]' donde `level' es el nivel de
     recursión para la función,  `direction' puede ser tanto `enter'
     como `exit', `function' es el nombre de la función  y `item' es la
     lista de argumentos (a la entrada) o el valor de retorno (a la
     salida).

     A continuación un ejemplo de opciones de rastreo no condicionales:

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Para la misma función, con la opción `break' condicionada a un
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Función: untrace (<f_1>, ..., <f_n>)
 -- Función: untrace ()
     Dadas las funciones <f_1>, ..., <f_n>, `untrace' desactiva el
     rastreo previamente activado por la función `trace'. Si no se
     aportan argumentos, `untrace' desactiva el rastreo de todas las
     funciones.

     La llamada a `untrace' devuelve una lista con las funciones para
     las que el rastreo se ha desactivado.




Local Variables:
coding: iso-8859-1
End:
