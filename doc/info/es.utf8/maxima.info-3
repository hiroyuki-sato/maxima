This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definiciones para Ecuaciones,  Prev: Ecuaciones,  Up: Ecuaciones

21.1 Definiciones para Ecuaciones
=================================

 -- Variable del sistema: %rnum_list
     Valor por defecto: `[]'

     La variable `%rnum_list' es la lista de variables introducidas en
     las soluciones por la función `algsys'.  Las variables `%r' se
     añaden a `%rnum_list' en su orden de creación. Esto es útil para
     hacer sustituciones en la solución.


 -- Variable opcional: algexact
     Default value: `false'

     El contenido de la variable `algexact' afecta al comportamiento de
     `algsys' de la siguiente forma:

     Si `algexact' vale `true', `algsys' llamará siempre a `solve' y
     luego utilizará `realroots'.

     Si `algexact' vale `false', `solve' será llamada sólo si la
     ecuación no es univariante, o si es cuadrática o bicuadrática.

     Sin embargo, `algexact: true' no garantiza que únicamente se
     obtengan soluciones exactas, ya que aunque `algsys' intente
     siempre dar soluciones exactas, dará resultados aproximados si no
     encuentra una solución mejor.


 -- Función: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Función: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Resuelve el sistema de ecuaciones polinómicas <expr_1>, ...,
     <expr_m> o las ecuaciones <eqn_1>, ..., <eqn_m> para las variables
     <x_1>, ..., <x_n>.  La expresión <expr> equivale a la ecuación
     `<expr> = 0'. Puede haber más ecuaciones que variables o viceversa.

     La función `algsys' devuelve una lista de soluciones, cada una de
     las cuales consistente a su vez en una lista de ecuaciones
     asociando valores a las variables <x_1>, ..., <x_n> que satisfacen
     el sistema de ecuaciones.  Si `algsys' no puede encontrar
     soluciones devuelve la lista vacía `[]'.

     Si es necesario se introducen en la solución los símbolos  `%r1',
     `%r2', ..., para representar parámetros arbitrarios; estas
     variables también se añaden a la lista `%rnum_list'.

     El proceso que se sigue es el siguiente:

     (1) Primero se factorizan las ecuaciones y se reparten en
     subsistemas.

     (2) Para cada subsistema <S_i>, se seleccionan una ecuación <E> y
     una variable <x>. Se elige la variable que tenga grado menor.
     Entonces se calcula el resultado de <E> y <E_j> respecto de <x>,
     siendo las <E_j> el resto de ecuaciones del subsistema <S_i>. De
     aquí se obtiene otro subsistema <S_i'> con una incógnita menos, ya
     que <x> ha sido eliminada. El proceso ahora vuelve al paso (1).

     (3) En ocasiones se obtiene un subsistema consistente en una única
     ecuación. Si la ecuación es multivariante y no se han introducido
     aproximaciones en formato decimal de coma flotante, entonces  se
     llama a `solve' para tratar de encontrar una solución exacta.

     En algunos casos, `solve' no puede encontrar la solución, o si lo
     consigue puede que el resultado tenga una expresión muy grande.

     Si la ecuación tiene una sóla incógnita y es lineal, o cuadrática
     o bicuadrática, entonces se llama a la función `solve' si no se
     han introducido aproximaciones en formato decimal. Si se han
     introducido aproximaciones, o si hay más de una incógnita, o si no
     es lineal, ni cuadrática ni bicuadrática, y si la variables
     `realonly' vale `true', entonces se llama a la función `realroots'
     para calcular las soluciones reales.  Si `realonly' vale `false',
     entonces se llama a `allroots' para obtener las soluciones reales
     y complejas.

     Si `algsys' devuelve una solución que tiene menos dígitos
     significativos de los requeridos, el usuario puede cambiar a
     voluntad el valor de `algepsilon' para obtener mayor precisión.

     Si `algexact' vale `true', se llamará siempre a `solve'.

     Cuando `algsys' encuentra una ecuación con múltiples incógnitas y
     que contiene aproximaciones en coma flotante (normalmente debido a
     la imposibilidad de encontrar soluciones exactas en pasos
     anteriores), entonces no intenta aplicar los métodos exactos a
     estas ecuaciones y presenta el mensaje: "`algsys' cannot solve -
     system too complicated."

     Las interacciones con `radcan' pueden dar lugar a expresiones
     grandes o complicadas. En tal caso, puede ser posible aislar
     partes del resultado con  `pickapart' o `reveal'.

     Ocasionalmente, `radcan' puede introducir la unidad imaginaria
     `%i' en una solución que de hecho es real.

     Ejemplos:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Función: allroots (<expr>)
 -- Función: allroots (<eqn>)
     Calcula aproximaciones numéricas de las raíces reales y complejas
     del polinomio <expr> o ecuación polinómica <eqn> de una variable.

     Si la variable `polyfactor' vale `true' hace que la función
     `allroots' factorice el polinomio para números reales si el
     polinomio es real, o para números complejos si el polinomio es
     complejo.

     La función `allroots' puede dar resultados inexactos en caso de
     que haya raíces múltiples.  Si el polinomio es real, `allroots
     (%i*<p>)') puede alcanzar mejores aproximaciones que `allroots
     (<p>)', ya que `allroots' ejecuta entonces un algoritmo diferente.

     La función `allroots' no opera sobre expresiones no polinómicas,
     pues requiere que el numerador sea reducible a un polinomio y el
     denominador sea, como mucho, un número complejo.

     Para polinomios complejos se utiliza el algoritmo de Jenkins y
     Traub descrito en (Algorithm 419, Comm. ACM, vol. 15, (1972), p.
     97). Para polinomios reales se utiliza el algoritmo de Jenkins
     descrito en (Algorithm 493, ACM TOMS, vol. 1, (1975), p.178).

     Ejemplos:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Variable opcional: breakup
     Valor por defecto: `true'

     Si `breakup' vale `true', `solve' expresa sus soluciones a las
     ecuaciones cúbicas y cuárticas en términos de subexpresiones
     comunes, las cuales son asignadas a etiquetas del tipo `%t1',
     `%t2', etc.  En otro caso, no se identifican subexpresiones
     comunes.

     La asignación `breakup: true' sólo tiene efecto cuando
     `programmode' vale `false'.

     Ejemplos:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Función: dimension (<eqn>)
 -- Función: dimension (<eqn_1>, ..., <eqn_n>)
     El paquete `dimen' es para análisis dimensional. La instrucción
     `load ("dimen")' carga el paquete y `demo ("dimen")' presenta una
     pequeña demostración.


 -- Variable opcional: dispflag
     Valor por defecto: `true'

     Si `dispflag' vale `false', entonces se inhibirá que Maxima
     muestre resultados de las funciones que resuelven ecuaciones
     cuando éstas son llamadas desde dentro de un bloque (`block').
     Cuando un bloque termina con el signo del dólar, $, a la variable
     `dispflag' se le asigna `false'.


 -- Función: funcsolve (<eqn>, <g>(<t>))
     Devuelve `[<g>(<t>) = ...]'  o `[]', dependiendo de que exista o
     no una función racional  `<g>(<t>)' que satisfaga <eqn>, la cual
     debe ser un polinomio de primer orden, lineal para `<g>(<t>)' y
     `<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Aviso: esta es una implemetación rudimentaria, por lo que debe ser
     utilizada con cautela.


 -- Variable opcional: globalsolve
     Valor por defecto: `false'

     Si `globalsolve' vale `true', a las incógnitas de las ecuaciones
     se les asignan las soluciones encontradas por `linsolve' y por
     `solve' cuando se resuelven sistemas de dos o más ecuaciones
     lineales.

     Si `globalsolve' vale `false', las soluciones encontradas por
     `linsolve' y por `solve' cuando se resuelven sistemas de dos o más
     ecuaciones lineales se expresan como ecuaciones y a las incógnitas
     no se le asignan valores.

     Cuando se resuelven ecuaciones que no son sistemas de dos o más
     ecuaciones lineales, `solve' ignora el valor de `globalsolve'.
     Otras funciones que resuelven ecuaciones (como `algsys') ignoran
     siempre el valor de `globalsolve'.

     Ejemplos:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Función: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     El paquete `inteqn' se dedica a la resolución de ecuaciones
     integrales. Para hacer uso de él, ejecutar la instrucción `load
     ("inteqn")'.

     El argumento <ie> es la ecuación integral; <unk> es la función
     incógnita; <tech> es el método a aplicar para efectuar la
     resolución del problema (<tech> = `first' significa: aplica el
     primer método que encuentre una solución; <tech> = `all'
     significa: aplica todos los métodos posibles); <n> es el número
     máximo de términos que debe tomar `taylor', `neumann',
     `firstkindseries' o `fredseries' (también es el máximo nivel de
     recursión para el método de diferenciación); <guess> es la
     solución candidata inicial para `neumann' o `firstkindseries'.

     Valores por defecto para los argumentos segundo a quinto son:

     <unk>: `<p>(<x>)', donde <p> es la primera función desconocida que
     Maxima encuentra en el integrando y <x> es la variable que actúa
     como argumento en la primera aparición de <p> encontrada fuera de
     una integral en el caso de ecuaciones de segunda especie
     (`secondkind'), o es la única variable aparte de la de integración
     en el caso de ecuaciones de primera especie (`firstkind'). Si el
     intento de encontrar <x> falla, el usuario será consultado para
     suministrar una variable independiente.


 -- Variable opcional: ieqnprint
     Valor por defecto: `true'

     La variable `ieqnprint' controla el comportamiento del resultado
     retornado por la instrucción `ieqn'. Si `ieqnprint' vale `false',
     la lista devuelta por la función `ieqn' tiene el formato

     [<solución>, <método utilizado>, <nterms>, <variable>]

     donde <variable> estará ausente si la solución es exacta; en otro
     caso, será la palabra `approximate' o `incomplete' según que la
     solución sea inexacta o que no tenga forma explícita,
     respectivamente. Si se ha utilizado un método basado en series,
     <nterms> es el número de términos utilizado, que puede ser menor
     que el `n' dado a `ieqn'.


 -- Función: lhs (<expr>)
     Devuelve el miembro izquierdo (es decir, el primer argumento) de
     la expresión <expr>, cuando el operador de <expr> es uno de los
     operadores de relación `< <= = # equal notequal >= >', o un
     operadores de asignación `:= ::= : ::', o un operador infijo
     binario definido por el usuario mediante `infix'.

     Si <expr> es un átomo o si su operador es diferente de los citados
     más arriba, `lhs' devuelve <expr>.

     Véase también `rhs'.

     Ejemplo:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Función: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Resuelve la lista de ecuaciones lineales simultáneas para la lista
     de variables. Las expresiones deben ser polinomios lineales
     respecto de las variables o ecuaciones.

     Si `globalsolve' vale `true', a cada incógnita se le asigna el
     valor de la solución encontrada.

     Si `backsubst' vale `false', `linsolve' no hace la sustitución
     tras la triangulariación de las ecuaciones.  Esto puede ser
     necesario en problemas muy grandes en los que la sustitución puede
     dar lugar a la generación de expresiones enormes.

     Si `linsolve_params' vale `true', `linsolve' también genera
     símbolos `%r' para representar parámetros arbitrarios como los
     descritos para la función `algsys'. Si vale `false', el resultado
     devuelto por `linsolve' expresará, si es el sistema es
     indeterminado, unas variables en función de otras.

     Si `programmode' vale `false', `linsolve' muestra la solución con
     etiquetas de expresiones intermedias (`%t') y devuelve las lista
     de etiquetas.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]


 -- Variable opcional: linsolvewarn
     Valor por defecto: `true'

     Si `linsolvewarn' vale `true', `linsolve' mostrará el mensaje:
     "Dependent equations eliminated".


 -- Variable opcional: linsolve_params
     Valor por defecto: `true'

     Si `linsolve_params' vale `true', `linsolve' también genera
     símbolos `%r' para representar parámetros arbitrarios como los
     descritos para la función `algsys'. Si vale `false', el resultado
     devuelto por `linsolve' expresará, si es el sistema es
     indeterminado, unas variables en función de otras.


 -- System variable: multiplicities
     Valor por defecto: `not_set_yet'

     La variable `multiplicities' es una con las multiplicidades de las
     soluciones encontradas por `solve' o `realroots'.


 -- Función: nroots (<p>, <low>, <high>)
     Devuelve el número de raíces reales del polinomio real univariante
     <p> en el intervalo semiabierto `(<low>, <high>]'. Los extremos
     del intervalo pueden ser `minf' o `inf', menos y más infinito.

     La función `nroots' utiliza el método de las secuencias de Sturm.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Función: nthroot (<p>, <n>)
     Siendo `p' un polinomio de coeficientes enteros y `n' un entero
     positivo, `nthroot' devuelve un polinomio `q', también de
     coeficientes enteros, tal que `q^n=p', o un mensaje de error
     indicando que `p' no es una `n'-potencia exacta. Esta función es
     bastante más rápida que `factor' y que `sqfr'.


 -- Variable opcional: programmode
     Valor por defecto: `true'

     Si `programmode' vale `true', `solve', `realroots', `allroots' y
     `linsolve' devuelve sus soluciones como elementos de una lista.
     Si `programmode' vale `false', `solve' y las demás crean
     expresiones intermedias etiquetadas `%t1', `t2', etc., y les
     asinan las soluciones.

          (%i1) solve(x^2+x+1);
                              sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o1)        [x = - --------------, x = --------------]
                                    2                   2
          (%i2) programmode:false$
          (%i3) solve(x^2+x+1);
          Solution:

                                        sqrt(3) %i + 1
          (%t3)                   x = - --------------
                                              2

                                       sqrt(3) %i - 1
          (%t4)                    x = --------------
                                             2
          (%o4)                        [%t4, %t5]


 -- Variable opcional: realonly
     Valor por defecto: `false'

     Si `realonly' vale `true', `algsys' sólo devuelve aquellas
     soluciones exentas de la constante `%i'.


 -- Función: realroots (<poly>, <bound>)
     Encuentra todas las raíces reales del polinomio real univariante
     con la tolerancia especificada por `bound', que si es menor que 1,
     hace que se busquen las raíces enteras de forma exacta. El
     argumento `bound' puede ser arbitrariamente pequeño a fin de
     conseguir la precisión deseada. El primer argumento también puede
     ser una ecuación. La función `realroots' asigna un valor a
     `multiplicities', útil en caso de raíces múltiples. La llamada
     `realroots (<p>)' equivale a `realroots (<p>, rootsepsilon)'. La
     variable `rootsepsilon' es un númeroreal que establece los
     intervalos de confianza para las raíces. Hágase `example
     (realroots)' para ver un ejemplo.


 -- Función: rhs (<expr>)
     Devuelve el miembro derecho (es decir, el segundo argumento) de la
     expresión <expr>, cuando el operador de <expr> es uno de los
     operadores de relación `< <= = # equal notequal >= >', o un
     operadores de asignación `:= ::= : ::', o un operador infijo
     binario definido por el usuario mediante `infix'.

     Si <expr> es un átomo o si su operador es diferente de los citados
     más arriba, `rhs' devuelve <expr>.

     Véase también `lhs'.

     Ejemplo:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Variable opcional: rootsconmode
     Valor por defecto: `true'

     La variable `rootsconmode' controla el comportamiento de la
     instrucción `rootscontract'.  Véase `rootscontract' para más
     detalles.


 -- Función: rootscontract (<expr>)
     Convierte productos de raíces en raíces de productos. Por ejemplo,
     `rootscontract (sqrt(x)*y^(3/2))' devuelve `sqrt(x*y^3)'.

     Si `radexpand' vale `true' y `domain' vale `real', `rootscontract'
     convierte `abs' en `sqrt', por ejemplo, `rootscontract
     (abs(x)*sqrt(y))' devuelve `sqrt(x^2*y)'.

     La opción `rootsconmode' afecta el resultado de `rootscontract'
     como sigue:

          Problema            Valor de         Resultadod de
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     Si `rootsconmode' vale `false', `rootscontract' contrae sólamente
     respecto de exponentes racionales cuyos denominadores sean
     iguales. La clave para los ejemplos `rootsconmode: true' es
     simplemente que 2 divide a 4 pero no a 3. La asignación
     `rootsconmode: all' hace que se calcule el mínimo común múltiplo
     de los denominadores de los exponentes.

     La función `rootscontract' utiliza `ratsimp' de forma similar a
     como lo hace `logcontract'.

     Ejemplos:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0


 -- Variable opcional: rootsepsilon
     Valor por defecto: 1.0e-7

     La variable `rootsepsilon' es la tolerancia que establece el
     intervalo de confianza para las raíces calculadas por la función
     `realroots'.


 -- Función: solve (<expr>, <x>)
 -- Función: solve (<expr>)
 -- Función: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Resuelve la ecuación algebraica <expr> de incógnita <x> y devuelve
     una lista de igualdades con la <x> despejada.  Si <expr> no es una
     igualdad, se supone que se quiere resolver la ecuación `<expr> =
     0'.  El argumento <x> puede ser una función (por ejemplo, `f(x)'),
     u otra expresión no atómica, excepto una suma o producto. Puede
     omitirse <x> si <expr> contiene solamente una variable. El
     argumento <expr> puede ser una expresión racional y puede contener
     funciones trigonométricas, exponenciales, etc.

     Se utiliza el siguiente método de resolución:

     Sea <E> la expresión y <X> la incógnita. Si <E> es lineal respecto
     de <X> entonces <X> se resuelve de forma trivial. En caso
     contrario, si <E> es de la forma `A*X^N + B' entonces el resultado
     es `(-B/A)^1/N)' multiplicado por las `N'-ésimas raíces de la
     unidad.

     Si <E> no es lineal respecto de <X> entonces el máximo común
     divisor de los exponentes de <X> en <E> (supóngase que es <N>) se
     divide entre los exponentes y la multiplicidad de las raíces se
     multiplica por <N>.  Entonces es llamado recursivamente `solve'
     para este resultado. Si <E> es factorizable entonces `solve' es
     invocado para cada uno de los factores.  Finalmente, `solve'
     usará, según sea necesario, las fórmulas cuadrática, cúbica o
     cuártica.

     En caso de que <E> sea un polinomio respecto de una función de la
     incógnita, por ejemplo `F(X)', entonces se calcula primero para
     `F(X)' (sea <C> el resultado obtenido), entonces la ecuación
     `F(X)=C' se resuelve para <X> en el supuesto que se conozca la
     inversa de la función <F>.

     Si la variable `breakup' vale `false' hará que `solve' muestre las
     soluciones de las ecuaciones cúbicas o cuárticas como expresiones
     únicas, en lugar de utilizar varias subexpresiones comunes, que es
     el formato por defecto.

     A la variable `multiplicities' se le asignará una lista con las
     multiplicidades de las soluciones individuales devueltas por
     `solve', `realroots' o `allroots'. La instrucción `apropos
     (solve)' hará que se muestren las variables optativas que de algún
     modo afectan al comportamiento de `solve'. Se podrá luego utilizar
     la función  `describe' para aquellas variables cuyo objeto no esté
     claro.

     La llamada `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])'
     resuelve un sistema de ecuaciones polinómicas simultáneas
     (lineales o no) llamando a `linsolve' o `algsys' y devuelve una
     lista de listas con soluciones para las incógnitas. En caso de
     haberse llamado a `linsolve' esta lista contendrá una única lista
     de soluciones. La llamada a `solve' tiene dos listas como
     argumentos. La primera lista tiene las ecuaciones a resolver y la
     segunda son las incógnitas cuyos valores se quieren calcular. Si
     el número de variables en las ecuaciones es igual al número de
     incógnitas, el segundo argumento puede omitirse. En caso de
     sistemas lineales incompatibles se mostrará el mensaje
     `inconsistent' (véase la variable `solve_inconsistent_error'); si
     no existe una única solución, se mostrará el mensaje `singular'.

     Si `programmode' vale `false', `solve' muestra la solución con
     etiquetas de expresiones intermedias (`%t') y devuelve las lista
     de etiquetas.

     Si `globalsolve' vale `true' y el problema consiste en resolver un
     sistema de dos o más ecuaciones lineales, a cada incógnita se le
     asigna el valor encontrado en la resolución del sistema.

     Ejemplos:
          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0


 -- Variable opcional: solvedecomposes
     Valor por defecto: `true'

     Si `solvedecomposes' vale `true', `solve' llama a `polydecomp' en
     caso de que se le pida resolver ecuaciones polinómicas.


 -- Variable opcional: solveexplicit
     Valor por defecto: `false'

     Si `solveexplicit' vale `true', le inhibe a `solve' devolver
     soluciones implícitas, esto es, soluciones de la forma `F(x) = 0',
     donde `F' es cierta función.


 -- Variable opcional: solvefactors
     Valor por defecto: `true'

     Si `solvefactors' vale `false', `solve' no intenta factorizar la
     expresión.  Este valor `false' puede ser útil en algunos casos en
     los que la factorización no es necesaria.


 -- Variable opcional: solvenullwarn
     Valor por defecto: `true'

     Si `solvenullwarn' vale `true',  `solve' muestra un mensaje de
     aviso si es llamado con una lista de ecuaciones vacía o con una
     lista de incógnitas vacía. Por ejemplo, `solve ([], [])' imprimirá
     dos mensajes de aviso y devolverá `[]'.


 -- Variable opcional: solveradcan
     Valor por defecto: `false'

     Si `solveradcan' vale `true', `solve' llama a `radcan', lo que
     hará que `solve' se ejecute de forma más lenta, pero permitirá que
     se resuelvan ciertas ecuaciones que contengan exponenciales y
     logaritmos.


 -- Variable opcional: solvetrigwarn
     Valor por defecto: `true'

     Si `solvetrigwarn' vale `true', `solve' puede presentar un mensaje
     diciendo que está utilizando funciones trigonométricas inversas
     para resolver la ecuación, y que por lo tanto puede estar
     ignorando algunas soluciones.


 -- Variable opcional: solve_inconsistent_error
     Valor por defecto: `true'

     Si `solve_inconsistent_error' vale `true', `solve' y `linsolve'
     devuelven un error si las ecuaciones a resolver son incompatibles.
     Si vale `false', `solve' y `linsolve' devuelven la lista vacía
     `[]' en caso de incompatibilidad.

     Ejemplo:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equations:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []



File: maxima.info,  Node: Ecuaciones Diferenciales,  Next: Métodos numéricos,  Prev: Ecuaciones,  Up: Top

22 Ecuaciones Diferenciales
***************************

* Menu:

* Definiciones para Ecuaciones Diferenciales::


File: maxima.info,  Node: Definiciones para Ecuaciones Diferenciales,  Prev: Ecuaciones Diferenciales,  Up: Ecuaciones Diferenciales

22.1 Definiciones para Ecuaciones Diferenciales.
================================================

 -- Función: bc2 (<soluc>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resuelve el problema del valor en la frontera para ecuaciones
     diferenciales de segundo orden.  Aquí, <soluc> es una solución
     general de la ecuación, como las que calcula `ode2', <xval1> es
     una ecuación de la forma `<x> = <x0>' para la variable
     independiente y <yval1> es una ecuación de la forma `<y> = <y0>'
     para la variable dependiente.  Los argumentos <xval2> y <yval2>
     son ecuaciones a verificar por estas mismas variables en otro
     punto. Véase `ode2' para un ejemplo sobre su utilización.


 -- Función: desolve (<ecu>, <x>)
 -- Función: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     La función `dsolve' resuelve sistemas de ecuaciones diferenciales
     ordinarias lineales utilizando la transformada de Laplace.  Aquí
     las <eqi> (`i'=1,..,n) son ecuaciones diferenciales con variables
     dependientes <x_1>, ..., <x_n>. Las relaciones funcionales deben
     indicarse explícitamente tanto para las ecuaciones como para las
     variables. Por ejemplo,

          'diff(f,x,2)=sin(x)+'diff(g,x);
          'diff(f,x)+x^2-f=2*'diff(g,x,2);

     no es el formato apropiado. El método correcto es

          'diff(f(x),x,2)=sin(x)+'diff(g(x),x);
          'diff(f(x),x)+x^2-f=2*'diff(g(x),x,2);

     La llamada a la función debe ser entonces
     `desolve([%o3,%o4],[f(x),g(x)]);' .

     Si las condiciones iniciales en 0 son conocidas, deben ser
     suministradas antes de llamar a `desolve' haciendo uso previo de
     la función `atvalue',

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Si `desolve' no encuentra una solución, entonces devuelve `false'.


 -- Función: ic1 (<soluc>, <xval>, <yval>)
     Resuelve el problema del valor inicial en ecuaciones diferenciales
     de primer orden.  Aquí, <soluc> es una solución general de la
     ecuación, como las que calcula `ode2', <xval> es una ecuación de
     la forma `<x> = <x0>' para la variable independiente y <yval> es
     una ecuación de la forma `<y> = <y0>' para la variable
     dependiente. Véase `ode2' para un ejemplo sobre su utilización.


 -- Función: ic2 (<soluc>, <xval>, <yval>, <dval>)
     Resuelve el problema del valor inicial en ecuaciones diferenciales
     de segundo orden.  Aquí, <soluc> es una solución general de la
     ecuación, como las que calcula `ode2', <xval> es una ecuación de
     la forma `<x> = <x0>' para la variable independiente y <yval> es
     una ecuación de la forma `<y> = <y0>' para la variable
     dependiente, siendo <dval> una ecuación para la derivada de la
     variable dependiente respecto de la independiente en el punto
     <xval>. Véase `ode2' para un ejemplo sobre su utilización.


 -- Función: ode2 (<ecu>, <dvar>, <ivar>)
     La función `ode2' resuelve ecuaciones diferenciales ordinarias de
     primer y segundo orden. Admite tres argumentos: una ecuación
     diferencial ordinaria <ecu>, la variable dependiente <dvar> y la
     variable independiente <ivar>.  Si ha tenido éxito en la
     resolución de la ecuación, devuelve una solución, explícita o
     implícita, para la variable dependiente. El símbolo `%c' se
     utiliza para representar la constante en el caso de ecuaciones de
     primer orden y los símbolos `%k1' y `%k2' son las constantes de
     las ecuaciones de segundo orden. Si por cualquier razón `ode2' no
     puede calcular la solución, devolverá `false', acompañado quizás
     de un mensaje de error. Los métodos utilizados para las ecuaciones
     de primer orden, en el orden en que se hace la tentativa de
     resolución son: lineal, separable, exacto (pudiendo solicitar en
     este caso un factor de integración), homogéneo, ecuación de
     Bernoulli y un método homogéneo generalizado. Para las ecuaciones
     de segundo orden: coeficiente constante, exacto, homogéneo lineal
     con coeficientes no constantes  que pueden ser transformados en
     coeficientes constantes, ecuación equidimensional o de Euler,
     método de variación de parámetros y ecuaciones exentas de las
     variables dependientes o independientes de manera que se puedan
     reducir a dos ecuaciones lineales de primer a ser resueltas
     secuencialmente. Durante el proceso de resolución de ecuaciones
     diferenciales ordinarias, ciertas variables se utilizan con el
     único propósito de suministrar información al usuario: `method'
     almacena el método utilizado para encontrar la solución (como por
     ejemplo `linear'), `intfactor' para el factor de integración que
     se haya podido utilizar, `odeindex' para el índice del método de
     Bernoulli o el homogéneo generalizado y `yp' para la solución
     particular del método de variación de parámetros.

     A fin de resolver problemas con valores iniciales y problemas con
     valores en la frontera, la función `ic1' está disponible para
     ecuaciones de primer orden y las funciones `ic2' y `bc2' para
     problemas de valores iniciales y de frontera, respectivamente, en
     el caso de las ecuaciones de segundo orden.

     Ejemplo:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Métodos numéricos,  Next: Estadística,  Prev: Ecuaciones Diferenciales,  Up: Top

23 Métodos numéricos
********************

* Menu:

* Introducción a los métodos numéricos::
* Series de Fourier::
* Definiciones para los métodos numéricos::
* Definiciones para las series de Fourier::


File: maxima.info,  Node: Introducción a los métodos numéricos,  Next: Series de Fourier,  Prev: Métodos numéricos,  Up: Métodos numéricos

23.1 Introducción a los métodos numéricos
=========================================


File: maxima.info,  Node: Series de Fourier,  Next: Definiciones para los métodos numéricos,  Prev: Introducción a los métodos numéricos,  Up: Métodos numéricos

23.2 Series de Fourier
======================

El paquete `fft' contiene funciones para el cálculo numérico (no
simbólico) de la transformada rápida de Fourier. La instrucción `load
("fft")' carga el paquete. Véase `fft'.

   El paquete `fourie' contiene funciones para el cálculo simbólico de
series de Fourier. La instrucción `load ("fourie")' carga el paquete.
Hay funciones en el paquete `fourie' para calcular los coeficientes de
Fourier y para la transformación de expresiones. Véase `Definiciones
para las series de Fourier'.


File: maxima.info,  Node: Definiciones para los métodos numéricos,  Next: Definiciones para las series de Fourier,  Prev: Series de Fourier,  Up: Métodos numéricos

23.3 Definiciones para los métodos numéricos
============================================

 -- Función: polartorect (<magnitude_array>, <phase_array>)
     Transforma valores complejos de la forma `r %e^(%i t)' a la forma
     `a + b %i'. La instrucción `load ("fft")' carga esta función en
     Maxima. Véase también `fft'.

     El módulo y la fase, `r' y `t', se toman de <magnitude_array> y
     <phase_array>, respectivamente. Los valores originales de los
     arreglos de entrada se reemplazan por las partes real e
     imaginaria, `a' y `b'. Los resultados se calculan como

          a: r cos (t)
          b: r sin (t)

     Los arreglos de entrada deben ser de igual tamaño y de dimensión
     1. El tamaño del arreglo no necesita ser potencia de 2.

     La función `polartorect' es la inversa de  `recttopolar'.


 -- Función: recttopolar (<real_array>, <imaginary_array>)
     Transforma valores complejos de la forma `a + b %i' a la forma `r
     %e^(%i t)'. La instrucción `load ("fft")' carga esta función en
     Maxima. Véase también `fft'.

     Las partes real e imaginaria, `a' y `b', se toman de <real_array>
     y <imaginary_array>, respectivamente. Los valores originales de
     los arreglos de entrada se reemplazan por el módulo y el
     argumento, `r' y `t'. Los resultados se calculan como

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     El ángulo calculado está en el rango entre `-%pi' y `%pi'.

     Los arreglos de entrada deben ser de igual tamaño y de dimensión
     1. El tamaño del arreglo no necesita ser potencia de 2.

     La función `recttopolar' es la inversa de `polartorect'.


 -- Función: ift (<real_array>, <imaginary_array>)
     Tranformada discreta inversa de Fourier. La instrucción `load
     ("fft")' carga esta función en Maxima.

     La función `ift' calcula la transformada rápida inversa compleja
     de Fourier de arreglos unidimensionales de números decimales en
     coma flotante. La transformada inversa se define como

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Véase `fft' para más detalles.


 -- Función: fft (<real_array>, <imaginary_array>)
 -- Función: ift (<real_array>, <imaginary_array>)
 -- Función: recttopolar (<real_array>, <imaginary_array>)
 -- Función: polartorect (<magnitude_array>, <phase_array>)
     Transformada rápida de Fourier y funciones asociadas. La
     instrucción `load ("fft")' carga estas funciones en Maxima.

     Las funciones `fft' y `ift' calculan la transformada rápida
     compleja de Fourier y su inversa de arreglos unidimensionales de
     números decimales en coma flotante. El tamaño de <imaginary_array>
     debe ser igual al de <real_array>.

     Los resultados devueltos por las funciones `fft' y `ift'
     sustituyen al contenido original de los arreglos de entrada. La
     función `fillarray' puede hacer una copia de un array en caso de
     ser necesario.

     La transformada discreta de Fourier y la transformada inversa se
     definen como sigue. Sea `x' el arreglo con los datos originales,
     con

          x[i]: real_array[i] + %i imaginary_array[i]

     Sea `y' el arreglo con los datos transformados. Las transformadas
     directa e inversa son

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Arreglos apropiados se pueden preparar con la función `array'. Por
     ejemplo:

          array (my_array, float, n-1)$

     declara un arreglo unidimensional con `n' elementos, indexado de 0
     a n-1, ambos inclusive. El número de elementos, `n', debe ser par.

     La función `fft' se puede aplicar a datos reales (con partes
     imaginarias nulas) para obtener coeficientes seno y coseno.
     Después de llamar a la función `fft', los coeficientes del seno y
     coseno, llamémosles `a' y `b', se pueden calcular como

          a[0]: real_array[0]
          b[0]: 0

     y

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     para j tomando valores de 1 a n/2-1, y

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     La función `recttopolar' transforma valores complejos de la forma
     `a + b %i' a la forma `r %e^(%i t)'. Véase `recttopolar'.

     La función `polartorect' transforma valores complejos de la forma
     `r %e^(%i t)' a la forma `a + b %i'. Véase `polartorect'.

     La instrucción `demo ("fft")' presenta una demostarción del
     paquete `fft'.


 -- Variable opcional: fortindent
     Valor por defecto: 0

     La variable `fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción `fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos
     harán que las expresiones se escriban más a la derecha.


 -- Función: fortran (<expr>)
     Escribe <expr> en código Fortran. La salida se escribe con
     márgenes, y si ésta es demasiado larga `fortran' sigue escribiendo
     en líneas sucesivas. La función `fortran' escribe el operador de
     exponenciación `^' como `**', e imprime un número complejo `a + b
     %i' como `(a,b)'.

     El argumento <expr> puede ser una ecuación. En tal caso, `fortran'
     escribe una sentencia de asignación, dándole el valor del miembro
     derecho de la expresión al miembro izquierdo. En particular, si el
     miembro derecho de <expr> es el nombre de una matriz, entonces
     `fortran' escribe una sentencia de asignación para cada elemento
     de la matriz.

     Si <expr> no es reconozida por `fortran', la expresión se escribe
     en formato `grind' sin avisos. La función `fortran' no reconoce
     listas, arreglos ni funciones.

     La variable `fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción `fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos
     harán que las expresiones se escriban más a la derecha.

     Si `fortspaces' vale `true', `fortran' rellena las líneas con
     espacios de 80 columnas.

     La función `fortran' evalúa sus argumentos; un argumento precedido
     de apóstrofo previene de la evaluación.  La función `fortran'
     siempre devuelve `done'.

     Ejemplos:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done


 -- Variable opcional: fortspaces
     Valor por defecto: `false'

     Si `fortspaces' vale `true', `fortran' rellena las líneas con
     espacios de 80 columnas.


 -- Función: horner (<expr>, <x>)
 -- Función: horner (<expr>)
     Cambia el formato de <expr> según la regla de Horner utilizando
     <x> como variable principal, si ésta se especifica. El argumento
     `x' se puede omitir, en cuyo caso se considerará como variable
     principal la de <expr> en su formato racional canónico (CRE).

     La función `horner' puede mejorar las estabilidad si `expr' va a
     ser numéricamente evaluada. También es útil si Maxima se utiliza
     para generar programas que serán ejecutados en Fortran. Véase
     también `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Función: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Función: find_root (<f>, <a>, <b>)
     Calcula el cero de la función <f> cuando <x> varía en el rango
     `[<a>, <b>]'.  La función debe tener signos diferentes en los
     extremos del intervalo. Si esta condición no se cumple, la acción
     de esta función la gobierna la variable `find_root_error'.  Si
     `find_root_error' vale `true' entonces se emite un mensaje de
     error, en otro caso se devuelve el valor de `find_root_error'. En
     caso contrario, dado que Maxima pouede evaluar el primer argumento
     en el rango especificado, el cual es continuo, está garantizado
     que `find_root' encontrará el cero buscado (o uno de ellos en caso
     de haber varios). La precisión de `find_root' está gobernada por
     `find_root_abs' y `find_root_rel', que deben ser números no
     negativos en coma flotante. La función `find_root' se detendrá
     cuando el primer argumento tome un valor menor o igual que
     `find_root_abs', o cuando sucesivas aproximaciones de la raíz se
     diferencien en menos de `find_root_rel * <one of the
     approximants>'. El valor por defecto de `find_root_abs' y
     `find_root_rel' es 0.0 en ambos casos, de forma que `find_root'
     obtiene la mejor aproximación posible para la aritmética de simple
     precisión de que se dispone. El primer argumento puede ser una
     ecuación. La ordenación de los dos últimos argumentos es
     irrelevante. Así,

          find_root (sin(x) = x/2, x, %pi, 0.1);

     equivale a

          find_root (sin(x) = x/2, x, 0.1, %pi);

     El método que se aplica es una búsqueda binaria en el rango
     especificado por los dos últimos argumentos. Cuando el algoritmo
     considera que la función está lo suficientemente cerca de ser
     lineal, comienza a utilizar interpolación lineal.

     Ejemplos:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981


 -- Variable opcional: find_root_abs
     Valor por defecto: 0.0

     La variable `find_root_abs' es la precisión de la instrucción
     `find_root', cuyo comportamiento lo controlan `find_root_abs' y
     `find_root_rel', variables que deben guardar dos números no
     negativos decimales en coma flotante.  La función `find_root'
     parará cuando su primer argumento tome un valor menor o igual que
     `find_root_abs' o si sucesivas aproximaciones a la raíz difieren
     entre sí en no más de `find_root_rel * <one of the approximants>'.
     El valor por defecto de `find_root_abs' y `find_root_rel' es 0.0
     en ambos casos, de forma que `find_root' obtiene la mejor
     aproximación posible para la aritmética de simple precisión de que
     se dispone.


 -- Variable opcional: find_root_error
     Valor por defecto: `true'

     La variable `find_root_error' controla el comportamiento de
     `find_root'.  Cuando se llama a la función `find_root', ésta
     determina si la función a ser resuelta satisface la condición de
     que sus valores en los extremos de los intervalos tengan signos
     diferentes. Si son de signo opuesto, se procede a la
     interpolación. Si son del mismo signo, y `find_root_error' vale
     `true', entonces se señala un error. Si son del mismo signo y
     `find_root_error' no vale `true', retornará el valor de
     `find_root_error'.


 -- Variable opcional: find_root_rel
     Valor por defecto: 0.0

     La variable `find_root_rel' es la precisión de la instrucción
     `find_root', cuyo comportamiento lo controlan `find_root_abs' y
     `find_root_rel', variables que deben guardar dos números no
     negativos decimales en coma flotante.  La función `find_root'
     parará cuando su primer argumento tome un valor menor o igual que
     `find_root_abs' o si sucesivas aproximaciones a la raíz difieren
     entre sí en no más de `find_root_rel * <one of the approximants>'.
     El valor por defecto de `find_root_abs' y `find_root_rel' es 0.0
     en ambos casos, de forma que `find_root' obtiene la mejor
     aproximación posible para la aritmética de simple precisión de que
     se dispone.



File: maxima.info,  Node: Definiciones para las series de Fourier,  Prev: Definiciones para los métodos numéricos,  Up: Métodos numéricos

23.4 Definiciones para las series de Fourier
============================================

 -- Función: equalp (<x>, <y>)
     Devuelve `true' si `equal (<x>, <y>)', en otro caso devuelve
     `false'. No devuelve el mensaje de error que se obtiene de  `equal
     (x, y)' en un caso como éste.


 -- Función: remfun (<f>, <expr>)
 -- Función: remfun (<f>, <expr>, <x>)
     La llamada `remfun (<f>, <expr>)' reemplaza todas las
     subexpresiones `<f> (<arg>)' por <arg> en <expr>.

     La llamada `remfun (<f>, <expr>, <x>)' reemplaza todas las
     subexpresiones `<f> (<arg>)' por <arg> en <expr> sólo si <arg>
     contiene a la variable <x>.


 -- Función: funp (<f>, <expr>)
 -- Función: funp (<f>, <expr>, <x>)
     La llamada `funp (<f>, <expr>)' devuelve `true' si <expr> contiene
     la función <f>.

     La llamada `funp (<f>, <expr>, <x>)' devuelve `true' si <expr>
     contiene la función <f> y la variable <x> está presente en el
     argumento de alguna de las presencias de <f>.


 -- Función: absint (<f>, <x>, <halfplane>)
 -- Función: absint (<f>, <x>)
 -- Función: absint (<f>, <x>, <a>, <b>)
     La llamada `absint (<f>, <x>, <halfplane>)' devuelve la integral
     indefinida de <f> con respecto a <x> en el semiplano dado (`pos',
     `neg' o `both'). La función <f> puede contener expresiones de la
     forma `abs (x)', `abs (sin (x))', `abs (a) * exp (-abs (b) * abs
     (x))'.

     La llamada `absint (<f>, <x>)' equivale a `absint (<f>, <x>, pos)'.

     La llamada `absint (<f>, <x>, <a>, <b>)' devuelve la integral
     definida de <f> con respecto a  <x> de <a> a <b>.


 -- Función: fourier (<f>, <x>, <p>)
     Devuelve una lista con los coeficientes de Fourier de `<f>(<x>)'
     definida en el intervalo `[-%pi, %pi]'.


 -- Función: foursimp (<l>)
     Simplifica `sin (n %pi)' a 0 si `sinnpiflag' vale `true' y `cos (n
     %pi)' a `(-1)^n' si `cosnpiflag' vale `true'.


 -- Variable opcional: sinnpiflag
     Valor por defecto: `true'

     Véase `foursimp'.


 -- Variable opcional: cosnpiflag
     Valor por defecto: `true'

     Véase `foursimp'.


 -- Función: fourexpand (<l>, <x>, <p>, <limit>)
     Calcula y devuelve la serie de Fourier a partir de la lista de los
     coeficientes de Fourier <l> hasta el término <limit> (<limit>
     puede ser `inf'). Los argumentos <x> y <p> tienen el mismo
     significado que en `fourier'.


 -- Función: fourcos (<f>, <x>, <p>)
     Devuelve los coeficientes de los cosenos de Fourier de `<f>(<x>)'
     definida en `[0, %pi]'.


 -- Función: foursin (<f>, <x>, <p>)
     Devuelve los coeficientes de los senos de Fourier de `<f>(<x>)'
     definida en `[0, %pi]'.


 -- Función: totalfourier (<f>, <x>, <p>)
     Devuelve `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>,
     <p>, 'inf)'.


 -- Función: fourint (<f>, <x>)
     Calcula y devuelve la lista de los coeficientes integrales de
     Fourier de `<f>(<x>)' definida en `[minf, inf]'.


 -- Función: fourintcos (<f>, <x>)
     Devuelve los coeficientes integrales de los cosenos  `<f>(<x>)' en
     `[0, inf]'.


 -- Función: fourintsin (<f>, <x>)
     Devuelve los coeficientes integrales de los senos  `<f>(<x>)' en
     `[0, inf]'.



File: maxima.info,  Node: Estadística,  Next: Arrays,  Prev: Métodos numéricos,  Up: Top

24 Estadística
**************

* Menu:

* Definiciones para Estadística::


File: maxima.info,  Node: Definiciones para Estadística,  Prev: Estadística,  Up: Estadística

24.1 Definiciones para Estadística
==================================

 -- Función: gauss (<n>, <s>)
     Devuelve un número decimal seudoaleatorio en coma flotante con
     distribución normal de media <n> y desviación típica <s>.



File: maxima.info,  Node: Arrays,  Next: Matrices y Álgebra Lineal,  Prev: Estadística,  Up: Top

25 Arrays
*********

* Menu:

* Definiciones para Arrays::


File: maxima.info,  Node: Definiciones para Arrays,  Prev: Arrays,  Up: Arrays

25.1 Definiciones para Arrays
=============================

 -- Función: array (<nombre>, <dim_1>, ..., <dim_n>)
 -- Función: array (<nombre>, <type>, <dim_1>, ..., <dim_n>)
 -- Función: array ([<nombre_1>, ..., <nombre_m>], <dim_1>, ...,
          <dim_n>)
     Crea un array de dimensión n, que debe ser menor o igual que 5.
     Los subíndices de la i-ésima dimensión son enteros que toman
     valores entre 0 y <dim_i>.

     La llamada `array (<nombre>, <dim_1>, ..., <dim_n>)' crea un array
     de tipo general.

     La llamada `array (<nombre>, <type>, <dim_1>, ..., <dim_n>)' crea
     un array con sus elementos del tipo especificado. El tipo <type>
     puede ser `fixnum' para enteros de tamaño limitado o `flonum' para
     números decimales en coma flotante.

     La llamada `array ([<nombre_1>, ..., <nombre_m>], <dim_1>, ...,
     <dim_n>)' crea m arrays,  todos ellos de igual dimensión.

     Si el usuario asigna un valor a una variable subindicada antes de
     declarar el array correspondiente, entonces se construye un array
     no declarado. Los arrays no declarados, también conocidos por el
     nombre de "arrays de claves" (hashed arrays), son más generales
     que los arrays declarados. El usuario no necesita declarar su
     tamaño máximo y pueden ir creciendo de forma dinámica. Los
     subíndices de los arrays no declarados no necesitan ser
     necesariamente números. Sin embargo, a menos que un array tenga
     sus elementos dispersos, probablemente sea más eficiente
     declararlo siempre que sea posible antes que dejarlo como no
     declarado. La función `array' puede utilizarse para transformar un
     array no declarado a a uno declarado.


 -- Función: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Evalúa `<A> [<i_1>, ..., <i_n>]', donde <A> es un array y <i_1>,
     ..., <i_n> son enteros.

     Esto es como `apply', excepto por el hecho de que el primer
     argumento es un array en lugar de una función.


 -- Función: arrayinfo (<A>)
     Devuelve información sobre el array<A>.  El argumento <A> puede
     ser un array declarado o no declarado, una función array o una
     función subindicada.

     En el caso de arrays declarados, `arrayinfo' devuelve una lista
     que contiene el átomo `declared', el número de dimensiones y el
     tamaño de cada dimensión.  Los elementos del array, tanto los que
     tienen valores asignados como los que no, son devueltos por
     `listarray'.

     En el caso de arrays no declarados (hashed arrays), `arrayinfo'
     devuelve una lista que contiene el átomo `hashed', el número de
     subíndices y los subíndices de aquellos elementos que guarden un
     valor. Los valores son devueltos por `listarray'.

     En el caso de funciones array, `arrayinfo' devuelve una lista que
     contiene el átomo `hashed', el número de subíndices y los
     subíndices para los que la función tiene valores almacenados.  Los
     valores almacenados de la función array son devueltos por
     `listarray'.

     En el caso de funciones subindicadas, `arrayinfo' devuelve una
     lista que contiene el átomo `hashed', el número de subíndices y
     los subíndices para los que hay expresiones lambda.  Las
     expresiones lambda son devueltas por `listarray'.

     Ejemplos:

     `arrayinfo' y `listarray' aplicadas a una array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     `arrayinfo' y `listarray' aplicadas a una array no declarado
     (hashed arrays).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     `arrayinfo' y `listarray' aplicadas a una función array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     `arrayinfo' y `listarray' aplicadas a una función subindicada.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]


 -- Función: arraymake (<name>, [<i_1>, ..., <i_n>])
     Devuelve la expresión `<name> [<i_1>, ..., <i_n>]'.

     Esta función es similar a `funmake', excepto que el valor
     retornado es referencia a un array no evaluado, en lugar de una
     llamada a una función no evaluada.


 -- Variable del sistema: arrays
     Valor por defecto: `[]' La variable `arrays' es una lista con
     todos los arrays que han sido alojados, lo que comprende a los
     arrays declarados por `array', a los no declarados (hashed arrays)
     construidos implícitamente (asignando algo al elemento de un
     array) y a las funciones array definidas mediante `:=' y `define'.
     Los arrays definidos mediante `make_array' no se incluyen en este
     grupo.

     Véanse también `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray' y `rearray'.

     Ejemplos:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]


 -- Función: bashindices (<expr>)
     Transforma la expresión <expr> dándole a cada suma y producto un
     único índice. Esto le da a `changevar' mayor precisión cuando
     opera con sumas y productos. La forma del único índice es
     `j<number>'. La cantidad <number> se determina en función de
     `gensumnum', valor que puede cambiar el usuario.  Por ejemplo,
     haciendo `gensumnum:0$'.


 -- Función: fillarray (<A>, <B>)
     Rellena el array <A> con los valores de <B>, que puede ser una
     lista o array.

     Si <A> es un array de números decimales en coma flotante (enteros)
     entonces <B> debe ser o bien una lista de números decimales en
     coma flotante  (enteros), o bien otro array de números en coma
     flotante (enteros).

     Si las dimensiones de los areglos son diferentes, <A> se rellena
     según el orden de las filas. Si no hay suficientes elementos en
     <B> el último elemento se utiliza para cubrir el resto de <A>. Si
     hay demasiados, los elementos sobrantes son ignorados.

     La función `fillarray' devuelve su primer argumento.


 -- Función: listarray (<A>)
     Devuelve una lista con los elementos del array <A>.  El argumento
     <A> puede ser un array declarado o no declarado, una función array
     o una función subindicada.

     Los elementos se ordenan en primera instancia respecto del primer
     índice, después respecto del segundo índice y así sucesivamente.
     La ordenación de los índices es la misma que la establecida por
     `orderless'.

     En el caso de arrays no declarados, funciones array y funciones
     subindicadas, los elementos corresponden a los índices devueltos
     por `arrayinfo'.

     Los elementos de los arrays declarados que no tienen valores
     asignados (excepto `fixnum' y `flonum') se devuelven como `#####'.
     Los elementos sin valores asignados de los arrays `fixnum' y
     `flonum' son devueltos como 0 y 0.0, respectivamente.  Los
     elementos sin valor asignado de los arrays no declarados,
     funciones array y funciones subindicadas no son devueltos.

     Ejemplos:

     `listarray' y `arrayinfo' aplicadas a un array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     `listarray' y `arrayinfo' aplicadas a un array no declarado
     (hashed array).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     `listarray' y `arrayinfo' aplicadas a una función array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     `listarray' y `arrayinfo' aplicadas a una función subindicada.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]


 -- Función: make_array (<tipo>, <dim_1>, ..., <dim_n>)
     Construye y devuelve un array de Lisp. El argumento <tipo> puede
     ser  `any', `flonum', `fixnum', `hashed' o `functional'. Hay n
     índices, y el índice i-ésimo va de  0 a <dim_i> - 1.

     La ventaja de `make_array' sobre `array' estriba en que el valor
     retornado no tiene nombre, y una vez que un puntero deja de
     referenciarlo, el valor desaparece. Por ejemplo, si `y: make_array
     (...)' entonces `y' apunta a un objeto que ocupa cierto espacio en
     la memoria, pero después de `y: false', `y' ya no apunta al
     objeto, por lo que éste puede ser considerado basura y
     posteriormente eliminado.


 -- Función: rearray (<A>, <dim_1>, ..., <dim_n>)
     Cambia las dimensiones de un array. El nuevo array será rellenado
     con los elementos del viejo según el orden de las filas. Si el
     array antiguo era demasiado pequeño, los elementos restantes se
     rellenan con `false', `0.0' o `0', dependiendo del tipo del array.
     El tipo del array no se puede cambiar.


 -- Función: remarray (<A_1>, ..., <A_n>)
 -- Función: remarray (all)
     Borra los arrays y las funciones relacionadas con ellos, liberando
     el espacio de memoria ocupado.  Los argumentos pueden ser arrays
     declarados, arrays no declarados (hashed arrays), funciones array
     y funciones subindicadas.

     La llamada `remarray (all)' borra todos los elementos de la lista
     global `arrays'.

     La función `remarray' devuelve la lista de los arrays borrados.


 -- Función: subvar (<x>, <i>)
     Evalúa la expresión subindicada `<x>[<i>]'.

     La función `subvar' evalúa sus argumentos.

     La instrucción `arraymake (<x>, [<i>]' construye la expresión
     `<x>[<i>]', pero no la evalúa.

     Ejemplos:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc


 -- Variable opcional: use_fast_arrays
     Valor por defecto: `false'

     Si `use_fast_arrays' vale `true' entonces tan solo se reconocen
     dos tipos de arrays.



File: maxima.info,  Node: Matrices y Álgebra Lineal,  Next: Afines,  Prev: Arrays,  Up: Top

26 Matrices y Álgebra Lineal
****************************

* Menu:

* Introducción a las Matrices y al Álgebra Lineal::
* Definiciones para las Matrices y el Álgebra Lineal::


File: maxima.info,  Node: Introducción a las Matrices y al Álgebra Lineal,  Next: Definiciones para las Matrices y el Álgebra Lineal,  Prev: Matrices y Álgebra Lineal,  Up: Matrices y Álgebra Lineal

26.1 Introducción a las Matrices y al Álgebra Lineal
====================================================

* Menu:

* Operador punto::
* Vectores::
* Paquete eigen::


File: maxima.info,  Node: Operador punto,  Next: Vectores,  Prev: Introducción a las Matrices y al Álgebra Lineal,  Up: Introducción a las Matrices y al Álgebra Lineal

26.1.1 Operador punto
---------------------

El operador  `.' realiza la multiplicación matricial y el producto
escalar.  Cuando los operandos son dos matrices columna o matrices fila
`a' y `b', la expresión `a.b' es equivalente a `sum (a[i]*b[i], i, 1,
length(a))'.  Si `a' y `b' no son complejos, estamos en el caso del
producto escalar.  En caso de ser `a' y `b' vectores en el campo
complejo, el producto escalar se define como `conjugate(a).b'; la
función `innerproduct' del paquete `eigen' realiza el producto escalar
complejo.

   Cuando los operandos son matrices de índole más general, el
resultado que se obtiene es el producto matricial de `a' por `b'.  El
número de filas de `b' debe ser igual al número de columnas de `a', y
el resultado tiene un número de filas igual al de `a' y un número de
columnas igual al de `b'.

   Al objeto de distinguir `.' como operador aritmético del punto
decimal de la notación en coma flotante, puede ser necesario dejar
espacios a ambos lados.  Por ejemplo, `5.e3' es `5000.0' pero `5 . e3'
es `5' por `e3'.

   Hay algunas variables globales que controlan la simplificación de
expresiones que contengan al operador `.', a saber, `dot',
`dot0nscsimp', `dot0simp', `dot1simp', `dotassoc', `dotconstrules',
`dotdistrib', `dotexptsimp', `dotident', y `dotscrules'.


File: maxima.info,  Node: Vectores,  Next: Paquete eigen,  Prev: Operador punto,  Up: Introducción a las Matrices y al Álgebra Lineal

26.1.2 Vectores
---------------

El paquete `vect' define funciones para análisis vectorial. Para cargar
el paquete en memoria se debe hacer `load ("vect")'  y con `demo
("vect")' se presenta una demostración sobre las funciones del paquete.

   El paquete de análisis vectorial puede combinar y simplificar
expresiones simbólicas que incluyan productos escalares y vectoriales,
junto con los operadores de gradiente, divergencia, rotacional y
laplaciano. La distribución de estos operadores sobre sumas o productos
se gobierna por ciertas variables, al igual que otras transformaciones,
incluida la expansión en componentes en cualquier sistema de
coordenadas especificado.  También hay funciones para obtener el
potencial escalar o vectorial de un campo.

   El paquete `vect' contiene las siguientes funciones: `vectorsimp',
`scalefactors', `express', `potential' y `vectorpotential'.

   Aviso: el paquete `vect' declara el operador `.' como conmutativo.


File: maxima.info,  Node: Paquete eigen,  Prev: Vectores,  Up: Introducción a las Matrices y al Álgebra Lineal

26.1.3 Paquete eigen
--------------------

El paquete `eigen' contiene funciones para el cálculo simbólico de
valores y vectores propios. Maxima carga el paquete automáticamente si
se hace una llamada a cualquiera de las dos funciones `eigenvalues' o
`eigenvectors'. El paquete se puede cargar de forma explícita mediante
`load ("eigen")'.

   La instrucción `demo ("eigen")' hace una demostración de las
funciones de este paquete; `batch ("eigen")' realiza la misma
demostración pero sin pausas entre los sucesivos cálculos.

   Las funciones del paquete `eigen' son `innerproduct', `unitvector',
`columnvector', `gramschmidt', `eigenvalues', `eigenvectors',
`uniteigenvectors' y `similaritytransform'.


File: maxima.info,  Node: Definiciones para las Matrices y el Álgebra Lineal,  Prev: Introducción a las Matrices y al Álgebra Lineal,  Up: Matrices y Álgebra Lineal

26.2 Definiciones para las Matrices y el Álgebra Lineal
=======================================================

 -- Función: addcol (<M>, <lista_1>, ..., <lista_n>)
     Añade la/s columna/s dada/s por la/s lista/s (o matrices) a la
     matriz <M>.


 -- Función: addrow (<M>, <lista_1>, ..., <lista_n>)
     Añade la/s fila/s dada/s por la/s lista/s (o matrices) a la matriz
     <M>.


 -- Función: adjoint (<M>)
     Devuelve el adjunto de la matriz <M>.  La matriz adjunta es la
     transpuesta de la matriz de cofactores de <M>.


 -- Función: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ...,
          <x_n>])
     Devuelve la matriz aumentada de coeficientes del sistema de
     ecuaciones lineales <eqn_1>, ..., <eqn_m> de variables <x_1>, ...,
     <x_n>. Se trata de la matriz de coeficientes con una columna
     adicional para los términos constantes de cada ecuación, es decir,
     aquellos términos que no dependen de las variables <x_1>, ...,
     <x_n>.

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]


 -- Función: charpoly (<M>, <x>)
     Calcula el polinomio característico de la matriz <M> respecto de
     la variable <x>. Esto es, `determinant (<M> - diagmatrix (length
     (<M>), <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)


 -- Función: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Devuelve la matriz de coeficientes para las variables <x_1>, ...,
     <x_n> del sistema de ecuaciones lineales <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]


 -- Función: col (<M>, <i>)
     Devuelve la <i>-ésima columna de la matriz <M>.  El resultado es
     una matriz de una sola columna.


 -- Función: columnvector (<L>)
 -- Función: covect (<L>)
     Devuelve una matriz con una columna  y `length (<L>)' filas,
     conteniendo los elementos de la lista <L>.

     La llamada `covect' es un sinónimo de `columnvector'.

     Es necesario cargar la función haciendo `load ("eigen")'.

     Ejemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function eigenvalues
          Warning - you are redefining the Macsyma function eigenvectors
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]


 -- Función: conjugate (<x>)
     Devuelve el conjugado complejo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Función: copymatrix (<M>)
     Devuelve una copia de la matriz <M>. Esta es la única manera de
     obtener una réplica de <M> además de la de copiar elemento a
     elemento.

     Nótese que una asignación de una matriz a otra, como en `m2: m1',
     no hace una copia de `m1'. Asignaciones del tipo `m2 [i,j]: x' o
     `setelmx (x, i, j, m2' también modifica `m1 [i,j]'. Si se crea una
     copia con `copymatrix' y luego se hacen asignaciones se tendrá una
     copia separada y modificada.


 -- Función: determinant (<M>)
     Calcula el determinante de  <M> por un método similar al de
     eliminación de Gauss

     La forma del resultado depende del valor asignado a `ratmx'.

     Existe una rutina especial para calcular determinantes de matrices
     con elementos dispersas, la cual será invocada cuando las
     variables `ratmx' y `sparse' valgan ambas `true'.


 -- Variable opcional: detout
     Valor por defecto: `false'

     Cuando `detout' vale `true', el determinante de la matriz cuya
     inversa se calcula aparece como un factor fuera de la matriz.

     Para que esta variable surta efecto, `doallmxops' y `doscmxops'
     deberían tener el valor `false' (véanse sus descripciones).
     Alternativamente, esta variable puede ser suministrada a `ev'.

     Ejemplo:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Función: diagmatrix (<n>, <x>)
     Devuelve una matriz diagonal de orden <n> con los elementos de la
     diagonal todos ellos iguales a <x>. La llamada `diagmatrix (<n>,
     1)' devuelve una matriz identidad (igual que `ident (<n>)').

     La variable <n> debe ser un número entero, en caso contrario
     `diagmatrix' envía un mensaje de error.

     <x> puede ser cualquier tipo de expresión, incluso otra matriz.
     Si <x> es una matriz, no se copia; todos los elementos de la
     diagonal son iguales a <x>.


 -- Variable opcional: doallmxops
     Valor por defecto: `true'

     Cuando `doallmxops' vale `true', todas las operaciones
     relacionadas con matrices son llevadas a cabo. Cuando es `false',
     entonces las selecciones para `dot' controlan las operaciones a
     ejecutar.


 -- Variable opcional: domxexpt
     Valor por defecto: `true'

     Cuando `domxexpt' vale `true', un exponente matricial, como `exp
     (<M>)' donde <M> es una matriz, se interpreta como una matriz cuyo
     elemento `[i,j' es igual a `exp (m[i,j])'. En otro caso, `exp
     (<M>)' se evalúa como `exp (ev(<M>))'.

     La variable `domxexpt' afecta a todas las expresiones de la forma
     `<base>^<exponente>' donde <base> es una expresión escalar o
     constante y <exponente> es una lista o matriz.

     Ejemplo:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]


 -- Variable opcional: domxmxops
     Valor por defecto: `true'

     Cuando `domxmxops' vale `true', se realizan todas las operaciones
     entre matrices o entre matrices y listas (pero no las operaciones
     entre matrices y escalares); si esta variable es `false' tales
     operaciones no se realizan.


 -- Variable opcional: domxnctimes
     Valor por defecto: `false'

     Cuando `domxnctimes' vale `true', se calculan los productos no
     conmutativos entre matrices.


 -- Variable opcional: dontfactor
     Valor por defecto: `[]'

     En `dontfactor' puede guardarse una lista de variables respecto de
     las cuales no se realizarán factorizaciones. Inicialmente, la lista
     está vacía.


 -- Variable opcional: doscmxops
     Valor por defecto: `false'

     Cuando `doscmxops' vale `true', se realizan las operaciones entre
     escalares y matrices.


 -- Variable opcional: doscmxplus
     Valor por defecto: `false'

     Cuando `doscmxplus' vale `true', las operaciones entre escalares y
     matrices dan como resultado una matriz.


 -- Variable opcional: dot0nscsimp
     Valor por defecto: `true'

     (Esta descripción no está clara en la versión inglesa original.)


 -- Variable opcional: dotassoc
     Valor por defecto: `true'

     Cuando `dotassoc' vale `true', una expresión como `(A.B).C' se
     transforma en `A.(B.C)'.


 -- Variable opcional: dotconstrules
     Valor por defecto: `true'

     Cuando `dotconstrules' vale `true', un producto no conmutativo de
     una constante con otro término se transforma en un producto
     conmutativo.


 -- Variable opcional: dotdistrib
     Valor por defecto: `false'

     Cuando `dotdistrib' vale `true', una expresión como `A.(B + C)' se
     transforma en `A.B + A.C'.


 -- Variable opcional: dotexptsimp
     Valor por defecto: `true'

     Cuando `dotexptsimp' vale `true', una expresión como `A.A' se
     transforma en `A^^2'.


 -- Variable opcional: dotident
     Valor por defecto: 1

     El valor de la variable `dotident' es el resultado devuelto por
     `X^^0'.


 -- Variable opcional: dotscrules
     Valor por defecto: `false'

     Cuando `dotscrules' vale `true', una expresión como `A.SC' o
     `SC.A' se transforma en `SC*A' y `A.(SC*B)' en `SC*(A.B)'.


 -- Función: echelon (<M>)
     Devuelve la forma escalonada de la matriz <M>, obtenida por
     eliminación gaussiana.  La forma escalonada se calcula a partir de
     <M> mediante operaciones elementales con sus filas, de tal manera
     que el primer elemento no nulo de cada fila en la matriz resultado
     es la unidad y que cada elemento de la columna por debajo del
     primer uno de cada fila sean todos ceros.

     La función `triangularize' también lleva a cabo la eliminación
     gaussiana, pero no normaliza el primer elemento no nulo de cada
     fila.

     Otras funciones, como `lu_factor' y `cholesky', también dan como
     resultados matrices triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]


 -- Función: eigenvalues (<M>)
 -- Función: eivals (<M>)
     Devuelve una lista con dos sublistas. La primera sublista la
     forman los valores propios de la matriz <M> y la segunda sus
     multiplicidades correspondientes.

     El nombre `eivals' es un sinónimo de `eigenvalues'.

     La función `eigenvalues' llama a la función `solve' para calcular
     las raíces del polinomio característico de la matriz. En
     ocasiones, `solve' no podrá encontrar dichas raíces, en cuyo caso
     otras funciones de este paquete no trabajarán correctamente, a
     excepción de `innerproduct', `unitvector', `columnvector' y
     `gramschmidt'.

     En algunos casos los valores propios encontrados por `solve' serán
     expresiones complicadas, las cuales se podrán simplificar haciendo
     uso de otras funciones.

     El paquete `eigen.mac' se carga en memoria de forma automática
     cuando se invocan `eigenvalues' o `eigenvectors'. Si `eigen.mac' no
     está ya cargado, `load ("eigen")' lo carga. Tras la carga, todas
     las funciones y variables del paquete estarán activas.


 -- Función: eigenvectors (<M>)
 -- Función: eivects (<M>)
     Tomando la matriz <M> como argumento, devuelve una lista de listas,
     la primera de las cuales es la salida de `eigenvalues' y las
     siguientes son los vectorios propios de la matriz asociados a los
     valores propios correspondientes. Los vectores propios calculados
     son los vectores propios por la derecha.

     El nombre `eivects' es un sinónimo de `eigenvectors'.

     El paquete `eigen.mac' se carga en memoria de forma automática
     cuando se invocan `eigenvalues' o `eigenvectors'. Si `eigen.mac' no
     está ya cargado, `load ("eigen")' lo carga. Tras la carga, todas
     las funciones y variables del paquete estarán activas.

     Las variables que afectan a esta función son:

     `nondiagonalizable' toma el valor `true' o `false' dependiendo de
     si la matriz no es diagonalizable o diagonalizable tras la
     ejecución de `eigenvectors'.

     `hermitianmatrix', si vale `true', entonces los vectores propios
     degenerados de la matriz hermítica son ortogonalizados mediante el
     algoritmo de Gram-Schmidt.

     `knowneigvals', si vale `true', entonces el paquete `eigen' da por
     sentado que los valores propios de la matriz son conocidos por el
     usuario y almacenados en la variable global `listeigvals'.
     `listeigvals' debería ser similar a la salida de `eigenvalues'.

     La función `algsys' se utiliza aquí para calcular los vectores
     propios. A veces, `algsys' no podrá calcular una solución. En
     algunos casos, será posible simplificar los valores propios
     calculándolos en primer lugar con `eigenvalues' y luego utilizando
     otras funciones para simplificarlos. Tras la simplificación,
     `eigenvectors' podrá ser llamada otra vez con la variable
     `knowneigvals' ajustada al valor `true'.


 -- Función: ematrix (<m>, <n>, <x>, <i>, <j>)
     Devuelve una matriz de orden <m> por <n>, con todos sus elementos
     nulos, excepto el que ocupa la posición `[<i>, <j>]', que es igual
     a <x>.


 -- Función: entermatrix (<m>, <n>)
     Devuelve una matriz de orden <m> por <n>, cuyos elementos son
     leidos de forma interactiva.

     Si <n> es igual a <m>, Maxima pregunta por el tipo de matriz
     (diagonal, simétrica, antisimétrica o general) y luego por cada
     elemento. Cada respuesta introducida por el usuario debe terminar
     con un punto y coma `;' o con un signo de dólar `$'.

     Si <n> y <m> no son iguales, Maxima pregunta por el valor de cada
     elemento.

     Los elementos de la matriz pueden ser cualquier tipo de expresión,
     que en todo caso será evaluada.  `entermatrix' evalúa sus
     argumentos.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matrix entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]


 -- Función: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Función: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Función: genmatrix (<a>, <i_2>, <j_2>)
     Devuelve una matriz generada a partir de <a>, siendo
     `<a>[<i_1>,<j_1>]' el elemento superior izquierdo y
     `<a>[<i_2>,<j_2>]' el inferior derecho de la matriz.  Aquí <a> se
     declara como una arreglo (creado por `array', pero no por
     `make_array'), o un array no declarado, o una función array, o una
     expresión lambda de dos argumentos.  (An array function is created
     like other functions with `:=' or `define', but arguments are
     enclosed in square brackets instead of parentheses.)

     Si se omite <j_1>, entonces se le asigna el valor <i_1>. Si tanto
     <j_1> como <i_1> se omiten, a las dos variables se le asigna el
     valor 1.

     Si un elemento `i,j' del arreglo no está definido, se le asignará
     el elemento simbólico `<a>[i,j]'.

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]


 -- Función: gramschmidt (<x>)
 -- Función: gschmit (<x>)
     Ejecuta el algoritmo de ortogonalización de Gram-Schmidt sobre
     <x>, que puede ser una matriz o una lista de listas. La función
     `gramschmidt' no altera el valor de <x>.

     Si <x> es una matriz, el algoritmo se aplica a las filas de <x>.
     Si  <x> es una lista de listas, el algoritmo se aplica a las
     sublistas, las cuales deben tener el mismo número de miembros. En
     cualquier caso, el valor devuelto es una lista de listas, cuyas
     sublistas son ortogonales.  La función `factor' es invocada  en
     cada paso del algoritmo para simplificar resultados intermedios.
     Como consecuencia, el valor retornado puede contener enteros
     factorizados.

     El nombre `gschmit' es sinónimo de `gramschmidt'.

     Es necesario cargar la función haciendo `load ("eigen")'.

     Ejemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function eigenvalues
          Warning - you are redefining the Macsyma function eigenvectors
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) i: innerproduct$
          (%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
          (%o5)                       [0, 0, 0]


 -- Función: hach (<a>, <b>, <m>, <n>, <l>)
     La función `hach' es una implementación del algoritmo Hacijan de
     programación lineal.

     Es necesario cargar la función haciendo `load ("kach")'. La
     instrucción `demo ("kach")' ejecuta una demostración de esta
     función.


 -- Función: ident (<n>)
     Devuelve la matriz identidad de orden <n>.


 -- Función: innerproduct (<x>, <y>)
 -- Función: inprod (<x>, <y>)
     Devuelve el producto interior o escalar de <x> por <y>, que deben
     ser listas de igual longitud, o ambas matrices columa o fila de
     igual longitud. El valor devuelto es `conjugate (x) . y', donde
     `.' es el operador de multiplicación no conmutativa.

     Es necesario cargar la función haciendo `load ("eigen")'.

     El nombre `inprod' es sinónimo de `innerproduct'.


 -- Función: invert (<M>)
     Devuelve la inversa de la matriz <M>, calculada por el método del
     adjunto.

     La implementación actual no es eficiente para matrices de orden
     grande.

     Cuando `detout' vale `true', el determinante queda fuera de la
     inversa a modo de factor escalar.

     Los elementos de la matriz inversa no se expanden. Si <M> tiene
     elementos polinómicos, se puede mejorar el aspecto del resultado
     haciendo `expand (invert (m)), detout'.  Véase la descripción de
     `^^' (exponente no conmutativo) para información sobre otro método
     para invertir matrices.


 -- Variable opcional: lmxchar
     Valor por defecto: `['

     La variable `lmxchar' guarda el carácter a mostrar como
     delimitador izquierdo de la matriz.  Véase también `rmxchar'.

     Ejemplo:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]


 -- Función: matrix (<fila_1>, ..., <fila_n>)
     Devuelve una matriz rectangular con las filas  <fila_1>, ...,
     <fila_n>. Cada fila es una lista de expresiones. Todas las filas
     deben tener el mismo número de miembros.

     Las operaciones `+' (suma), `-' (resta), `*' (multiplicación) y
     `/' (división), se llevan a cabo elemento a elemento cuando los
     operandos son dos matrices, un escalar y una matriz o una matriz
     con un escalar. La operación `^' (exponenciación, equivalente a
     `**') se lleva cabo también elemento a elemento si los operandos
     son un escalr y una matriz o uma matriz y un escalar, pero no si
     los operandos son dos matrices.

     El producto matricial se representa con el operador de
     multiplicación no conmutativa `.'. El correspondiente operador de
     exponenciación no conmutativa es `^^'. Dada la matriz `<A>',
     `<A>.<A> = <A>^^2' y `<A>^^-1' es la inversa de <A>, si existe.

     Algunas variables controlan la simplificación de expresiones que
     incluyan estas operaciones: `doallmxops', `domxexpt', `domxmxops',
     `doscmxops' y `doscmxplus'.

     Hay otras opciones adicionales relacionadas con matrices:
     `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix' y `sparse'.

     Hay también algunas funciones que admiten matrices como argumentos
     o que devuelven resultados matriciales: `eigenvalues',
     `eigenvectors', `determinant', `charpoly', `genmatrix', `addcol',
     `addrow', `copymatrix', `transpose', `echelon' y `rank'.

     Ejemplos:

        * Construcción de matrices a partir de listas.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

        * Suma elemento a elemento.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

        * Resta elemento a elemento.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

        * Multiplicación elemento a elemento.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

        * División elemento a elemento.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

        * Matriz elevada a un exponente escalar, operación elemento a
          elemento.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

        * Base escalar y exponente matricial, operación elemento a
          elemento.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Base y exponente matriciales. Esta operación no se realiza
          elemento a elemento.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

        * Multiplicación matricial no conmutativa.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

        * Exponenciación matricial no conmutativa. Una base escalar <b>
          elevada a un exponente matricial <M> se lleva a cabo elemento
          a elemento y por lo tanto `b^^m' equivale a `b^m'.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Una matriz elevada al exponente -1 con el operador de
          exponenciación no conmutativa equivale a la matriz inversa,
          si existe.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]


 -- Función: matrixmap (<f>, <M>)
     Devuelve una matriz con el elemento `i,j' igual a `<f>(<M>[i,j])'.

     Véanse también `map', `fullmap', `fullmapl' y `apply'.


 -- Función: matrixp (<expr>)
     Devuelve `true' si <expr> es una matriz, en caso contrario `false'.


 -- Variable opcional: matrix_element_add
     Valor por defecto: `+'

     La variable `matrix_element_add' guarda el símbolo del operador a
     ejecutar en lugar de la suma en el producto matricial; a
     `matrix_element_add' se le puede asignar cualquier operador n-ario
     (esto es, una función que admite cualquier número de argumentos).
     El valor asignado puede ser el nombre de un operador encerrado
     entre apóstrofos, el nombre de una función o una expresión lambda.

     Véanse también `matrix_element_mult' y `matrix_element_transpose'.

     Ejemplo:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]


 -- Variable opcional: matrix_element_mult
     Valor por defecto: `*'

     La variable `matrix_element_mult' guarda el símbolo del operador a
     ejecutar en lugar de la multiplicación en el producto matricial; a
     `matrix_element_mult' se le puede asignar cualquier operador
     binario. El valor asignado puede ser el nombre de un operador
     encerrado entre apóstrofos, el nombre de una función o una
     expresión lambda.

     El operador `.' puede ser una opción útil en determinados
     contextos.

     Véanse también `matrix_element_add' y `matrix_element_transpose'.

     Ejemplo:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]


 -- Variable opcional: matrix_element_transpose
     Valor por defecto: `false'

     La variable `matrix_element_transpose' es una operación que se
     aplica a cada elemento de una matriz a la que se le calcula la
     transpuesta. A `matrix_element_mult' se le puede asignar cualquier
     operador unitario. El valor asignado puede ser el nombre de un
     operador encerrador entre apóstrofos, el nombre de una función o
     una expresión lambda.

     Cuando `matrix_element_transpose' es igual a `transpose', la
     función `transpose' se aplica a cada elemento. Cuando
     `matrix_element_transpose' es igual  a `nonscalars', la función
     `transpose' se aplica a todos los elementos no escalares. Si
     alguno de los elementos es un átomo, la opción `nonscalars' se
     aplica `transpose' sólo si el átomo se declara no escalar,
     mientras que la opción `transpose' siempre aplica  `transpose'.

     La opción por defecto, `false', significa que no se aplica ninguna
     operación.

     Véanse también `matrix_element_add' y `matrix_element_mult'.

     Ejemplos:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]


 -- Función: mattrace (<M>)
     Devuelve la traza (esto es, la suma de los elementos de la
     diagonal principal) de la matriz cuadrada <M>.

     Para disponer de esta función es necesario cargar el paquete
     haciendo `load ("nchrpl")'.


 -- Función: minor (<M>, <i>, <j>)
     Devuelve el menor `(<i>, <j>)' de la matriz <M>.  Esto es, la
     propia matriz <M>, una vez extraídas la fila <i> y la columna <j>.


 -- Función: ncexpt (<a>, <b>)
     Si una expresión exponencial no conmutativa es demasiado grande
     para mostrarse en la forma `<a>^^<b>' entonces aparece como
     `ncexpt (<a>,<b>)'.

     El nombre `ncexpt' no corresponde al de una función u operador,
     sino que tan solo aparece en la salida y no se reconoce como una
     entrada válida.


 -- Función: ncharpoly (<M>, <x>)
     Devuelve el polinomio característico de la matriz <M> respecto de
     la variable <x>. Es una alternativa a la función `charpoly' de
     Maxima.

     La función `ncharpoly' opera calculando trazas de las potencias de
     la matriz dada, que son iguales a las sumas de las potencias de
     las raíces del polinomio característico. A partir de estas
     cantidades se pueden calcular las funciones simétricas de las
     raíces, que no son otra cosa sino los coeficientes del polinomio
     característico. La función   `charpoly' opera calculando el
     determinante de  by `<x> * ident [n] - a'. La función `ncharpoly'
     es m'as eficiente en el caso de matrices grandes y densas.

     Para disponer de esta función es necesario cargar el paquete
     haciendo `load ("nchrpl")'.


 -- Función: newdet (<M>, <n>)
     Calcula el determinante de la matriz o arreglo <M> por el
     algoritmo del árbol menor de Johnson-Gentleman.  El argumento <n>
     es el orden; es opcional si <M> es una matriz.


 -- Declaración: nonscalar
     Hace que los átomos se comporten como hace una lista o matriz con
     respecto del operador `.' del la multiplicación no conmutativa.


 -- Función: nonscalarp (<expr>)
     Devuelve `true' si <expr> no es escalar, es decir, si contiene
     átomos declarados como no escalares, listas o matrices.


 -- Función: permanent (<M>, <n>)
     Calcula la permanente de la matriz <M>. La permanente es como un
     determinante pero sin cambios de signo.


 -- Función: rank (<M>)
     Calcula el rango de la matriz <M>.  Esto es, el orden del mayor
     subdeterminante no singular de <M>.

     La función <rango> puede retornar una respuesta errónea si no
     detecta que un elemento de la matriz equivalente a cero lo es.


 -- Variable opcional: ratmx
     Valor por defecto: `false'

     Si `ratmx' vale `false', el determinante y la suma, resta y
     producto matriciales se calculan cuando las matrices se expresan
     en términos de sus elementos, pero no se calcula la inversión
     matricial en su representación general.

     Si `ratmx' vale `true', las cuatro operaciones citadas más arriba
     se calculan en el formato CRE y el resultado de la matriz inversa
     también se da en formato CRE. Esto puede hacer que se expandan los
     elementos de la matriz, dependiendo del valor de `ratfac', lo que
     quizás no sea siempre deseable.


 -- Función: row (<M>, <i>)
     Devuelve la <i>-ésima fila de la matriz <M>. El valor que devuelve
     tiene formato de matriz.


 -- Variable opcional: scalarmatrixp
     Valor por defecto: `true'

     Si `scalarmatrixp' vale `true', entonces siempre que una matriz 1
     x 1 se produce como resultado del cálculo del producto no
     conmutativo de matrices se cambia al formato escalar.

     Si `scalarmatrixp' vale `all', entonces todas las matrices 1 x 1
     se simplifican a escalares.

     Si `scalarmatrixp' vale `false', las matrices 1 x 1 no se
     convierten en escalares.


 -- Función: setelmx (<x>, <i>, <j>, <M>)
     Asigna el valor <x> al (<i>, <j>)-ésimo elemento de la matriz <M>
     y devuelve la matriz actualizada.

     La llamada `<M> [<i>, <j>]: <x>' hace lo mismo, pero devuelve  <x>
     en lugar de <M>.


 -- Función: similaritytransform (<M>)
 -- Función: simtran (<M>)
     La función `similaritytransform' calcula la transformada de
     similitud de la matriz `M'. Devuelve una lista que es la salida de
     la instrucción `uniteigenvectors'. Además, si la variable
     `nondiagonalizable' vale `false' entonces se calculan dos matrices
     globales `leftmatrix' y `rightmatrix'. Estas matrices tienen la
     propiedad de que `leftmatrix . <M> . rightmatrix' es una matriz
     diagonal con los valores propios de <M> en su diagonal.  Si
     `nondiagonalizable' vale `true' entonces no se calculan estas
     matrices.

     Si la variable `hermitianmatrix' vale `true' entonces `leftmatrix'
     es el conjugado complejo de la transpuesta de `rightmatrix'.  En
     otro caso `leftmatrix' es la inversa de `rightmatrix'.

     Las columnas de la matriz `rightmatrix' son los vectores propios
     de <M>.  Las otras variables (véanse `eigenvalues' y
     `eigenvectors') tienen el mismo efecto, puesto que
     `similaritytransform' llama a las otras funciones del paquete para
     poder formar `rightmatrix'.

     Estas funciones se cargan con `load ("eigen")'.

     El nombre `simtran' es sinónimo de `similaritytransform'.


 -- Variable opcional: sparse
     Valor por defecto: `false'

     Si `sparse' vale `true' y si `ratmx' vale `true', entonces
     `determinant' utilizará rutinas especiales para calcular
     determinantes dispersos.


 -- Función: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Función: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Función: submatrix (<M>, <j_1>, ..., <j_n>)
     Devuelve una nueva matriz formada a partir de la matriz <M> pero
     cuyas filas <i_1>, ..., <i_m> y columnas  <j_1>, ..., <j_n> han
     sido eliminadas.


 -- Función: transpose (<M>)
     Calcula la transpuesta de <M>.

     Si <M> es una matriz, el valor devuelto es otra matriz <N> tal que
     `N[i,j] = M[j,i]'.

     Si <M> es una lista, el valor devuelto es una matriz <N> de
     `length (m)' filas y 1 columna, tal que `N[i,1] = M[i]'.


 -- Función: triangularize (<M>)
     Devuelve la forma triangular superior de la matriz `M', obtenida
     por eliminación gaussiana.  El resultado es el mismo que el
     devuelto por `echelon', con la salvedad de que el primer elemento
     no nulo de cada fila no se normaliza a 1.

     Las funciones `lu_factor' y `cholesky' también triangularizan
     matrices.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]


 -- Función: uniteigenvectors (<M>)
 -- Función: ueivects (<M>)
     Calcula los vectores propios unitarios de la matriz <M>. El valor
     que devuelve es una lista de listas, la primera de las cuales es
     la salida de la función `eigenvalues' y el resto de sublistas son
     los vectores propios unitarios de la matriz correspondiente a esos
     valores propios, respectivamente.

     Las variables citadas en la descripción de la función
     `eigenvectors' tienen los mismos efectos en `uniteigenvectors'.

     Si `knowneigvects' vale `true', el paquete `eigen' da por supuesto
     que el usuario conoce los vectores propios de la matriz y que
     están guardados en la variable global `listeigvects', en tal caso
     el contenido de  `listeigvects' debe ser una lista de estructura
     similar a la que devuelve la función `eigenvectors'.

     Si `knowneigvects' vale `true' y la lista de vectores propios está
     en la variable `listeigvects', el valor de la variable
     `nondiagonalizable' puede que no sea el correcto. Si tal es el
     caso, debe asignarsele el valor correcto.  Para utilizar esta
     fucnión es necesario cargarla haciendo `load ("eigen")'.

     El nombre `ueivects' es sinónimo de `uniteigenvectors'.


 -- Función: unitvector (<x>)
 -- Función: uvect (<x>)
     Devuelve <x>/norm(<x>), esto es, el vector unitario de igual
     dirección y sentido que <x>.

     `load ("eigen")' loads this function.

     Para utilizar esta fucnión es necesario cargarla haciendo `load
     ("eigen")'.

     El nombre `uvect' es sinónimo de `unitvector'.


 -- Función: vectorsimp (<expr>)
     Realiza simplificaciones y expansiones de acuerdo con los valores
     de las siguientes variables globales:

     `expandall', `expanddot', `expanddotplus', `expandcross',
     `expandcrossplus', `expandcrosscross', `expandgrad',
     `expandgradplus', `expandgradprod', `expanddiv', `expanddivplus',
     `expanddivprod', `expandcurl', `expandcurlplus', `expandcurlcurl',
     `expandlaplacian', `expandlaplacianplus' y `expandlaplacianprod'.

     Todas estas variables tienen por defecto el valor `false'. El
     sufijo `plus' se refiere al uso de la suma o la distributividad.
     El sufijo `prod' se refiere a la expansión de operadores que
     realizan cualquier tipo de producto.

    `expandcrosscross'
          Simplifica p ~ (q ~ r) en (p . r)*q - (p . q)*r.

    `expandcurlcurl'
          Simplifica curl curl p en grad div p + div grad p.

    `expandlaplaciantodivgrad'
          Simplifica laplacian p en div grad p.

    `expandcross'
          Activa `expandcrossplus' y `expandcrosscross'.

    `expandplus'
          Activa `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus' y `expandlaplacianplus'.

    `expandprod'
          Activa `expandgradprod', `expanddivprod' y
          `expandlaplacianprod'.

     Estas variables están declaradas como `evflag'.


 -- Función: zeromatrix (<m>, <n>)
     Devuelve una matriz rectangular <m> por <n> con todos sus
     elementos iguales a cero.


 -- Símbolo especial: [
 -- Símbolo especial: [
     Los símbolos `[' y `]' marcan el comienzo y final,
     respectivamente, de una lista.

     Los símbolos `[' y `]' también se utilizan para indicar los
     subíndices de los elementos de una lista, arreglo o función
     arreglo.

     Ejemplos:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101



File: maxima.info,  Node: Afines,  Next: itensor,  Prev: Matrices y Álgebra Lineal,  Up: Top

27 Afines
*********

* Menu:

* Definiciones para Afines::


File: maxima.info,  Node: Definiciones para Afines,  Prev: Afines,  Up: Afines

27.1 Definiciones para Afines
=============================

 -- Función: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Resuelve las ecuaciones lineales simultáneas <expr_1>, ...,
     <expr_m> para las variables <x_1>, ..., <x_n>.  Cada <expr_i>
     puede ser una ecuación o una expresión general; en caso de
     tratarse de una expresión general, será tratada como una ecuación
     de la forma `<expr_i> = 0'.

     El valor que devuelve es una lista de ecuaciones de la forma
     `[<x_1> = <a_1>, ..., <x_n> = <a_n>]' donde todas las <a_1>, ...,
     <a_n> están exentas de <x_1>, ..., <x_n>.

     La función `fast_linsolve' es más rápida que `linsolve' para
     sistemas de ecuaciones con coeficientes dispersos.


 -- Función: grobner_basis ([<expr_1>, ..., <expr_m>])
     Devuelve una base de Groebner para las ecuaciones <expr_1>, ...,
     <expr_m>.  La función `polysimp' puede ser entonces utilizada para
     simplificar otras funciones relativas a las ecuaciones.

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     `polysimp(f)' alcanza 0 si y sólo si <f> está en el ideal generado
     por <expr_1>, ..., <expr_m>, es decir, si y sólo si <f> es una
     combinación  polinómica de los elementos de <expr_1>, ...,
     <expr_m>.


 -- Función: set_up_dot_simplifications (<eqns>, <check_through_degree>)
 -- Función: set_up_dot_simplifications (<eqns>)
     Las <eqns> son ecuaciones polinómicas de variables no conmutativas.
     El valor de `current_variables' es la lista de variables
     utilizadas para el cálculo de los grados. Las ecuaciones deben ser
     homogéneas, al objeto de completar el procedimiento.

     El grado es el devuelto por `nc_degree'. Éste a su vez depende de
     los pesos de las variables individuales.


 -- Función: declare_weight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Asigna los pesos <w_1>, ..., <w_n> a <x_1>, ..., <x_n>,
     respectivamente.  Estos pesos son los utilizados en el cálculo de
     `nc_degree'.


 -- Función: nc_degree (<p>)
     Devuelve el grado de un polinomio no conmutativo <p>. Véase
     `declare_weights'.


 -- Función: dotsimp (<f>)
     Devuelve 0 si y sólo si  <f> está en el ideal generado por las
     ecuaciones, esto es, si y sólo si <f> es una combinación lineal de
     los elementos de las ecuaciones.


 -- Función: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     Si se ha ejecutado `set_up_dot_simplifications' con antelación,
     obtiene los polinomios centrales de grado <n> de variables <x_1>,
     ..., <x_n>.

     Por ejemplo:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];


 -- Función: check_overlaps (<n>, <add_to_simps>)
     Revisa la superposición hasta el grado <n>, asegurándose de que el
     usuario tiene suficientes reglas de simplificación en cada grado
     para que `dotsimp' trabaje correctamente. Este proceso puede
     acelerarse si se conoce de antemano cuál es la dimensión del
     espacio de monomios.  Si éste es de dimensión global finita,
     entonces debería usarse `hilbert'. Si no se conoce la dimensiones
     de los monomios, no se debería especificar una `rank_function'.
     Un tercer argumento opcional es `reset'.


 -- Función: mono ([<x_1>, ..., <x_n>], <n>)
     Devuelve la lista de monomios independientes.

 -- Función: monomial_dimensions (<n>)
     Calcula el desarrollo de Hilbert de grado <n> para el algebra
     actual.

 -- Función: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>,
          ..., <m_n>])
     Hace una lista de los coeficientes de los polinomios no
     conmutativos <p_1>, ..., <p_n> de los monomios no conmutativos
     <m_1>, ..., <m_n>. Los coeficientes deben escalares. Hágase uso de
     `list_nc_monomials' para construir la lista de monomios.

 -- Función: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Función: list_nc_monomials (<p>)
     Devuelve  una lista de los monomios no conmutativos que aparecen
     en el polinomio  <p> o una lista de polinomios en <p_1>, ...,
     <p_n>.

 -- Variable: all_dotsimp_denoms
     Valor por defecto: `false'

     Cuando `all_dotsimp_denoms' es una lista, los denominadores
     encontrados por `dotsimp' son añadidos a la lista. La variable
     `all_dotsimp_denoms' puede inicializarse como una lista vacía `[]'
     antes de llamar a `dotsimp'.

     Por defecto, `dotsimp' no recolecta los denominadores.



File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Afines,  Up: Top

28 itensor
**********

* Menu:

* Introducción a itensor::
* Definiciones para itensor::


File: maxima.info,  Node: Introducción a itensor,  Next: Definiciones para itensor,  Prev: itensor,  Up: itensor

28.1 Introducción a itensor
===========================

Maxima implementa dos tipos diferentes de manipulación simbólica de
tensores: la manipulación de componentes (paquete `ctensor') y la
manipulación indexada (paquete `itensor').

   Véase más abajo la nota sobre 'notación tensorial'.

   La manipulación de componentes significa que los objetos geométricos
tensoriales se representan como arreglos (arrays) o matrices.
Operaciones tensoriales como la contracción o la diferenciación
covariante se llevan a cabo sumando índices mudos con la sentencia
`do'. Esto es, se realizan operaciones directamente con las componentes
del tensor almacenadas en un arreglo o matriz.

   La manipulación indexada de tensores se lleva a cabo mediante la
representación de los tensores como funciones de sus índices
covariantes, contravariantes y de derivadas. Operaciones tensoriales
como la contracción o la diferenciación covariante se realizan
manipulando directamente los índices, en lugar de sus componentes
asociadas.

   Estas dos técnicas para el tratamiento de los procesos
diferenciales, algebraicos y analíticos en el contexto de la geometría
riemanniana tienen varias ventajas y desventajas que surgen según la
naturaleza y dificultad del problema que está abordando el usuario. Sin
embargo, se deben tener presentes las siguientes características de
estas dos técnicas:

   La representación de los tensores y sus operaciones en términos de
sus componentes facilita el uso de paquete `ctensor'. La especificación
de la métrica y el cálculo de los tensores inducidos e invariantes es
inmediato. Aunque toda la potencia de simplificación de Maxima se
encuentra siempre a mano, una métrica compleja con dependencias
funcionales y de coordenadas intrincada, puede conducir a expresiones
de gran tamaño en las que la estructura interna quede oculta. Además,
muchos cálculos requieren de expresiones intermedias que pueden
provocar la detención súbita de los programas antes de que se termine
el cálculo. Con la experiencia, el usuario podrá evitar muchas de estas
dificultades.

   Devido a la forma en que los tensores y sus operaciones se
representan en términos de operaciones simbólicas con sus índices,
expresiones que serían intratables en su representación por componentes
pueden en ocasiones simplificarse notablemente utilizando las rutinas
especiales para objetos simétricos del paquete `itensor'. De esta
manera, la estructura de expresiones grandes puede hacerse más
transparente. Por otro lado, debido a la forma especial de la
representación indexada de tensores en `itensor', en algunos casos el
usuario encontrará dificultades con la especificación de la métrica o
la definición de funciones.

28.1.1 Notación tensorial
-------------------------

Hasta ahora, el paquete `itensor' de Maxima utilizaba una notación que
algunas veces llevaba a una ordenación incorrecta de los índices. Por
ejemplo:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   Este resultado no es correcto a menos que `a' sea un tensor
simétrico. La razón por la que esto ocurre es que aunque `itensor'
mantenga correctamente el orden dentro del conjunto de índices
covariantes y contravariantes, una vez un índice sea aumentado o
disminuido, su posición relativa al otro conjunto de índices se pierde.

   Para evitar este problema, se ha desarrollado una notación
totalmente compatible con la anterior.En esta notación, los índices
contravariantes se insertan en las posiciones correctas en la lista de
índices covariantes, pero precedidos del signo negativo.

   En esta notación, el ejemplo anterior da el resultado correcto:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   El único código que hace uso de esta notación es la función
`lc2kdt'.  Devido a que este código es nuevo, puede contener errores.

28.1.2 Manipulación indexada de tensores
----------------------------------------

El paquete `itensor' se carga haciendo `load(itensor)'. Para acceder a
las demos se hará `demo(tensor)'.

   En el paquete `itensor' un tensor se representa como un objeto
indexado, esto es, como una función de tres grupos de índices: los
covariantes, los contravariantes y los de derivadas. Los índices
covariantes se especifican mediante una lista que será el primer
argumento del objeto indexado, siendo los índices contravariantes otra
lista que será el segundo argumento del mismo objeto indexado. Si al
objeto indexado le falta cualquiera de estos grupos de índices,
entonces se le asignará al argumento correspondiente la lista vacía
`[]'.  Así, `g([a,b],[c])' representa un objeto indexado llamado `g',
el cual tiene dos índices covariantes `(a,b)', un índice contravariante
(`c') y no tiene índices de derivadas.

   Los índices de derivadas, si están presentes, se añaden como
argumentos adicionales a la función simbólica que representa al tensor.
Se pueden especificar explícitamente por el usuario o pueden crearse
durante el proceso de diferenciación respecto de alguna coordenada.
Puesto que la diferenciación ordinaria es conmutativa, los índices de
derivadas se ordenan alfanuméricamente, a menos que la variable
`iframe_flag' valga `true', indicando que se está utilizando una
métrica del sistema de referencia. Esta ordenación canónica hace
posible que Maxima reconozca, por ejemplo, que `t([a],[b],i,j)' es lo
mismo que `t([a],[b],j,i)'. La diferenciación de un objeto indexado con
respecto de alguna coordenada cuyo índice no aparece como argumento de
dicho objeto indexado, dará como resultado cero. Esto se debe a que
Maxima no sabe si el tensor representado por el objeto indexado depende
implícitamente de la coordenada correspondiente. Modificando la función
`diff' de Maxima en `itensor', se da por hecho que todos los objetos
indexados dependen de cualquier variable de diferenciación, a menos que
se indique lo contrario. Esto hace posible que la convención sobre la
sumación se extienda a los índices de derivadas. El paquete `itensor'
trata a los índices de derivadas como covariantes.

   Las siguientes funciones forman parte del paquete `itensor' para la
manipulación indexada de vectores. En lo que respecta a las rutinas de
simplificación, no se considera en general que los objetos indexados
tengan propiedades simétricas. Esto puede cambiarse reasignando a la
variable `allsym[false]' el valor `true', con lo cual los objetos
indexados se considerarán simétricos tanto respecto de sus índices
covariantes como contravariantes.

   En general, el paquete `itensor' trata a los tensores como objetos
opacos. Las ecuaciones tensoriales se manipulan en base a reglas
algebraicas, como la simetría y la contracción. Además, en el paquete
`itensor' hay funciones para la diferenciación covariante, la curvatura
y la torsión. Los cálculos se pueden realizar respecto de una métrica
del sistema de referencia móvil, dependiendo de las asignaciones dadas
a la variable `iframe_flag'.

   La siguiente sesión de ejemplo demuestra cómo cargar el paquete
`itensor', especificar el nombre de la métrica y realizar algunos
cálculos sencillos.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                    %4 %5
     (%t12) v    - g      v   (e p       + e   p     - e p       - e    p
             i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                     + e p       + e   p    )/2
                                                          i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %8                    %6 %8
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %8 i             %6    i j %8      i,j

                                                         %6 %8
                                                    - ifg      v   ifb      )/2
                                                                %6    %8 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0


File: maxima.info,  Node: Definiciones para itensor,  Prev: Introducción a itensor,  Up: itensor

28.2 Definiciones para itensor
==============================

28.2.1 Trabajando con objetos indexados
---------------------------------------

 -- Función: entertensor (<nombre>)
     Permite crear un objeto indexado llamado <nombre>, con cualquier
     número de índices tensoriales y de derivadas. Se admiten desde un
     único índice hasta una lista de índices. Véase el ejemplo en la
     descripción de `covdiff'.


 -- Función: changename (<anterior>, <nuevo>, <expr>)
     Cambia el nombre de todos los objetos indexados llamados
     <anterior> a <new> en <expr>. El argumento <anterior> puede ser un
     símbolo o una lista de la forma `[<nombre>, <m>, <n>]', en cuyo
     caso sólo los objetos indexados de llamados <nombre> con <m>
     índices covariantes y <n> contravariantes se renombrarán como
     <nuevo>.


 -- Función: listoftens
     Hace un listado de todos los tensores y sus índices en una
     expresión tensorial. Por ejemplo,


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y


 -- Función: ishow (<expr>)
     Muestra <expr> con todos los objetos indexados que contiene, junto
     con los correspondientes índices covariantes (como subíndices) y
     contravariantes (como superíndices). Los índices de derivadas se
     muestran como subíndices, separados de los covariantes por una
     coma; véanse los múltiples ejemplos de este documento.


 -- Función: indices (<expr>)
     Devuelve una lista con dos elementos. El primer elemento es una
     lista con los índices libres, aquellos que aparecen una sola vez.
     El segundo elemento es una lista con los índices mudos en <expr>,
     aquellos que aparecen exactamente dos veces. Por ejemplo,


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     Un producto tensorial que contenga el mismo índice más de dos
     veces es sintácticamente incorrecto. La función `indices' intenta
     tratar estas expresiones de una forma razonable; sin embargo,
     cuando se la obliga a manipular una expresión incorrecta puede
     tener un comportamiento imprevisto.


 -- Función: rename (<expr>)
 -- Función: rename (<expr>, <count>)
     Devuelve una expresión equivalente a <expr> pero con los índices
     mudos de cada término elegidos del conjunto  `[%1, %2,...]' si el
     segundo argumento opcional se omite. En otro caso, los índices
     mudos son indexados empezando con el valor <count>. Cada índice
     mudo en un producto será diferente. En el caso de las sumas, la
     función `rename' operará sobre cada término de la suma
     reinicializando el contador con cada término. De esta manera
     `rename' puede servir como simplificador tensorial. Además, los
     índices se ordenarán alfanuméricamente, si la variable `allsym'
     vale `true', respecto de los índices covariantes y contravariantes
     dependiendo del valor de `flipflag'. Si  `flipflag' vale `false',
     entonces los índices se renombrarán de acuerdo con el orden de los
     índices contravariantes. Si `flipflag' vale `true', entonces los
     índices se renombrarán de acuerdo con el orden de los índices
     covariantes. Suele acontecer que el efecto combinado de los dos
     cambios de nombre reduzcan la expresión más de lo que que pueda
     reducir cualquiera de ellas por separado.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$

                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                        %1 %2  %3 %4      %6         %5         %7        u
                     - g      g      ichr2      ichr2      ichr2     ichr2
                                          %1 %3      %2 %6      %4 r      %5 %7


 -- Variable opcional: flipflag
     Valor por defecto: `false'

     Si vale `false' los índices se renombrarán de acuerdo con el orden
     de los índices covariantes, si `true' se renombrarán de acuerdo
     con el orden de los índices covariantes.

     Si `flipflag' vale `false', entonces `rename' construye una lista
     con los índices contravariantes según van apareciendo de izquierda
     a derecha; si vale `true', entonces va formando la lista con los
     covariantes. Al primer índice mudo se le da el nombre `%1', al
     siguiente `%2', etc. Finalmente se hace la ordenación. Véase el
     ejemplo en la descripción de la función `rename'.


 -- Función: defcon (<tensor_1>)
 -- Función: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     Le asigna a gives <tensor_1> la propiedad de que la contracción de
     un producto de <tensor_1> por <tensor_2> da como resultado un
     <tensor_3> con los índices apropiados. Si sólo se aporta un
     argumento, <tensor_1>, entonces la contracción del producto de
     <tensor_1> por cualquier otro objeto indexado que tenga los
     índices apropiados, por ejemplo `my_tensor', dará como resultado
     un objeto indexado con ese nombre, `my_tensor', y con un nuevo
     conjunto de índices que reflejen las contracciones realizadas. Por
     ejemplo, si `imetric:g', entonces `defcon(g)' implementará el
     aumento o disminución de los índices a través de la contracción
     con el tensor métrico. Se puede dar más de un `defcon' para el
     mismo objeto indexado, aplicándose el último. La variable
     `contractions' es una lista con aquellos objetos indexados a los
     que se le han dado propiedades de contracción con  `defcon'.


 -- Función: remcon (<tensor_1>, ..., <tensor_n>)
 -- Función: remcon (all)
     Borra todas las propiedades de contracción de <tensor_1>, ...,
     <tensor_n>). La llamada `remcon(all)' borra todas las propiedades
     de contracción de todos los objetos indexados.


 -- Función: contract (<expr>)
     Lleva a cabo las contracciones tensoriales en <expr>, la cual
     puede ser cualquier combinación de sumas y productos. Esta función
     utiliza la información dada a la función `defcon'. Para obtener
     mejores resultados, `expr' debería estar completamente expandida.
     La función `ratexpand' es la forma más rápida de expandir
     productos y potencias de sumas si no hay variables en los
     denominadores de los términos.


 -- Función: indexed_tensor (<tensor>)
     Debe ejecutarse antes de asignarle componentes a un <tensor> para
     el que ya existe un valor, como `ichr1', `ichr2' o `icurvature'.
     Véase el ejemplo de la descripción de `icurvature'.


 -- Función: components (<tensor>, <expr>)
     Permite asignar un valor indexado a la expresión <expr> dando los
     valores de las componentes de <tensor>. El tensor debe ser de la
     forma `t([...],[...])', donde cualquiera de las listas puede estar
     vacía. La expresión  <expr> puede ser cualquier objeto indexado
     que tenga otros objetos con los mismos índices libres que
     <tensor>. Cuando se utiliza para asignar valores al tensor métrico
     en el que las componentes contengan índices mudos, se debe tener
     cuidado en no generar índices mudos múltiples. Se pueden borrar
     estas asignaciones con la función  `remcomps'.

     Es importante tener en cuenta que `components' controla la
     valencia del tensor, no el orden de los índices. Así, asignando
     componentes de la forma `x([i,-j],[])', `x([-j,i],[])' o
     `x([i],[j])' todos ellos producen el mismo resultado, la
     asignación de componentes a un tensor de nombre `x' con valencia
     `(1,1)'.

     Las componentes se pueden asignar a una expresión indexada de
     cuatro maneras, dos de las cuales implican el uso de la
     instrucción `components':

     1) Como una expresión indexada. Por ejemplo:


          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) Como una matriz:


          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([3,3],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) Como una función. Se puede utilizar una función de Maxima para
     especificar las componentes de un tensor en base a sus índices.
     Por ejemplo, el código siguiente asigna  `kdelta' a `h' si `h'
     tiene el mismo número de índices covariantes y contravariantes y
     no tiene índices de derivadas, asignándole `g' en otro caso:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Utilizando los patrones de Maxima, en particular las funciones
     `defrule' y `applyb1':


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n


 -- Función: remcomps (<tensor>)
     Borra todos los valores de <tensor> que han sido asignados con la
     función `components'.


 -- Función: showcomps (<tensor>)
     Muestra las componentes de un tensor definidas con la instrucción
     `components'. Por ejemplo:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load(itensor);
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     La función `showcomps' también puede mostrar las componentes de
     tensores de rango mayor de 2.


 -- Función: idummy ()
     Incrementa `icounter' y devuelve un índice de la forma `%n' siendo
     `n' un entero positivo.  Esto garantiza que índices mudos que sean
     necesarios para formar expresiones no entren en conflico con
     índices que ya están en uso. Véase el ejemplo de la descripción de
     `indices'.


 -- Variable opcional: idummyx
     Valor por defecto: `%'

     Es el prefijo de los índices mudos. Véase `indices'.


 -- Variable opcional: icounter
     Valor por defecto: `1'

     Determina el sufijo numérico a ser utilizado en la generación del
     siguiente índice mudo. El prefijo se determina con la opción
     `idummy' (por defecto: %).

 -- Función: kdelta (<L1>, <L2>)
     Es la función delta generalizada de Kronecker definida en el
     paquete `itensor' siendo <L1> la lista de índices covariantes y
     <L2> la lista de índices contravariantes. La función
     `kdelta([i],[j])' devuelve el valor de la delta ordinaria de
     Kronecker. La instrucción `ev(<expr>,kdelta)' provoca la
     evaluación de una expresión que contenga `kdelta([],[])'.

     En un abuso de la notación, `itensor' también permite a `kdelta'
     tener 2 índices covariantes y ninguno contravariante, o 2
     contravariantes y ninguno covariante. Esto es una funcionalidad
     del paquete, loque no implica que  `kdelta([i,j],[])' sea un
     objeto tensorial de pleno derecho.


 -- Función: kdels (<L1>, <L2>)
     Función delta de Kronecker simetrizada, utilizada en algunos
     cálculos. Por ejemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b


 -- Función: levi_civita (<L>)
     Es el tensor de permutación de Levi-Civita, el cual devuelve 1  si
     la lista <L> con una permutación par de enteros, -1 si es en una
     permutación impar y 0 si algunos de los índices de <L> están
     repetidos.


 -- Función: lc2kdt (<expr>)
     Simplifica expresiones que contengan el símbolo de Levi-Civita,
     convirtiéndolas en expresiones con la delta de Kronecker siempre
     que sea posible. La diferencia principal entre esta función y la
     simple evaluación del símbolo de Levi-Civita consiste en que de
     esta última forma se obtienen expresiones de Kronecker con índices
     numéricos, lo que impide simplificaciones ulteriores. La función
     `lc2kdt' evita este problema, dando resultados con son más fáciles
     de simplificar con `rename' o `contract'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     La función `lc2kdt' en ocasiones hace uso del tensor métrico. Si
     el tensor métrico no fue previamente definido con `imetric', se
     obtiene un mensaje de error.


          (%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j       k
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                              %3             %4               %3             %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i      l i
          (%t11)                           a    - a g


 -- Función: lc_l
     Regla de simplificación utilizada en expresiones que contienen el
     símbolo de `levi_civita' sin evaluar. Junto con  `lc_u', puede
     utilizarse para simplificar muchas expresiones de forma más
     eficiente que la evaluación de `levi_civita'. Por ejemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
          (%t4)                                  0
          (%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
          (%t5)                                  0


 -- Función: lc_u
     Regla de simplificación utilizada en expresiones que contienen el
     símbolo de `levi_civita' sin evaluar. Junto con  `lc_l', puede
     utilizarse para simplificar muchas expresiones de forma más
     eficiente que la evaluación de `levi_civita'. Véase `lc_l'.


 -- Función: canten (<expr>)
     Simplifica <expr> renombrando (véase `rename') y permutando
     índices mudos. La función `rename' se restringe a sumas de
     productos de tensores en los cuales no hay derivadas, por lo que
     está limitada y sólo debería utilizarse si `canform' no es capaz
     de de llevar a cabo la simplificación requerida.

     La función `canten' devuelve un resultado matemáticamente correcto
     sólo si su argumento es una expresión completamente simétrica
     respecto de sus índices. Por esta razón, `canten' devuelve un
     error si `allsym' no vale `true'.


 -- Función: concan (<expr>)
     Similar a `canten' pero también realiza la contracción de los
     índices.


28.2.2 Simetrías de tensores
----------------------------

 -- Variable opcional: allsym
     Valor por defecto: `false'

     Si vale `true' entonces todos los objetos indexados se consideran
     simétricos respecto de todos sus índices covariantes y
     contravariantes. Si vale `false' entonces no se tienen en cuenta
     ningún tipo de simetría para estos índices. Los índices de
     derivadas se consideran siempre simétricos, a menos que la
     variable `iframe_flag' valga `true'.


 -- Función: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])
     Declara propiedades de simetría para el <tensor> de <m> índices
     covariantes y <n> contravariantes. Los <cov_i> y <contr_i> son
     seudofunciones que expresan relaciones de simetría entre los
     índices covariantes y contravariantes, respectivamente. Éstos son
     de la forma `symoper(<index_1>, <index_2>,...)' donde `symoper' es
     uno de `sym', `anti' o `cyc' y los <index_i> son enteros que
     indican la posición del índice en el <tensor>.  Esto declarará a
     <tensor> simétrico, antisimétrico o cíclico respecto de <index_i>.
     La llamada `symoper(all)' indica que todos los índices cumplen la
     condición de simetría. Por ejemplo, dado un objeto `b' con 5
     índices covariantes,
     `decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])' declara `b'
     simétrico en el primer y segundo índices covariantes,
     antisimétrico en su tercer y cuarto índices también covariantes y
     cíclico en todos sus índices contravariantes. Cualquiera de las
     listas de declaración de simetrías puede ser nula. La función que
     realiza las simplificaciones es `canform', como se ilustra en el
     siguiente ejemplo,


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]


 -- Función: remsym (<tensor>, <m>, <n>)
     Borra todas las propiedades de simetría del <tensor> que tiene <m>
     índices covariantes y <n> contravariantes.

 -- Función: canform (<expr>)
     Simplifica <expr> renombrando índices mudos y reordenando todos
     los índices según las condiciones de simetría que se le hayan
     impuesto. Si `allsym' vale `true' entonces todos los índices se
     consideran simétricos, en otro caso se utilizará la información
     sobre simetrías suministrada por `decsym'. Los índices mudos se
     renombran de la misma manera que en la función `rename'. Cuando
     `canform' se aplica a una expresión grande el cálculo puede llevar
     mucho tiempo. Este tiempo se puede acortar llamando primero  a
     `rename'.  Véase también el ejemplo de la descripción de `decsym'.
     La función `canform' puede que no reduzca completamente una
     expresión a su forma más sencilla, pero en todo caso devolverá un
     resultado matemáticamente correcto.

28.2.3 Cálculo tensorial indexado
---------------------------------

 -- Función: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Se trata de la función de Maxima para la diferenciación, ampliada
     para las necesidades del paquete `itensor'. Calcula la derivada de
     <expr> respecto de <v_1> <n_1> veces, respecto de <v_2> <n_2>
     veces, etc. Para el paquete de tensores,la función ha sido
     modificada de manera que <v_i> puedan ser enteros desde 1 hasta el
     valor que tome la variable `dim'. Esto permite que la derivación
     se pueda realizar con respecto del <v_i>-ésimo miembro de la lista
     `vect_coords'. Si `vect_coords' guarda una variable atómica,
     entonces esa variable será la que se utilice en la derivación. Con
     esto se hace posible la utilización de una lista con nombres de
     coordenadas subindicadas, como `x[1]', `x[2]', ...

 -- Función: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Diferenciación inicial. Al contrario que `diff', que deriva
     respecto de una variable independiente, `idiff' puede usarse para
     derivar respecto de una coordenada.  La función `idiff' también
     puede derivar el determinante del tensor métrico. Así, si
     `imetric' toma el valor `G' entonces `idiff(determinant(g),k)'
     devolverá `2*determinant(g)*ichr2([%i,k],[%i])' donde la índice
     mudo `%i' se escoge de forma apropiada.

 -- Función: liediff (<v>, <ten>)
     Calcula la derivada de Lie de la expresión tensorial <ten>
     respecto de campo vectorial <v>. La expresión <ten> debe ser
     cualquier tensor indexado; <v> debe ser el nombre (sin índices) de
     un campo vectorial. Por ejemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                          %1  k        %1  k      %1  k
                                      + (v   b      - b   v    + v   b   ) a
                                              ,%1 l    ,l  ,%1    ,l  ,%1   i j


 -- Función: rediff (<ten>)
     Calcula todas las instrucciones `idiff' que aparezcan en la
     expresión tensorial <ten>.


 -- Función: undiff (<expr>)
     Devuelve una expresión equivalente a <expr> pero con todas las
     derivadas de los objetos indexados reemplazadas por la forma
     nominal de la función `idiff'.

 -- Función: evundiff (<expr>)
     Equivale a `undiff' seguido de  `ev' y `rediff'.

     La razón de esta operación es evaluar de forma sencilla
     expresiones que no pueden ser directamente evaluadas en su forma
     derivada. Por ejemplo, lo siguiente provoca un error:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     Sin embargo, si `icurvature' se da en forma nominal, puede ser
     evaluada utilizando `evundiff':

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                          l              l         %1           l           %1
                   + ichr2        + ichr2     ichr2      + ichr2       ichr2
                          i j,k m        %1 k      i j,m        %1 k,m      i j


 -- Función: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Iguala a cero en la expresión <expr> todas las apariciones de
     <tensor_i> que no tengan índices de derivadas.


 -- Función: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Iguala a cero en la expresión <expr> todas las apariciones de
     <tensor_i> que tengan índices de derivadas


 -- Función: flushnd (<expr>, <tensor>, <n>)
     Iguala a cero en <expr> todas las apariciones del objeto
     diferenciado  <tensor> que tenga <n> o más índices de derivadas,
     como demuestra el siguiente ejemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- Función: coord (<tensor_1>, <tensor_2>, ...)
     Le da a <tensor_i> la propiedad de diferenciación coordenada, que
     la derivada del vector contravariante cuyo nombre es uno de los
     <tensor_i> es igual a la delta de Kronecker.  Por ejemplo, si se
     ha hecho `coord(x)' entonces  `idiff(x([],[i]),j)' da
     `kdelta([i],[j])'. La llamada `coord' devuelve una lista de todos
     los objetos indexados con esta propiedad.


 -- Función: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Función: remcoord (all)
     Borra todas las propiedades de diferenciación coordenada de
     `tensor_i' que hayan sido establecidas por la función `coord'. La
     llamada `remcoord(all)' borra esta propiedad de todos los objetos
     indexados.


 -- Función: makebox (<expr>)
     Muestra <expr> de la misma manera que lo hace `show'; sin embargo,
     cualquier tensor de d'Alembert que aparezca en  <expr> estará
     indicado por `[]'.  Por ejemplo, `[]p([m],[n])' representa
     `g([],[i,j])*p([m],[n],i,j)'.


 -- Función: conmetderiv (<expr>, <tensor>)
     Simplifica expresiones que contengan derivadas ordinarias tanto de
     las formas covariantes como contravariantes del tensor métrico.
     Por ejemplo,  `conmetderiv' puede relacionar la derivada del
     tensor métrico contravariante con los símbolos de Christoffel,
     como se ve en el ejemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- Función: simpmetderiv (<expr>)
 -- Función: simpmetderiv (<expr>[, <stop>])
     Simplifica expresiones que contienen productos de las derivadas
     del tensor métrico. La función `simpmetderiv' reconoce dos
     identidades:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     de donde


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     y


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     que se deduce de las simetrías de los símbolos de Christoffel.

     La función `simpmetderiv' tiene un argumento opcional, el cual
     detiene la función después de la primera sustitución exitosa en un
     expresión producto. La función `simpmetderiv' también hace uso de
     la variable global <flipflag> que determina cómo aplicar una
     ordenación "canónica" a los índices de los productos.

     Todo esto se puede utilizar para conseguir buenas simplificaciones
     que serían difíciles o imposibles de conseguir, lo que se
     demuestra en el siguiente ejemplo, que utiliza explícitamente las
     simplificaciones parciales de `simpmetderiv':


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     Véase también `weyl.dem' para un ejemplo que utiliza
     `simpmetderiv' y `conmetderiv' para simplificar contracciones del
     tensor de Weyl.


 -- Función: flush1deriv (<expr>, <tensor>)
     Iguala a cero en `expr' todas las apariciones de `tensor' que
     tengan exactamente un índice derivado.


28.2.4 Tensores en espacios curvos
----------------------------------

 -- Función: imetric (<g>)
 -- Variable de sistema: imetric
     Especifica la métrica haciendo la asignación de la variable
     `imetric:<g>', además las propiedades de contracción de la métrica
     <g> se fijan ejecutando las instrucciones `defcon(<g>),
     defcon(<g>,<g>,kdelta)'. La variable `imetric', a la que no se le
     asigna ningún valor por defecto, tiene el valor de la métrica que
     se le haya asignado con la instrucción `imetric(<g>)'.


 -- Función: idim (<n>)
     Establece las dimensiones de la métrica. También inicializa las
     propiedades de antisimetría de los símbolos de Levi-Civita para la
     dimensión dada.


 -- Función: ichr1 ([<i>, <j>, <k>])
     Devuelve el símbolo de Christoffel de primera especie dado por la
     definición
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k

     Para evaluar los símbolos de Christoffel de una métrica
     determinada, a la variable  `imetric' hay que asignarle un nombre
     como en el ejemplo de la descripción de `chr2'.


 -- Función: ichr2 ([<i>, <j>], [<k>])
     Devuelve el símbolo de Christoffel de segunda especie dado por la
     definición
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- Función: icurvature ([<i>, <j>, <k>], [<h>])
     Devuelve el tensor de curvatura de Riemann en términos de los
     símbolos de Christoffel de segunda especie (`ichr2').  Se utiliza
     la siguiente notación:
                         h             h            h         %1         h
               icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                         i j k         i k,j        %1 j      i k        i j,k
                                         h          %1
                                  + ichr2      ichr2
                                         %1 k       i j

 -- Función: covdiff (<expr>, <v_1>, <v_2>, ...)
     Devuelve la derivada covariante de <expr> respecto de las
     variables  <v_i> en términos de los símbolos de Christoffel de
     segunda especie (`ichr2'). Para evaluarlos debe hacerse
     `ev(<expr>,ichr2)'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the covariant indices: [i,j];
          Enter a list of the contravariant indices: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k            k     %1
          (%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
                       i %1      j s    %1 j      i s    i j,s        %1 s  i j
          (%i4) imetric:g;
          (%o4)                                  g
          (%i5) ishow(ev(%th(2),ichr2))$
                   %1 %4  k
                  g      a     (g       - g       + g      )
                          i %1   s %4,j    j s,%4    j %4,s
          (%t5) - ------------------------------------------
                                      2
              %1 %3  k
             g      a     (g       - g       + g      )
                     %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                                 2
              k %2  %1
             g     a    (g        - g        + g       )
                    i j   s %2,%1    %1 s,%2    %1 %2,s     k
           + ------------------------------------------- + a
                                  2                         i j,s


 -- Función: lorentz_gauge (<expr>)
     Impone la condición de Lorentz sustituyendo por 0 todos los
     objetos indexados de <expr> que tengan un índice derivado idéntico
     a un índice contravariante.


 -- Función: igeodesic_coords (<expr>, <nombre>)
     Elimina los símbolos no diferenciados de Christoffel y las
     primeras derivadas del tensor métrico de <expr>. El argumento
     <nombre> de la función `igeodesic_coords' se refiere a la métrica
     <nombre> si aparece en <expr>, mientras que los coeficientes de
     conexión deben tener los nombres  `ichr1' y/o `ichr2'. El
     siguiente ejemplo hace la verificación de la identidad cíclica
     satisfecha por el tensor de curvatura de Riemann haciendo uso de
     la función `igeodesic_coords'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u            u         %1
          (%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
                       r t,s        %1 s      r t        r s,t        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t        r t,s

                                                                            u
                                                                     + ichr2
                                                                            r s,t
          (%i5) canform(%);
          (%o5)                                  0


28.2.5 Sistemas de referencia móviles
-------------------------------------

Maxima puede hacer cálculos utilizando sistemas de referencia móviles,
los cuales pueden ser ortonormales o cualesquiera otros.

   Para utilizar sistemas de referencia, primero se debe asignar a la
variable `iframe_flag' el valor `true'. Con esto se hace que los
símbolos de Christoffel, `ichr1' y `ichr2', sean reemplazados por los
coeficientes `icc1' y `icc2' en los cálculos, cambiando así el
comportamiento de `covdiff' y `icurvature'.

   El sistema de referencia se define con dos tensores: el campo del
sistema de referencia inverso (`ifri', la base dual tetrad) y la
métrica del sistema de referencia `ifg'. La métrica del sistema de
referencia es la matriz identidad en los sistemas de referencia
ortonormales, o la métrica de Lorentz en sistemas de referencia
ortonormales en el espacio-tiempo de Minkowski.  El campo del sistema
de referencia inverso define la base del sistema de referencia con
vectores unitarios. Las propiedades contractivas se definen para el
campo y la métrica del sistema de referencia.

   Si `iframe_flag' vale `true', muchas expresiones de `itensor'
utilizan la métrica `ifg' en lugar de la métrica definida por `imetric'
para incrementar y reducir índices.

   IMPORTANTE: Asignando a la variable `iframe_flag' el valor `true' NO
deshace las propiedades contractivas de una métrica establecidas con
una llamada a `defcon' o a `imetric'. Si se utiliza el campo del
sistema de referencia, es mejor definir la métrica asignando su nombre
a la variable  `imetric' y NO hacer una llamada a la función `imetric'.

   Maxima utiliza estos dos tensores para definir los coeficientes del
sistema de referencia: `ifc1' y and `ifc2', los cuales forman parte de
los coeficientes de conexión `icc1' y `icc2', tal como demuestra el
siguiente ejemplo:


     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                             %1      i           i        i
     (%t4)                  v   (ifc2     + ichr2    ) + v
                                     %1 j        %1 j     ,j
     (%i5) ishow(ev(%,ifc2))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t5)      -------------------------------------------------- + v
                                        2                             ,j
     (%i6) ishow(ifb([a,b,c]))$
                            %5    %4
     (%t6)               ifr   ifr   (ifri        - ifri       )
                            a     b       c %4,%5       c %5,%4

   Se utiliza un método alternativo  para calcular el sistema de
referencia `ifb' si la variable `iframe_bracket_form' vale `false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                            %7    %6        %6      %7
     (%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                            a     b,%7      a,%7    b       c %6

 -- Variable: ifb
     Es el sistema de referencia soporte. La contribución de la métrica
     del campo a los coeficientes de conexión se expresa utilizando:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     El sistema de referencia soporte se define en términos del campo y
     la métrica del sistema de referencia. Se utilizan dos métodos
     alternativos dependiendo del valor de `frame_bracket_form'. Si
     vale `true' (que es el valor por defecto) o si `itorsion_flag'
     vale `true':


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e

     En otro caso:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d


 -- Variable: icc1
     Coeficientes de conexión de primera especie. Se definen en
     `itensor' como


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     En esta expresión, si `iframe_flag' vale `true', el símbolo de
     Christoffel `ichr1' se reemplaza por el coeficiente de conexión
     del sistema de referencia `ifc1'. Si `itorsion_flag' vale `false',
     `ikt1' será omitido. También se omite si se utiliza una base, ya
     que la torsión ya está calculada como parte del sistema de
     referencia.


 -- Variable: icc2
     Coeficientes de conexión de segunda especie. Se definen en
     `itensor' como


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     En esta expresión, si la variable `iframe_flag' vale `true', el
     símbolo de Christoffel `ichr2' se reemplaza por el coeficiente de
     conexión del sistema de referencia `ifc2'. Si `itorsion_flag' vale
     `false', `ikt2' se omite. También se omite si se utiliza una base
     de referncia. Por último, si  `inonmet_flag' vale `false', se
     omite `inmc2'.


 -- Variable: ifc1
     Coeficiente del sistema de referencia de primera especie, también
     conocido como coeficientes de rotación de Ricci. Este tensor
     represnta la contribución de la métrica del sistema de referencia
     al coeficiente de conexión de primera especie, definido como


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- Variable: ifc2
     Coeficiente del sistema de referencia de primera especie. Este
     tensor representa la contribución de la métrica del sistema de
     referencia al coeficiente de conexión de primera especie, definido
     como


              c       cd
          ifc2   = ifg   ifc1
              ab             abd


 -- Variable: ifr
     El campo del sistema de referencia. Se contrae con el campo
     inverso `ifri' para formar la métrica del sistema de referencia,
     `ifg'.


 -- Variable: ifri
     Campo inverso del sistema de referencia. Especifica la base del
     sistema de referencia (vectores de la base dual).


 -- Variable: ifg
     La métrica del sistema de referencia. Su valor por defecto es
     `kdelta', pero puede cambiarse utilizando `components'.


 -- Variable: ifgi
     La métrica inversa del sistema de referencia. Se contrae con la
     métrica `ifg' para dar `kdelta'.


 -- Variable opcional: iframe_bracket_form
     Valor por defecto: `true'

     Especifica cómo se calcula `ifb'.


28.2.6 Torsión y no metricidad
------------------------------

Maxima trabaja con conceptos como la torsión y la no metricidad. Cuando
la variable `itorsion_flag' vale `true', la contribución de la torsión
se añade a los coeficientes de conexión. También se añaden las
componentes de no metricidad cuando `inonmet_flag' vale  `true'.

 -- Variable: inm
     Vector de no metricidad. La no metricidad conforme se define a
     partir de la derivada covariante del tensor métrico. La derivada
     covariante del tensor métrico, que normalmente es nula, se
     calcula, cuando `inonmet_flag' vale `true', como

          g     =- g  inm
           ij;k     ij   k


 -- Variable: inmc1
     Permutación covariante de las componentes del vector de no
     metricidad. Se define como


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Sustitúyase `g' por `ifg' si se utiliza una métrica para el
     sistema de referencia.)


 -- Variable: inmc2
     Permutación contravariante de las componentes del vector de no
     metricidad. Se utiliza en los coeficientes de conexión si
     `inonmet_flag' vale `true'. Se define como


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Sustitúyase `g' por `ifg' si se utiliza una métrica para el
     sistema de referencia.)


 -- Variable: ikt1
     Permutación covariante del tensor de permutación, también conocido
     como contorsión. Se define como


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Sustitúyase `g' por `ifg' si se utiliza una métrica para el
     sistema de referencia.)


 -- Variable: ikt2
     Permutación contravariante del tensor de permutación, también
     conocido como contorsión. Se define como


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Sustitúyase `g' por `ifg' si se utiliza una métrica para el
     sistema de referencia.)


 -- Variable: itr
     Tensor de torsión. Para una métrica con torsión, la diferenciación
     covariante iterada de una función escalar no conmuta, tal como
     demuestra el siguiente ejemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j


28.2.7 Álgebra exterior
-----------------------

Con el paquete `itensor' se pueden realizar operaciones en campos
tensoriales covariantes antisimétricos. Un campo tensorial totalmente
antisimétrrico de rango (0,L) se corresponde con una L-forma
diferencial. Sobre estos objetos se define una operación que se llama
producto exterior.

   Desafortunadamente no hay consenso entre los autores a la hora de
definir el producto exterior. Algunos autores prefieren una definición
que se corresponde con la noción de antisimetrización, con lo que el
producto externo de dos campos vectoriales se definiría como

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

   De forma más general, el producto de una p-forma por una q-forma se
definiría como

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

   donde `D' es la delta de Kronecker.

   Otros autores, sin embargo, prefieren una definición "geométrica"
que se corresponde con la noción del elemento de volumen,

     a  /\ a  = a a  - a a
      i     j    i j    j i

   y, en el caso general,

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

   Puesto que `itensor' un paquete de álgebra tensorial, la primera de
estas dos definiciones parece la más natural. Sin embargo, muchas
aplicaciones hacen uso de la segunda definición. Para resolver el
dilema, se define una variable que controla el comportamiento del
producto exteriort: si `igeowedge_flag' vale `false' (el valor por
defecto), se utiliza la primera definición, si vale `true', la segunda.

 -- Operador: ~
     El operador del producto exterior se representa por el símbolo
     `~'. Este es un operador binario. Sus argumentos deben ser
     expresiones que tengan escalares, tensores covariantes de rango
     uno o tensores covariantes de rango `l' que hayan sido declarados
     antisimétricos en todos los índices covariantes.

     El comportamiento del operador del producto exterior se controla
     con la variable `igeowedge_flag', como en el ejemplo siguiente:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j


 -- Operador: |
     La barra vertical `|' representa la operación "contraciíon con un
     vector". Cuando un tensor covariante totalmente antisimétrico se
     contrae con un vector contravariante, el resultado no depende del
     índice utilizado para la contracción. Así, es posible definir la
     operación de contracción de forma que no se haga referencia al
     índice.

     En el paquete `itensor' la contracción con un vector se realiza
     siempre respecto del primer índice de la ordenación literal.
     Ejemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Nótese que es primordial que los tensores utilizados junto con el
     operador `|' se declaren totalmente antisimétricos en sus  índices
     covariantes. De no ser así, se pueden obtener resultados
     incorrectos.


 -- Función: extdiff (<expr>, <i>)
     Calcula la derivada exterior de <expr> con respecto del índice
     <i>. La derivada exterior se define formalmente como el producto
     exterior del operador de la derivada parcial y una forma
     diferencial. Por lo tanto, esta operación también se ve afectada
     por el valor que tome la variable `igeowedge_flag'. Ejemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                      a      - a      + a
                                      j k,i    i k,j    i j,k


 -- Función: hodge (<expr>)
     Calcula el dual de Hodge  <expr>. Por ejemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g        g
                                                               %1 %106  %2 %107
                                                      g        g      A        /6
                                                       %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108


 -- Variable opcional: igeowedge_flag
     Valor por defecto: `false'

     Controla el comportamiento del producto exterior y de la derivada
     exterior. Cuando vale `false', la noción de formas diferenciales
     se corresponde con el de campo tensorial covariante totalmente
     antisimétrico. Cuando vale `true', las formas diferenciales se
     corresponden con la idea de elemento de volumen.


28.2.8 Exportando expresiones en TeX
------------------------------------

El paquete `itensor' dispone de soporte limitado para exportar
expresiones con tensores a TeX. Puesto que las expresiones de `itensor'
son llamadas a funciones, puede que la instrucción habitual en Maxima,
`tex', no devuleva los resultados esperados. Se puede utlizar el
comando `tentex', que tratará de traducir expresiones tensoriales a
objetos de TeX correctamente indexados.

 -- Función: tentex (<expr>)
     Para utilizar la función `tentex', primero se debe cargar
     `tentex', tal como muestra el siguiente ejemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load(tentex);
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i            i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
                      j k      m1 l        j l      m1 k        j l,k        j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Nótese la asignación de la variable `idummyx' para evitar la
     aparición del símbolo del porcentaje en la expresión en TeX, que
     puede dar errores de compilación.

     Téngase en cuenta que esta versión de la función `tentex' es
     experimental.


28.2.9 Interactuando con ctensor
--------------------------------

El paquete `itensor' genera código Maxima que luego puede ser ejecutado
en el contexto del paquete `ctensor'. La función que se encarga de esta
tarea es `ic_convert'.

 -- Function: ic_convert (<eqn>)
     Convierte la ecuación <eqn> del entorno `itensor' a una sentencia
     de asignación de `ctensor'. Sumas implícitas sobre índices mudos
     se hacen explícitas mientras que objetos indexados se transforman
     en arreglos (los subíndices de los arreglos se ordenan poniendo
     primero los covariantes seguidos de los contravariantes. La
     derivada de un objeto indexado se reemplazará por por la forma
     nominal de `diff' tomada con respecto a `ct_coords' con el
     subíndice correspondiente al índice derivado. Los símbolos de
     Christoffel `ichr1'  `ichr2' se traducen a `lcs' y `mcs',
     respectivamente. Además, se añaden bucles `do' para la sumación de
     todos los índices libres, de manera que la sentencia traducida
     pueda ser evaluada haciendo simplemente `ev'. Los siguientes
     ejemplos muestran las funcionalidades de esta función.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m


28.2.10 Palabras reservadas
---------------------------

Las siguientes palabras son utilizadas por el paquete `itensor'
internamente, por lo que no deberían ser modificadas por el usuario:

       Palabra    Comentarios
       ------------------------------------------
       indices2() Versión interna de indices()
       conti      Lista los índices contravariantes
       covi       Lista los índices covariantes
       deri       Lista los índices de derivadas
       name       Devuelve el nombre de un objeto indexado
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: ctensor,  Next: atensor,  Prev: itensor,  Up: Top

29 ctensor
**********

* Menu:

* Introducción a ctensor::
* Definiciones para ctensor::


File: maxima.info,  Node: Introducción a ctensor,  Next: Definiciones para ctensor,  Prev: ctensor,  Up: ctensor

29.1 Introducción a ctensor
===========================

El paquete `ctensor' dispone de herramientas para manipular componentes
de tensores. Para poder hacer uso de `ctensor' es necesario cargarlo
previamente en memoria ejecutando  `load(ctensor)'. Para comenzar una
sesión interactiva con `ctensor', ejecutar la función `csetup()'.
Primero se le pregunta al usuario la dimensión de la variedad. Si la
dimensión es 2, 3 o 4, entonces la lista de coordenadas será por
defecto  `[x,y]', `[x,y,z]' o `[x,y,z,t]', respectivamente. Estos
nombres pueden cambiarse asignando una nueva lista de coordenadas a la
variable `ct_coords' (que se describe más abajo), siendo el usuario
advertido sobre este particular.  Se debe tener cuidado en evitar que
los nombres de las coordenadas entren en conflicto con los nombres de
otros objetos en Maxima.

   A continuación, el usuario introduce la métrica, bien directamente,
o desde un fichero especificando su posición ordinal.  La métrica se
almacena en la matriz `lg'. Por último, la métrica inversa se obtiene y
almacena en la matriz `ug'. También se dispone de la opción de efectuar
todos los cálculos en serie de potencias.

   Se desarrolla a continuación un ejemplo para la métrica estática,
esférica y simétrica, en coordenadas estándar, que se aplicará
posteriormente al problema de derivar las ecuaciones de vacío de
Einstein (de las que se obtiene la solución de Schwarzschild). Muchas
de las funciones de `ctensor' se mostrarán  en los ejemplos para la
métrica estándar.

     (%i1) load(ctensor);
     (%o1)      /share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Definiciones para ctensor,  Prev: Introducción a ctensor,  Up: ctensor

29.2 Definiciones para ctensor
==============================

29.2.1 Inicialización y preparación
-----------------------------------

 -- Función: csetup ()
     Es la función del paquete `ctensor' que inicializa el paquete y
     permite al usuario introducir una métrica de forma interactiva.
     Véase `ctensor' para más detalles.

 -- Función: cmetric (<dis>)
 -- Función: cmetric ()
     Es la función del paquete `ctensor' que calcula la métrica inversa
     y prepara el paquete para cálculos ulteriores.

     Si `cframe_flag' vale `false', la función calcula la métrica
     inversa `ug' a partir de la matriz `lg' definida por el usuario.
     Se calcula también la métrica determinante y se almacena en la
     variable `gdet'. Además, el paquete determina si la métrica es
     diagonal y ajusta el valor de `diagmetric' de la forma apropiada.
     Si el argumento opcional <dis> está presente y no es igual a
     `false', el usuario podrá ver la métrica inversa.

     Si `cframe_flag' vale `true', la función espera que los valores de
     `fri' (la matriz del sistema de referencia inverso) y `lfg' (la
     matriz del sistema de referencia) estén definidos. A partir de
     ellos, se calculan la matriz del sistema de referencia `fr' y su
     métrica `ufg'.


 -- Función: ct_coordsys (<sistema_coordenadas>, <extra_arg>)
 -- Función: ct_coordsys (<sistema_coordenadas>)
     Prepara un sistema de coordenadas predefinido y una métrica. El
     argumento <sistema_coordenadas> puede ser cualquiera de los
     siguientes símbolos:


            Símbolo              Dim Coordenadas       Descripción/comentarios
            --------------------------------------------------------------------------------
            cartesian2d           2  [x,y]             Sistema de coordenadas cartesianas en 2D
            polar                 2  [r,phi]           Sistema de coordenadas polares
            elliptic              2  [u,v]             Sistema de coordenadas elípticas
            confocalelliptic      2  [u,v]             Coordenadas elípticas confocales
            bipolar               2  [u,v]             Sistema de coordenas bipolares
            parabolic             2  [u,v]             Sistema de coordenadas parabólicas
            cartesian3d           3  [x,y,z]           Sistema de coordenadas cartesianas en 3D
            polarcylindrical      3  [r,theta,z]       Polares en 2D con cilíndrica z
            ellipticcylindrical   3  [u,v,z]           Elípticas en 2D con cilíndrica z
            confocalellipsoidal   3  [u,v,w]           Elipsoidales confocales
            bipolarcylindrical    3  [u,v,z]           Bipolares en 2D con cilíndrica z
            paraboliccylindrical  3  [u,v,z]           Parabólicas en 2D con cilíndrica z
            paraboloidal          3  [u,v,phi]         Coordenadas paraboloidales
            conical               3  [u,v,w]           Coordenadas cónicas
            toroidal              3  [u,v,phi]         Coordenadas toroidales
            spherical             3  [r,theta,phi]     Sistema de coordenadas esféricas
            oblatespheroidal      3  [u,v,phi]         Coordenadas esferoidales obleadas
            oblatespheroidalsqrt  3  [u,v,phi]
            prolatespheroidal     3  [u,v,phi]         Coordenadas esferoidales prolatas
            prolatespheroidalsqrt 3  [u,v,phi]
            ellipsoidal           3  [r,theta,phi]     Coordenadas elipsoidales
            cartesian4d           4  [x,y,z,t]         Sistema de coordenadas cartesianas en 4D
            spherical4d           4  [r,theta,eta,phi] Sistema de coordenadas esféricas en 4D
            exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
            interiorschwarzschild 4  [t,z,u,v]         Métrica interior de Schwarzschild
            kerr_newman           4  [t,r,theta,phi]   Métrica simétrica con carga axial

     El argumento `sistema_coordenadas' puede ser también una lista de
     funciones de transformación, seguida de una lista que contenga los
     nombres de las coordenadas. Por ejemplo, se puede especificar una
     métrica esférica como se indica a continuación:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Las funciones de transformación se pueden utilizar también si
     `cframe_flag' vale `true':


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
                [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
                [                                                                       ]
          (%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
                [                                                                       ]
                [     sin(theta)            r cos(theta)                   0            ]
          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     El argumento opcional <extra_arg> puede ser cualquiera de los
     siguientes:

     `cylindrical' indica a `ct_coordsys' que añada una coordenada
     cilíndrica más.

     `minkowski' indica a  `ct_coordsys' que añada una coordenada más
     con signatura métrica negativa.

     `all' indica a  `ct_coordsys' que llame a  `cmetric' y a
     `christof(false)' tras activar la métrica.

     Si la variable global `verbose' vale `true', `ct_coordsys' muestra
     los valores de `dim', `ct_coords', junto con `lg' o `lfg' y `fri',
     dependiendo del valor de `cframe_flag'.


 -- Función: init_ctensor ()
     Inicializa el paquete `ctensor'.

     La función `init_ctensor' reinicializa el paquete `ctensor'. Borra
     todos los arreglos ("arrays") y matrices utilizados por `ctensor'
     y reinicializa todas las variables, asignando a `dim' el valor 4 y
     la métrica del sistema de referencia a la de Lorentz.


29.2.2 Los tensores del espacio curvo
-------------------------------------

El propósito principal del paquete `ctensor' es calcular los tensores
del espacio (-tiempo) curvo, en especial los tensores utilizados en
relatividad general.

   Cuando se utiliza una métrica, `ctensor' puede calcular los
siguientes tensores:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem

   El paquete `ctensor' también puede trabajar con sistemas de
referencia móviles. Si `cframe_flag' vale `true', se pueden calcular
los siguientes tensores:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Función: christof (<dis>)
     Es una función del paquete `ctensor'. Calcula los símbolos de
     Christoffel de ambos tipos. El argumento <dis> determina qué
     resultados se mostrarán de forma inmediata. Los símbolos de
     Christoffel de primer y segundo tipo se almacenan en los arreglos
     `lcs[i,j,k]' y `mcs[i,j,k]', respectivamente, y se definen
     simétricos en sus dos primeros índices. Si el argumento de
     `christof' es `lcs' o `mcs' entonces serán mostrados únicamente
     los valores no nulos de `lcs[i,j,k]' o `mcs[i,j,k]',
     respectivamente. Si el argumento es `all' entonces se mostrarán
     los valores no nulos de `lcs[i,j,k]' y `mcs[i,j,k]'.  Si el
     argumento vale `false' entonces no se mostrarán los elementos. El
     arreglo `mcs[i,j,k]' está definido de tal modo que el último
     índice es contravariante.

 -- Función: ricci (<dis>)
     Es una función del paquete `ctensor'. La función `ricci' calcula
     las componentes covariantes (simétricas) `ric[i,j]' del tensor de
     Ricci. Si el argumento <dis> vale `true', entonces se muestran las
     componentes no nulas.

 -- Función: uricci (<dis>)
     Esta función calcula en primer lugar las componentes covariantes
     `ric[i,j]' del tensor de Ricci. Después se calcula el tensor de
     Ricci utilizando la métrica contravariante. Si el valor del
     argumento <dis> vale `true', entonces se mostrarán directamente
     las componentes `uric[i,j]' (el índice <i> es covariante y el <j>
     contravariante). En otro caso,  `ricci(false)' simplemente
     calculará las entradas del arreglo `uric[i,j]' sin mostrar los
     resultados.


 -- Función: scurvature ()
     Devuelve la curvatura escalar (obtenida por contracción del tensor
     de Ricci) de la variedad de Riemannian con la métrica dada.


 -- Función: einstein (<dis>)
     Es una función del paquete `ctensor'. La función  `einstein'
     calcula el tensor de Einstein después de que los símbolos de
     Christoffel y el tensor de Ricci hayan sido calculados (con las
     funciones `christof' y `ricci').  Si el argumento <dis> vale
     `true', entonces se mostrarán los valores no nulos del tensor de
     Einstein `ein[i,j]', donde `j' es el índice contravariante. La
     variable `rateinstein' causará la simplificación racional de estas
     componentes. Si `ratfac' vale `true' entonces las componentes
     también se factorizarán.


 -- Función: leinstein (<dis>)
     Es el tensor covariante de Einstein. La función `leinstein'
     almacena los valores del tensor covariante de Einstein en el
     arreglo `lein'. El tensor covariante de Einstein se calcula a
     partir del tensor de Einstein `ein' multiplicándolo por el tensor
     métrico. Si el argumento  <dis> vale `true', entonces se mostrarán
     los valores no nulos del tensor covariante de Einstein.


 -- Función: riemann (<dis>)
     Es una función del paquete `ctensor'. La función `riemann' calcula
     el tensor de curvatura de Riemann a partir de la métrica dada y de
     los símbolos de Christoffel correspondientes. Se utiliza el
     siguiente convenio sobre los índices:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     Esta notación es consistente con la notación utilizada por el
     paquete `itensor' y su función `icurvature'. Si el argumento
     opcional <dis> vale `true', se muestran las componentes no nulas
     de `riem[i,j,k,l]'. Como en el caso del tensor de Einstein,
     ciertas variables permiten controlar al usuario la simplificación
     de las componentes del tensor de Riemann. Si  `ratriemann' vale
     `true', entonces se hará la simplificación racional. Si `ratfac'
     vale `true', entonces se factorizarán todas las componentes.

     Si la variable `cframe_flag' vale `false', el tensor de Riemann se
     calcula directamente a partir de los símbolos de Christoffel. Si
     `cframe_flag' vale `true', el tensor covariante de Riemann se
     calcula a partir de los coeficientes del campo.


 -- Función: lriemann (<dis>)
     Es el tensor covariante de Riemann (`lriem[]').

     Calcula el tensor covariante de Riemann como un arreglo `lriem'.
     Si el argumento <dis> vale `true', sólo se muestran los valores no
     nulos.

     Si la variable `cframe_flag' vale `true', el tensor covariante de
     Riemann se calcula directamente de los coeficientes del campo. En
     otro caso, el tensor de Riemann (3,1) se calcula en primer lugar.

     Para más información sobre la ordenación de los índices, véase
     `riemann'.


 -- Función: uriemann (<dis>)
     Calcula las componentes contravariantes del tensor de curvatura de
     Riemann como un arreglo `uriem[i,j,k,l]'.  Éstos se muestran si
     <dis> vale `true'.


 -- Función: rinvariant ()
     Calcula la invariante de Kretchmann (`kinvariant') obtenida por
     contracción de los tensores.

          lriem[i,j,k,l]*uriem[i,j,k,l].

     Este objeto no se simplifica automáticamente al ser en ocasiones
     muy grande.


 -- Función: weyl (<dis>)
     Calcula el tensor conforme de Weyl. Si el argumento <dis> vale
     `true', se le mostrarán al usuario las componentes no nulas
     `weyl[i,j,k,l]'. En otro caso, estas componentes serán únicamente
     calculadas y almacenadas. Si la variable `ratweyl' vale `true',
     entonces las componentes se simplifican racionalmente; si `ratfac'
     vale `true' los resultados también se simplificarán.


29.2.3 Desarrollo de Taylor
---------------------------

El paquete `ctensor' puede truncar resultados e interpretarlos como
aproximaciones de Taylor. Este comportamiento se controla con
lavariable `ctayswitch'; cuando vale `true', `ctensor' utiliza
internamente la función `ctaylor' cuando simplifica resultados.

   La función `ctaylor' es llamada desde las siguientes funciones del
paquete `ctensor':


         Función      Comentarios
         ---------------------------------
         christof()   Sólo para mcs
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Función: ctaylor ()
     La función `ctaylor' trunca su argumento convirtiéndolo en un
     desarrollo de Taylor por medio de la función `taylor' e invocando
     después a `ratdisrep'. Esto tiene el efecto de eliminar términos
     de orden alto en la variable de expansión `ctayvar'. El orden de
     los términos que deben ser eliminados se define `ctaypov'; el
     punto alrededor del cual se desarrolla la serie se especifica en
     `ctaypt'.

     Como ejemplo, considérese una sencilla métrica que es una
     perturbación de la de Minkowski. Sin añadir restricciones, incluso
     una métrica diagonal produce expansiones del tensor de Einstein
     que pueden llegar a ser muy complejas:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                   [ h11 l - 1      0          0                 0            ]
                   [                                                          ]
                   [     0      h22 l + 1      0                 0            ]
                   [                                                          ]
          (%o8)    [                        2                                 ]
                   [     0          0      r  + h33 l            0            ]
                   [                                                          ]
                   [                                    2    2                ]
                   [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     Sin embargo, si se recalcula este ejemplo como una aproximación
     lineal en la variable `l', se obtienen expresiones más sencillas:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                          2               2      4    2
                            - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                     r r                r

     Esta capacidad del paquete `ctensor' puede ser muy útil; por
     ejemplo, cuando se trabaja en zonas del campo gravitatorio
     alejadas del origen de éste.


29.2.4 Campos del sistema de referencia
---------------------------------------

Cuando la variable `cframe_flag' vale `true', el paquete `ctensor'
realiza sus cálculos utilizando un sistema de referencia móvil.

 -- Función: frame_bracket (<fr>, <fri>, <diagframe>)
     Es el sistema de referencia soporte (`fb[]').

     Calcula el soporte del sistema de referencia de acuerdo con la
     siguiente definición:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b


29.2.5 Clasificación algebraica
-------------------------------

Una nueva funcionalidad (Noviembre de 2004) de `ctensor' es su
capacidad de obtener la clasificación de Petrov de una métrica
espaciotemporal de dimensión 4. Para una demostración de esto véase el
fichero `share/tensor/petrov.dem'.

 -- Función: nptetrad ()
     Calcula la cuaterna nula de Newman-Penrose (`np'). Véase `petrov'
     para un ejemplo.

     La cuaterna nula se construye bajo la suposición de que se está
     utilizando una métrica tetradimensional ortonormal con signatura
     métrica (-,+,+,+). Los componentes de la cuaterna nula se
     relacionan con la inversa de la matriz del sistema de referencia
     de la siguiente manera:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4


 -- Función: psi (<dis>)
     Calcula los cinco coeficientes de Newman-Penrose
     `psi[0]'...`psi[4]'. Si `psi' vale `true', se muestran estos
     coeficientes. Véase `petrov' para un ejemplo.

     Estos coeficientes se calculan a partir del tensor de Weyl.


 -- Función: petrov ()
     Calcula la clasificación de  Petrov de la métrica caracterizada
     por `psi[0]'...`psi[4]'.

     Por ejemplo, lo que sigue demuestra cómo obtener la clasificación
     de Petrov para la métrica de Kerr:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

                 [  sqrt(r - 2 m)           sqrt(r)                                     ]
                 [ ---------------   ---------------------      0             0         ]
                 [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
                 [                                                                      ]
                 [  sqrt(r - 2 m)            sqrt(r)                                    ]
                 [ ---------------  - ---------------------     0             0         ]
                 [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
                 [                                                                      ]
                 [                                              r      %i r sin(theta)  ]
                 [        0                    0             -------   ---------------  ]
                 [                                           sqrt(2)       sqrt(2)      ]
                 [                                                                      ]
                 [                                              r       %i r sin(theta) ]
                 [        0                    0             -------  - --------------- ]
                 [                                           sqrt(2)        sqrt(2)     ]

                                       sqrt(r)          sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------, ---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     La función de clasificación de Petrov se basa en el algoritmo
     publicado en "Classifying geometries in general relativity: III
     Classification in practice" de Pollney, Skea, and d'Inverno,
     Class. Quant. Grav. 17 2885-2902 (2000).  Excepto para algunos
     ejemplos sencillos, esta implementación no ha sido exhaustivamente
     probada, por lo que puede contener errores.


29.2.6 Torsión y no metricidad
------------------------------

El paquete `ctensor' es capaz de calcular e incluir coeficientes de
torsión y no metricidad en los coeficientes de conexión.

   Los coeficientes de torsión se calculan a partir de un tensor
suministrado por el usuario, `tr', el cual debe ser de rango (2,1). A
partir de ahí, los coeficientes de torsión `kt' se calculan de acuerdo
con las siguientes fórmulas:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

   Los coeficientes de no metricidad se calculan a partir de un vector
de no metricidad, `nm', suministrado por el usuario. A partir de ahí,
los coeficientes de no metricidad, `nmc', se calculan como se indica a
continuación:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

   donde D es la delta de Kronecker.

 -- Función: contortion (<tr>)
     Calcula los coeficientes (2,1) de contorsión del tensor de torsión
     <tr>.


 -- Función: nonmetricity (<nm>)
     Calcula los coeficientes (2,1) de no metricidad del vector de no
     metricidad <nm>.


29.2.7 Otras funcionalidades
----------------------------

 -- Función: ctransform (<M>)
     Es una función del paquete `ctensor'.  Realiza una transformación
     de coordenadas a partir de una matriz cuadrada simétrica <M>
     arbitraria. El usuario debe introducir las funciones que definen
     la transformación.


 -- Función: findde (<A>, <n>)
     Devuelve la lista de las ecuaciones diferenciales que corresponden
     a los elementos del arreglo cuadrado <n>-dimensional. El argumento
     <n> puede ser 2 ó 3; `deindex' es una lista global que contiene
     los índices de <A> que corresponden a estas ecuaciones
     diferenciales. Para el tensor de Einstein (`ein'), que es un
     arreglo bidimensional, si se calcula para la métrica del ejemplo
     de más abajo, `findde' devuelve las siguientes ecuaciones
     diferenciales independientes:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
                  x                     x x         x        x    x            x

                                                                  2          2
                                                          - 2 a  d , a  x + a  - a]
                                                               x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]


 -- Función: cograd ()
     Calcula el gradiente covariante de una función escalar permitiendo
     al usuario elegir el nombre del vector correspondiente, como
     ilustra el ejemplo que acompaña a la definición de la función
     `contragrad'.

 -- Function: contragrad ()
     Calcula el gradiente contravariante de una función escalar
     permitiendo al usuario elegir el nombre del vector
     correspondiente, tal como muestra el siguiente ejemplo para la
     métrica de Schwarzschild:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r


 -- Función: dscalar ()
     Calcula el tensor de d'Alembertian de la función escalar una vez
     se han declarado las dependencias. Por ejemplo:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r


 -- Función: checkdiv ()
     Calcula la divergencia covariante del tensor de segundo rango
     (mixed second rank tensor), cuyo primer índice debe ser
     covariante, devolviendo las `n' componentes correspondientes del
     campo vectorial (la divergencia), siendo `n = dim'.

 -- Función: cgeodesic (<dis>)
     Es una función del paquete `ctensor' que calcula las ecuaciones
     geodésicas del movimiento para una métrica dada, las cuales se
     almacenan en el arreglo `geod[i]'. Si el argumento  <dis> vale
     `true' entonces se muestran estas ecuaciones.


 -- Función: bdvac (<f>)
     Genera las componentes covariantes de las ecuaciones del campo
     vacío de la teoría gravitacional de Brans- Dicke gravitational. El
     campo escalar se especifica con el argumento  <f>, el cual debe
     ser el nombre de una función no evaluada (precedida de apóstrofo)
     con dependencias funcionales, por ejemplo,  `'p(x)'.

     Las componentes del tensor covariante (second rank covariant field
     tensor) se almacenan en el arreglo `bd'.


 -- Función: invariant1 ()
     Genera el tensor de Euler-Lagrange (ecuaciones de campo) para la
     densidad invariante de  R^2. Las ecuaciones de campo son las
     componentes del arreglo `inv1'.


29.2.8 Utilidades
-----------------

 -- Función: diagmatrixp (<M>)
     Devuelve `true' si <M> es una matriz diagonal o un arreglo
     bidimensional.


 -- Función: symmetricp (<M>)
     Devuelve `true' si <M> es una matriz simétrica o un arreglo
     bidimensional.


 -- Función: ntermst (<f>)
     Permite hacerse una idea del tamaño del tensor <f>.

 -- Función: cdisplay (<ten>)
     Muestra todos los elementos del tensor <ten> como arreglo
     multidimensional. Tensors de rango 0 y 1, así como otros tipos de
     variables, se muestran como en `ldisplay'. Tensors de rango 2 se
     muestran como matrices bidimensionales, mientras que tensores de
     mayor rango se muestran como listas de matrices bidimensionales.
     Por ejemplo, el tensor de Riemann de la métrica de Schwarzschild
     se puede ver como:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                         [ 0               0                    0            0      ]
                         [                                                          ]
                         [                              2                           ]
                         [      3 m (r - 2 m)   m    2 m                            ]
                         [ 0  - ------------- + -- - ----       0            0      ]
                         [            4          3     4                            ]
                         [           r          r     r                             ]
                         [                                                          ]
              riem     = [                                 m (r - 2 m)              ]
                  1, 1   [ 0               0               -----------       0      ]
                         [                                      4                   ]
                         [                                     r                    ]
                         [                                                          ]
                         [                                              m (r - 2 m) ]
                         [ 0               0                    0       ----------- ]
                         [                                                   4      ]
                         [                                                  r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                             [     2 m                                         ]
                             [ ------------  0        0               0        ]
                             [  2                                              ]
                             [ r  (r - 2 m)                                    ]
                             [                                                 ]
                             [      0        0        0               0        ]
                             [                                                 ]
                  riem     = [                         m                       ]
                      2, 2   [      0        0  - ------------        0        ]
                             [                     2                           ]
                             [                    r  (r - 2 m)                 ]
                             [                                                 ]
                             [                                         m       ]
                             [      0        0        0         - ------------ ]
                             [                                     2           ]
                             [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                           [        2                                             ]
                           [   m sin (theta)                                      ]
                           [ - -------------         0                0         0 ]
                           [         r                                            ]
                           [                                                      ]
                           [                         2                            ]
                           [                    m sin (theta)                     ]
                riem     = [        0         - -------------         0         0 ]
                    4, 4   [                          r                           ]
                           [                                                      ]
                           [                                          2           ]
                           [                                   2 m sin (theta)    ]
                           [        0                0         ---------------  0 ]
                           [                                          r           ]
                           [                                                      ]
                           [        0                0                0         0 ]

          (%o5)                                done

 -- Función: deleten (<L>, <n>)
     Devuelve una nueva lista consistente en <L> sin su <n>-ésimo
     elemento.

29.2.9 Variables utilizadas por `ctensor'
-----------------------------------------

 -- Variable opcional: dim
     Valor por defecto: 4

     Es la dimensión de la variedad, que por defecto será 4. La
     instrucción `dim: n' establecerá la dimensión a cualquier otro
     valor `n'.


 -- Variable opcional: diagmetric
     Valor por defecto: `false'

     Si `diagmetric' vale `true' se utilizarán rutinas especiales para
     calcular todos los objetos geométricos teniendo en cuenta la
     diagonalidad de la métrica, lo que redundará en una reducción del
     tiempo de cálculo. Esta opción se fija automáticamente por
     `csetup' si se especifica una métrica diagonal.


 -- Variable opcional: ctrgsimp
     Provoca que se realicen simplificaciones trigonométricas cuando se
     calculan tensores. La variable `ctrgsimp' afecta únicamente a
     aquellos cálculos que utilicen un sistema de referencia móvil.


 -- Variable opcional: cframe_flag
     Provoca que los cálculos se realicen respecto de un sistema de
     referencia móvil.

 -- Variable opcional: ctorsion_flag
     Obliga a que se calcule también el tensor de contorsión junto con
     los coeficientes de conexión. El propio tensor de contorsión se
     calcula con la función `contortion' a partir del tensor `tr'
     suministrado por el usuario.


 -- Variable opcional: cnonmet_flag
     Obliga a que se calculen también los coeficientes de no metricidad
     junto con los coeficientes de conexión. Los coeficientes de no
     metricidad se calculan con la función `nonmetricity' a partir del
     vector de no metricidad`nm' suministrado por el usuario.


 -- Variable opcional: ctayswitch
     Si vale `true', obliga a que ciertos cálculos de `ctensor' se
     lleven a cabo utilizando desarrollos de series de Taylor. Estos
     cálculos hacen referencia a las funciones `christof', `ricci',
     `uricci', `einstein' y `weyl'.


 -- Variable opcional: ctayvar
     Variable utilizada para desarrollos de Taylor cuando la variable
     `ctayswitch' vale `true'.


 -- Variable opcional: ctaypov
     Máximo exponente utilizado en los desarrollos de Taylor cuando
     `ctayswitch' vale `true'.


 -- Variable opcional: ctaypt
     Punto alrededor del cual se realiza un desarrollo de Taylor cuando
     `ctayswitch' vale `true'.


 -- Variable opcional: gdet
     Es el determinante del tensor métrico `lg', calculado por
     `cmetric' cuando `cframe_flag' vale `false'.


 -- Variable opcional: ratchristof
     Obliga a que la función `christof' aplique la simplificación
     racional.


 -- Variable opcional: rateinstein
     Valor por defecto: `true'

     Si vale `true' entonces se hará la simplificación racional en los
     componentes no nulos de los tensores de Einstein; si `ratfac' vale
     `true' entonces las componentes también serán factorizadas.


 -- Variable opcional: ratriemann
     Valor por defecto: `true'

     Es una de las variables que controlan la simplificación de los
     tensores de Riemann; si vale `true', entonces se llevará a cabo la
     simplificación racional; si `ratfac' vale `true' entonces las
     componentes también serán factorizadas.


 -- Variable opcional: ratweyl
     Valor por defecto: `true'

     Si vale `true', entonces la función `weyl' llevará a cabo la
     simplificación racional de los valores del tensor de Weyl. si
     `ratfac' vale `true' entonces las componentes también serán
     factorizadas.

 -- Variable: lfg
     Es la covariante de la métrica del sistema de referencia. Por
     defecto, está inicializada al sistema de referencia
     tetradimensional de Lorentz con signatura  (+,+,+,-). Se utiliza
     cuando `cframe_flag' vale `true'.

 -- Variable: ufg
     Es la métrica del sistema de referencia inverso. La calcula `lfg'
     cuando `cmetric' es invocada tomando  `cframe_flag' el valor
     `true'.

 -- Variable: riem
     Es el tensor (3,1) de Riemann. Se calcula cuando se invoca la
     función `riemann'. Para información sobre el indexado, véase la
     descripción de  `riemann'.

     Si `cframe_flag' vale `true', `riem' se calcula a partir del
     tensor covariante de Riemann `lriem'.


 -- Variable: lriem
     Es el tensor covariante de Riemann. Lo calcula la función
     `lriemann'.


 -- Variable: uriem
     Es el tensor contravariante de Riemann. Lo calcula la función
     `uriemann'.


 -- Variable: ric
     Es el tensor de Ricci. Lo calcula la función `ricci'.


 -- Variable: uric
     Es el tensor contravariante de Ricci. Lo calcula la función
     `uricci'.


 -- Variable: lg
     Es el tensor métrico. Este tensor se debe especificar (como matriz
     cuadrada de orden `dim') antes de que se hagan otros cálculos.


 -- Variable: ug
     Es la inversa del tensor métrico. Lo calcula la función `cmetric'.


 -- Variable: weyl
     Es el tensor de Weyl. Lo calcula la función `weyl'.


 -- Variable: fb
     Son los coeficientes del sistema de referencia soporte, tal como
     los calcula `frame_bracket'.


 -- Variable: kinvariant
     Es la invariante de Kretchmann, tal como la calcula la función
     `rinvariant'.


 -- Variable: np
     Es la cuaterna nula de Newman-Penrose, tal como la calcula la
     función `nptetrad'.


 -- Variable: npi
     Es la cuaterna nula "raised-index Newman-Penrose". Lo calcula la
     función `nptetrad'.  Se define como `ug.np'. El producto
     `np.transpose(npi)' es constante:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]


 -- Variable: tr
     Tensor de rango 3 suministrado por el usuario y que representa una
     torsión. Lo utiliza la función `contortion'.

 -- Variable: kt
     Es el tensor de contorsión, calculado a partir de `tr' por la
     función `contortion'.

 -- Variable: nm
     Vector de no metricidad suministrado por el usuario. Lo utiliza la
     función `nonmetricity'.

 -- Variable: nmc
     Son los coeficientes de no metricidad, calculados a partir de `nm'
     por la función `nonmetricity'.


 -- Variable del sistema: tensorkill
     Variable que indica si el paquete de tensores se ha inicializado.
     Utilizada por `csetup' y reinicializada por `init_ctensor'.


 -- Variable opcional: ct_coords
     Valor por defecto: `[]'

     La variable `ct_coords' contiene una lista de coordenadas. Aunque
     se define normalmente cuando se llama a la función `csetup',
     también se pueden redefinir las coordenadas con la asignación
     `ct_coords: [j1, j2, ..., jn]' donde  `j' es el nuevo nombre de
     las coordenadas. Véase también `csetup'.


29.2.10 Nombres reservados
--------------------------

Los siguientes nombres se utilizan internamente en el paquete `ctensor'
y no deberían redefinirse:

       Nombre       Descripción
       ---------------------------------------
       _lg()        Toma el valor `lfg' si se utiliza métrica del sistema de referencia,
                    `lg' en otro caso
       _ug()        Toma el valor `ufg' si se utiliza métrica del sistema de referencia,
                    `ug' en otro caso
       cleanup()    Elimina elementos de la lista `deindex'
       contract4()  Utilizada por `psi()'
       filemet()    Utilizada por `csetup()' cuando se lee la métrica desde un fichero
       findde1()    Utilizada por `findde()'
       findde2()    Utilizada por `findde()'
       findde3()    Utilizada por `findde()'
       kdelt()      Delta de Kronecker (no generalizada)
       newmet()     Utilizada por `csetup()' para establecer una métrica interactivamente
       setflags()   Utilizada por `init_ctensor()'
       readvalue()
       resimp()
       sermet()     Utilizada por `csetup()' para definir una métrica como serie de Taylor
       txyzsum()
       tmetric()    Métrica del sistema de referencia, utilizada por `cmetric()'
                    cuando `cframe_flag:true'
       triemann()   Tensor de Riemann en la base del sistema de referencia, se utiliza cuando
                    `cframe_flag:true'
       tricci()     Tensor de Ricci en la base del sistema de referencia, se utiliza cuando
                    `cframe_flag:true'
       trrc()       Coeficientes de rotación de Ricci, utilizada por `christof()'
       yesp()


File: maxima.info,  Node: atensor,  Next: Series,  Prev: ctensor,  Up: Top

30 atensor
**********

* Menu:

* Introducción a atensor::
* Definiciones para atensor::


File: maxima.info,  Node: Introducción a atensor,  Next: Definiciones para atensor,  Prev: atensor,  Up: atensor

30.1 Introducción a atensor
===========================

El paquete `atensor' contiene funciones para la manipulación algebraica
de tensores. Para hacer uso de `atensor' es necesario cargarlo en
memoria haciendo `load(atensor)', seguido de una llamada a la función
`init_atensor'.

   La parte más importante de `atensor' es una batería de reglas de
simplificación para el producto no conmutativo ("`.'"). El paquete
`atensor' reconoce algunos tipos de álgebras; las correspondientes
reglas de simplificación se activan tan pronto como se hace una llamada
a la función `init_atensor'.

   Las capacidades de `atensor' se pueden demostrar definiendo el
álgebra de cuaterniones como un álgebra de Clifford Cl(0,2) con una
base de dos vectores. Las tres unidades imaginarias son los dos
vectores de la base junto con su producto:

         i = v     j = v     k = v  . v
              1         2         1    2

   Aunque el paquete `atensor' incluye su propia definición para el
álgebra de cuaterniones, no se utiliza en el siguiente ejemplo, en el
cual se construye la tabla de multiplicación como una matriz:


     (%i1) load(atensor);
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  . v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  . v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  . v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  . v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  . v      v        - v       - 1   ]
                        [  1    2      2          1            ]

   El paquete `atensor' reconoce como vectores de la base símbolos
indexados, donde el símbolo es el almacenado en  `asymbol' y el índice
va desde 1 hasta `adim'. Para símbolos indexados, y sólo para ellos, se
evalúan las formas bilineales `sf', `af' y `av'. La evaluación
sustituye el valor de `aform[i,j]' en lugar de `fun(v[i],v[j])', donde
`v' representa el valor de `asymbol' y `fun' es  `af' o `sf'; o
sustituye `v[aform[i,j]]' en lugar de `av(v[i],v[j])'.

   Huelga decir que las funciones `sf', `af' y `av' pueden volver a
definirse.

   Cuando se carga el paquete `atensor' se hacen las siguientes
asignaciones de variables:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

   Si se quiere experimentar con una álgebra no asociativa, también se
puede igualar la variable  `dotassoc' a `false'. En tal caso, sin
embargo, `atensimp' no será siempre capaz de realizar las
simplificaciones deseadas.


File: maxima.info,  Node: Definiciones para atensor,  Prev: Introducción a atensor,  Up: atensor

30.2 Definiciones para atensor
==============================

 -- Función: init_atensor (<alg_type>, <opt_dims>)
 -- Función: init_atensor (<alg_type>)
     Inicializa el paquete `atensor' con el tipo de álgebra
     especificado, <alg_type>, que puede ser una de las siguientes:

     `universal': El álgebra universal no tiene reglas de conmutación.

     `grassmann': El álgebra de Grassman se define mediante la relación
     de conmutación `u.v+v.u=0'.

     `clifford': El álgebra de Clifford se define mediante la regla de
     conmutación  `u.v+v.u=-2*sf(u,v)' donde  `sf' es una función
     escalar simétrica. Para esta álgebra,  <opt_dims> puede contener
     hasta tres enteros no negativos, que representan el número de
     dimensiones positivas, degeneradas y negativas, respectivamente,
     de esta álgebra. Si se suministran los valores de <opt_dims>,
     `atensor' configurará los valores de `adim' y `aform' de forma
     apropiada. En otro caso, `adim' tomará por defecto el valor 0 y
     `aform' no se definirá.

     `symmetric': El álgebra simétrica se define mediante la regla de
     conmutación `u.v-v.u=0'.

     `symplectic': El álgebra simpléctica se define mediante la regla
     de conmutación `u.v-v.u=2*af(u,v)', donde `af' es una función
     escalar antisimétrica. Para el álgebra simpléctica, <opt_dims>
     puede contener hasta dos enteros no negativos, que representan las
     dimensiones no degeneradas y degeneradas, respectivamente. Si se
     suministran los valores de <opt_dims>, `atensor' configurará los
     valores de `adim' y `aform' de forma apropiada. En otro caso,
     `adim' tomará por defecto el valor 0 y `aform' no se definirá.

     `lie_envelop': El álgebra de la envolvente de Lie se define
     mediante la regla de conmutación `u.v-v.u=2*av(u,v)', donde `av'
     es una función antisimétrica.

     La función `init_atensor' también reconoce algunos tipos de
     álgebras predefinidas:

     `complex' implementa el álgebra de números complejos como un
     álgebra de Clifford Cl(0,1). La llamada  `init_atensor(complex)'
     equivale a `init_atensor(clifford,0,0,1)'.

     `quaternion' implementa el álgebra de cuaterniones. La llamada
     `init_atensor(quaternion)' equivale a
     `init_atensor(clifford,0,0,2)'.

     `pauli' implementa el álgebra de Pauli como un álgebra de Clifford
     Cl(3,0). La llamada `init_atensor(pauli)' equivale a
     `init_atensor(clifford,3)'.

     `dirac' implementa el álgebra de Dirac como un álgebra de Clifford
     Cl(3,1). La llamada `init_atensor(dirac)' equivale a
     `init_atensor(clifford,3,0,1)'.


 -- Función: atensimp (<expr>)
     Simplifica la expresión algebraica de un tensor  <expr> de acuerdo
     con las reglas configuradas mediante una llamada a
     `init_atensor'. La simplificación incluye la aplicación recursiva
     de las reglas de conmutación y llamadas a `sf', `af' y `av'
     siempre que sea posible. Se utiliza un algoritmo que asegure que
     la función termina siempre, incluso en el caso de expresiones
     complejas.


 -- Función: alg_type
     Tipo de álgebra. Valores válidos son `universal', `grassmann',
     `clifford', `symmetric', `symplectic' y `lie_envelop'.


 -- Variable: adim
     Valor por defecto: 0

     La dimensión del álgebra. El paquete `atensor' utiliza el valor de
     `adim' para determinar si un objeto indexado es un vector válido
     para la base. Véase `abasep'.


 -- Variable: aform
     Valor por defecto: `ident(3)'

     Valores por defecto para las formas bilineales  `sf', `af' y `av'.
     El valor por defecto es la matriz identidad `ident(3)'.


 -- Variable: asymbol
     Valor por defecto: `v'

     Símbolo para los vectores base.


 -- Función: sf (<u>, <v>)
     Una función escalar simétrica que se utiliza en relaciones de
     conmutación. La implementación por defecto analiza si los dos
     argumentos son vectores base mediante  `abasep' y en tal caso
     sustituye el valor correspondiente de la matriz  `aform'.


 -- Función: af (<u>, <v>)
     Una función escalar antisimétrica que se utiliza en relaciones de
     conmutación. La implementación por defecto analiza si los dos
     argumentos son vectores base mediante  `abasep' y en tal caso
     sustituye el valor correspondiente de la matriz  `aform'.


 -- Función: av (<u>, <v>)
     Una función antisimétrica que se utiliza en relaciones de
     conmutación. La implementación por defecto analiza si los dos
     argumentos son vectores base mediante  `abasep' y en tal caso
     sustituye el valor correspondiente de la matriz  `aform'.

     Ejemplo:

          (%i1) load(atensor);
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3


 -- Función: abasep (<v>)
     Analiza si su argumento es un vector base en `atensor'. Esto es,
     si se trata de un símbolo indexado, siendo el símbolo el mismo que
     el valor de `asymbol' y si el índice tiene un valor numérico entre
     1 y `adim'.



File: maxima.info,  Node: Series,  Next: Teoría de Números,  Prev: atensor,  Up: Top

31 Series
*********

* Menu:

* Introducción a las Series::
* Definiciones para las Series::


File: maxima.info,  Node: Introducción a las Series,  Next: Definiciones para las Series,  Prev: Series,  Up: Series

31.1 Introducción a las Series
==============================

Maxima dispone de las funciones `taylor' y `powerseries' para calcular
las series de las funciones diferenciables. También tiene herramientas
como `nusum' capaces de encontrar la expresión compacta de algunas
series. Operaciones como la suma y la multiplicación operan de la forma
habitual en el contexto de las series. Esta sección presenta las
variables globales que controlan la expansión.



Local Variables:
coding: iso-8859-1
End:
