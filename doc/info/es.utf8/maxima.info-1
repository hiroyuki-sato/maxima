This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introducción a Maxima,  Prev: (dir),  Up: (dir)

Manual de Maxima
****************

Maxima es un sistema de cálculo simbólico escrito en Lisp.

   Maxima desciende del sistema Macsyma, desarrollado en el MIT
(Massachusetts Institute of Technology) entre los años 1968 y 1982 como
parte del proyecto MAC. El MIT pasó una copia del código fuente al DOE
(Department of Energy) en 1982, en una versión conocida como
DOE-Macsyma. Una de estas copias fue mantenida por el Profesor William
F. Schelter de la Universidad de Texas desde el año 1982 hasta su
fallecimiento en 2001. En 1998 Schelter había obtenido del Departamento
de Energía permiso para distribuir el código fuente de DOE-Macsyma bajo
licencia GNU-GPL, iniciando en el año 2000 el proyecto Maxima en
SourceForge con el fin de mantener y seguir desarrollando DOE-Macsyma,
ahora con el nombre de Maxima.

   Notas de la traducción española.

   La primera traducción al español del manual de Maxima se debió a
Juan Pablo Romero Bernal y colaboradores del proyecto GLUD-CLog
(`http://glud.udistrital.edu.co/clog') del Grupo Linux Universidad
Distrital (Colombia). Parte de la versión actual se debe a ellos.
Actualmente este documento lo mantiene Mario Rodríguez Riotorto
(`http://www.biomates.net'); para comentarios, sugerencias y
colaboraciones, contactar en la dirección de correo electrónico:

   mario ARROBA edu PUNTO xunta PUNTO es

* Menu:


Infraestructura de Maxima

* Introducción a Maxima::            Muestra de sesiones con Maxima.
* Reporte y Detección de Bugs::      Buscando y reportando bugs en Maxima
* Ayuda::                              Solicitando ayuda desde una sesión de Maxima.
* Línea de Comandos::    Sintaxis de los comandos de Maxima.
* Operadores::                         Operadores utilizados en expresiones de Maxima.
* Expresiones::                        Expresiones de Maxima.
* Simplificación::                   Simplificando expresiones.
* Gráficos::                         Gráficos en dos y tres dimensiones.
* Entrada y Salida::                   Entrada y salida de archivos
* Aritmética de punto flotante::     Rutinas numéricas de bajo nivel.
* Contextos::                          Imposición de restricciones a variables.

Soporte para campos más específicos de las matemáticas

* Polinomios::                         Operaciones con polinomios.
* Constantes::                         Constantes numéricas.
* Logaritmos::                         Transformación y cálculo de expresiones logarítmicas.
* Trigonometría::        Transformación y cálculo de expresiones trigonométricas.
* Funciones Especiales::               Funciones especiales.
* Funciones elípticas::  Funciones e integrales elípticas.
* Límites::              Cálculo de límites.
* Diferenciación::                   Cálculo diferencial.
* Integración::                      Cálculo integral.
* Ecuaciones::                         Definición y resolución de ecuaciones.
* Ecuaciones Diferenciales::           Definición y resolución de ecuaciones diferenciales.
* Métodos numéricos::              Integración numérica, transformadas de Fourier, etc.
* Estadística::          Funciones estadísticas.
* Arreglos y Tablas::                  Creación y manipulación de arreglos.
* Matrices y Álgebra Lineal::        Operaciones matriciales.
* Afines::
* itensor::                            Manipulación indexada de tensores
* ctensor::                            Manipulación por componentes de tensores
* atensor::                            Manipulación algebraica de tensores
* Series::                             Series de potencias y de Taylor.
* Teoría de Números::  Teoría de números.
* Simetrías::
* Grupos::                             Álgebra abstracta.

Funcionalidades avanzadas y programación

* Entorno de Ejecución::      Personalización de Maxima.
* Opciones Misceláneas::      Opciones que afectan globalmente el comportamiento de Maxima.
* Reglas y patrones::           Patrones de definidos por el usuario y
                                reglas de simplificación.
* Listas::                      Manipulación de listas.
* Conjuntos::                   Operaciones con conjuntos.
* Definición de Funciones::   Programando funciones.
* Programación::              Programación en Maxima.
* Depurado::                    Depuración de fallos en programas Maxima.

Índice

* Índice de Funciones y Variables::  Índice.

 --- Listado detallado de los nodos ---

Introducción

* Introducción a Maxima::

Ayuda

* Introducción a la Ayuda::
* Lisp y Maxima::
* Recolector de Basura::
* Documentación::
* Definiciones para la Ayuda::

Línea de Comandos

* Introducción a la Línea de Comandos::
* Definiciones para  la Línea de Comandos::

Operadores

* n-arios::
* no-fijos::
* operador::
* postfijos::
* prefijos::
* Definiciones para Operadores::

Expresiones

* Introducción a las Expresiones::
* Asignación::
* Expresiones complejas::
* Nombres y verbos::
* Identificadores::
* Desigualdades::
* Sintaxis::
* Definiciones para Expresiones::

Simplificación

* Definiciones para Simplificación::

Gráficos

* Definiciones para Gráficos::

Entrada y Salida

* Introducción a  Entrada y Salida::
* Archivos::
* Definiciones para Entrada y Salida::

Aritmética de punto flotante

* Definiones para aritmética de punto flotante::

Contextos

* Definiciones para Contextos::

Polinomios

* Introducción a los Polinomios::
* Definiciones para Polinomios::

Constantes

* Definiciones para Constantes::

Logaritmos

* Definiciones para Logaritmos::

Trigonometría

* Introducción a la Trigonometría::
* Definiciones para Trigonometría::

Funciones Especiales

* Introducción a las Funciones Especiales::
* specint::
* Definiciones para las Funciones Especiales::

Funciones elípticas

* Introducción a las funciones e integrales elípticas::
* Definiciones para funciones elípticas::
* Definiciones para integrales elípticas::

Límites

* Definiciones para Límites::

Diferenciación

* Definiciones para Diferenciación::

Integración

* Introducción a la Integración::
* Definiciones para Integración::

Ecuaciones

* Definiciones para Ecuaciones::

Ecuaciones Diferenciales

* Definiciones para Ecuaciones Diferenciales::

Métodos numéricos

* Introducción a los métodos numéricos::
* Series de Fourier::
* Definiciones para los métodos numéricos::
* Definiciones para las series de Fourier::

Estadística

* Definiciones para Estadística::

Arreglos y Tablas

* Definiciones para Arreglos y Tablas::

Matrices y Álgebra Lineal

* Introducción a las Matrices y al Álgebra Lineal::
* Operador punto::
* Vectores::
* Paquete eigen::
* Definiciones para las Matrices y el Álgebra Lineal::

Afines

* Definiciones para Afines::

itensor

* Introducción a itensor::
* Definiciones para itensor::

ctensor

* Introducción a ctensor::
* Definiciones para ctensor::

atensor

* Introducción a atensor::
* Definiciones para atensor::

Series

* Introducción a las Series::
* Definiciones para las Series::

Teoría de Números

* Definiciones para Teoría de Números::

Simetrías

* Definiciones para Simetrías::

Grupos

* Definiciones para Grupos::

Entorno de Ejecución

* Introducción al Entorno de Ejecución::
* Interrupciones::
* Definiciones para el Entorno de Ejecución::

Opciones Misceláneas

* Introducción a Opciones Misceláneas::
* Share::
* Definiciones para Opciones Misceláneas::

Reglas y patrones

* Introducción a reglas y patrones::
* Definiciones sobre reglas y patrones::

Listas

* Introducción a las listas::
* Definiciones para listas::

Conjuntos

* Introducción a los conjuntos::
* Definiciones para los conjuntos::

Definición de Funciones

* Introducción a la definición de funciones::
* Funciones::
* Macros::
* Definiciones para la definición de funciones::

Programación

* Introducción a la Programación::
* Definiciones para la Programación::

Depurado

* Depuración del código fuente::
* Claves de depuración::
* Definiciones para Depurado::


File: maxima.info,  Node: Introducción a Maxima,  Next: Reporte y Detección de Bugs,  Prev: Top,  Up: Top

1 Introducción a Maxima
***********************

Se puede iniciar Maxima con el comando "maxima". Maxima desplegará
alguna información importante acerca de la versión que se está usando y
un prompt. Cada comando que vaya a ser ejecutado por Maxima debe
terminar con un punto y coma. Para finalizar una sesión en Maxima se
emplea el comando "quit();". A continuación se presenta un breve
ejemplo de sesión:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima puede buscar en las páginas info. Para ello puede usar el
comando `describe' que mostrará todos los comandos y variables
asociadas con la cadena o argumento de este comando. Opcionalmente
puede mostrar la documentación respectiva. El signo de cierre de
interrogación `?' es una abreviación del comando `describe':

     (%i1) ? integ

      0: (maxima.info)Introduction to Elliptic Functions and Integrals.
      1: Definitions for Elliptic Integrals.
      2: Integration.
      3: Introduction to Integration.
      4: Definitions for Integration.
      5: askinteger :Definitions for Simplification.
      6: integerp :Definitions for Miscellaneous Options.
      7: integrate :Definitions for Integration.
      8: integrate_use_rootsof :Definitions for Integration.
      9: integration_constant_counter :Definitions for Integration.
     Enter space-separated numbers, `all' or `none': 6 5

     Info from file /usr/local/info/maxima.info:
      - Function: integerp (<expr>)
          Returns `true' if <expr> is an integer, otherwise `false'.


      - Function: askinteger (expr, integer)
      - Function: askinteger (expr)
      - Function: askinteger (expr, even)
      - Function: askinteger (expr, odd)
          `askinteger (expr, integer)' attempts to determine from the
          `assume' database whether `expr' is an integer.  `askinteger' will
          ask the user if it cannot tell otherwise, and attempt to install
          the information in the database if possible.  `askinteger (expr)'
          is equivalent to `askinteger (expr, integer)'.

          `askinteger (expr, even)' and `askinteger (expr, odd)' likewise
          attempt to determine if `expr' is an even integer or odd integer,
          respectively.

     (%o1)                         false

   Para usar un resultado de forma posterior, usted puede asignar dicho
resultado a una variable o referirse a él por medio de la etiqueta
asociada (%i* o %o*). Adicionalmente  puede usar `%' para referirse al
último resultado obtenido.

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima manipula sin ningún problema números complejos y constantes
numéricas:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima puede hacer derivadas  e integrales:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima puede resolver sistemas de ecuaciones lineales y cúbicas:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima puede resolver sistemas de ecuaciones no lineales. Tenga en
cuenta que si usted no desea que el resultado sea impreso, puede
finalizar el comando con `$' en vez de `;'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Bajo un sistema X window, (es decir que poseea interfaz gráfica),
Maxima puede generar gráficas  de una o más funciones:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12], [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Reporte y Detección de Bugs,  Next: Ayuda,  Prev: Introducción a Maxima,  Up: Top

2 Reporte y Detección de Bugs
*****************************

* Menu:

* Introducción a la detección de Bugs y su reporte::
* Definiciones para la detección de Bugs y su reporte::


File: maxima.info,  Node: Introducción a la detección de Bugs y su reporte,  Next: Definiciones para la detección de Bugs y su reporte,  Up: Reporte y Detección de Bugs

2.1 Introducción a la detección de Bugs y su reporte
====================================================

Como todos los grandes programas, Maxima contiene tanto bugs conocidos
como desconocidos. Este capítulo describe las facilidades internas para
ejecutar la suite de evaluación de Maxima (Maxima test suite) además de
reportar nuevos bugs.


File: maxima.info,  Node: Definiciones para la detección de Bugs y su reporte,  Prev: Introducción a la detección de Bugs y su reporte,  Up: Reporte y Detección de Bugs

2.2 Definiciones para la detección de Bugs y su reporte::
=========================================================

 -- Función: run_testsuite ()
 -- Función: run_testsuite (<boolean>)
 -- Función: run_testsuite (<boolean>, <boolean>)
 -- Función: run_testsuite (<boolean>, <boolean>, <list>)
     Ejecuta la suite de evaluación de Maxima. Los tests que producen
     las respuestas deseadas son considerados como "pruebas superadas",
     como los tests que no producen las respuestas deseadas, son
     marcados como bugs conocidos.

     `run_testsuite ()' muestra sólo los test que no pasaron la prueba.

     `run_testsuite (true)' muestra los tests que son marcados como bugs
     conocidos, además de fallos.

     `run_testsuite (true, true)' muestra todos los tests.

     Si se incluye el tercer argumento opcional, se ejecutará una parte
     de los tests.  Los tests a ejecutar se especifican formando una
     lista con los nombres de los mismos. La lista completa de tests
     está en `testsuite_files'.

     `run_testsuite' cambia el entorno de Maxima.  Típicamente un
     script de test ejecuta `kill' para establecer un entorno conocido
     (llámese uno sin funciones ni variables definidas por el usuario)
     y entonces define una serie de funciones y variables apropiadas
     para el test.

     `run_testsuite' retorna `done'.

 -- Variable opcional: testsuite_files
     `testsuite_files' es el conjunto de tests a ejecutar por
     `run_testsuite'. Se trata de una lista con los nombres de los
     ficheros que contienen los tests a ejecutar. Si se sabe que alguno
     de los tests de un fichero falla, entonces en lugar de listar el
     nombre del fichero, se utiliza una lista que contiene el nombre
     del fichero y los números de los tests que fallan.

     Por ejemplo, esta es una parte de los tests por defecto:

           ["rtest13s", ["rtest14", 57, 63]]

     Con esto se especifica que el conjunto de tests está formado por
     los ficheros "rtest13s"  y "rtest14", pero que "rtest14" contiene
     dos tests que se sabe que causan fallos, el 57 y el 63.

 -- Función: bug_report ()
     Imprime las versiones de Maxima y de Lisp y proporciona un enlace
     a la página web de reporte de bugs del proyecto Maxima.  La
     información respecto a las versiones es la misma que reporta la
     función `build_info'.

     Cuando un bug es reportado, es de gran ayuda que se copie la
     información relacionada con la versión de Maxima y de Lisp usada,
     dentro del reporte de bug.

     `bug_report' retorna una cadena vacía `""'.

 -- Función: build_info ()
     Imprime un resumen de los parámetros que se usaron para construir
     la versión de Maxima que se está usando.

     `build_info' retorna una cadena vacía  `""'.


File: maxima.info,  Node: Ayuda,  Next: Línea de Comandos,  Prev: Reporte y Detección de Bugs,  Up: Top

3 Ayuda
*******

* Menu:

* Introducción a la Ayuda::
* Lisp y Maxima::
* Recolector de Basura::
* Documentación::
* Definiciones para la Ayuda::


File: maxima.info,  Node: Introducción a la Ayuda,  Next: Lisp y Maxima,  Prev: Ayuda,  Up: Ayuda

3.1 Introducción a la Ayuda
===========================

El comando de ayuda más útil es `describe', el cual es invocado por el
signo de cierre de interrogación `?' a través del prompt interactivo.
`? foo' (con espacio entre `?' y `foo') es equivalente a `describe
("foo")', donde `foo' es el nombre o parte del nombre de alguna función
o tema; entonces `describe' encontrará todos los documentos que
contengan la cadena `foo' en sus títulos y los desplegará como opciones.
Si hay más de una opción, Maxima preguntará al usuario para que
seleccione las opciones que desee consultar.

     (%i1) ? integ
      0: (maxima.info)Introduction to Elliptic Functions and Integrals.
      1: Definitions for Elliptic Integrals.
      2: Integration.
      3: Introduction to Integration.
      4: Definitions for Integration.
      5: askinteger :Definitions for Simplification.
      6: integerp :Definitions for Miscellaneous Options.
      7: integrate :Definitions for Integration.
      8: integrate_use_rootsof :Definitions for Integration.
      9: integration_constant_counter :Definitions for Integration.
     Enter space-separated numbers, `all' or `none': 7 8

     Info from file /use/local/maxima/doc/info/maxima.info:
      - Function: integrate (expr, var)
      - Function: integrate (expr, var, a, b)
          Attempts to symbolically compute the integral of `expr' with
          respect to `var'.  `integrate (expr, var)' is an indefinite
          integral, while `integrate (expr, var, a, b)' is a definite
          integral, [...]

   En este ejemplo las opciones 7 y 8 fueron seleccionadas.  Todas o
ninguna de las opciones pueden ser seleccionadas escribiendo `all' o
`none', las cuales pueden ser abrevidas por `a' o `n', respectivamente.


File: maxima.info,  Node: Lisp y Maxima,  Next: Recolector de Basura,  Prev: Introducción a la Ayuda,  Up: Ayuda

3.2 Lisp y Maxima
=================

Maxima fue escrito en Lisp, y es muy fácil tener acceso a funciones y
variables Lisp desde Maxima y viceversa.  Los símbolos Lisp y los
símblos Maxima están claramente diferenciados por medio de una
convención de nombres.  Un símblo Lisp el cual comienza con un signo
pesos `$' corresponde a un símbolo Maxima sin el signo pesos.  Un
símbolo Maxima el cual comienza con un signo de cierre de interrogación
`?' corresponde a un símbolo Lisp sin dicho signo.  Por ejemplo, el
símbolo Maxima `foo' corresponde a el símbolo Lisp `$foo', mientras que
el símbolo Maxima `?foo' corresponde a el símbolo Lisp `foo', tenga en
cuenta que `?foo' esta escrito sin espacio entre `?' y `foo'; de otra
manera se estaría invocando a `describe ("foo")'.

   El guión `-', asterisco `*', u otros carácteres especiales en
símbolos Lisp deben ser escritos mediante un backslash `\' si aparecen
en código Maxima.  Por ejemplo, el identificador Lisp `*foo-bar*' se
debe escribir `?\*foo\-bar\*' en Maxima.

   Se puede ejecutar código Lisp desde una sesión de Maxima.  Una línea
Lisp (que contenga una o más formas) puede ser ejecutada por medio de
un comando especial `:lisp'. Por ejemplo,

     (%i1) :lisp (foo $x $y)

se llama a la función Lisp `foo' con variables Maxima `x' y `y' como
argumentos.  La instrucción `:lisp' puede aparecer en el prompt
interactivo o en un archivo que sea procesado por `batch' o `demo',
pero no en un archivo que sea procesado por `load', `batchload',
`translate_file' o `compile_file'.

   La función `to_lisp()' abre una sesión interactiva con el interprete
Lisp.  Escribiendo `(to-maxima)' se cierra la sesión con Lisp y se
retorna a Maxima.

   Las funciones y variables Lisp las cuales esten para ser visibles en
Maxima como funciones y variables con nombres oridinarios (sin una
puntuación especial), deben tener nombres tipo Lisp que comiencen con
el signo pesos `$'.

   Maxima es case-sensitive, distingue entre letras minúsculas y
mayúsculas en identificadores, mientras que Lisp no.  Existen algunas
reglas que gobiernan la traducción de nombres entre Lisp y Maxima.

  1. Un identificador Lisp que no se encuentra encerrado en barras
     verticales corresponde a un identificador Maxima in minúscula.
     Que el idenficador Lisp este en mayúscula, minúscula o una
     combinación de las dos, no afecta en nada.  E.g., los
     identificadores Lisp `$foo', `$FOO', y `$Foo', todos corresponden
     al identificador Maxima `foo'.

  2. Unn identificador Lisp el cual se encuentre todo en mayúscula o
     todo en minúscula y encerrado entre barras verticales corresponde
     a un identicador Maxima con el caso contrario.  Esto es, de
     mayúsculas cambia a minúsculas y de minúsculas cambia a mayúsculas.
     E.g., el identificador Lisp `|$FOO|' y `|$foo|' corresponden los
     identificadores Maxima `foo' y `FOO', respectivamente.

  3. Un identificador Lisp el cual esta escrito mezclando letras
     mayúsculas y minúsculas y se encuentra entre barras verticales
     corresponde a un identificador Maxima con la misma escritura.
     E.g., el identificador Lisp `|$Foo|' corresponde a el
     identificador Maxima `Foo'.

   La macro Lisp `#$' permite el uso de expresiones Maxima dentro de
código Lisp. `#$<expr>$' extiende a una expresión Lisp equivalente a la
expresión Maxima <expr>.

     (msetq $foo #$[x, y]$)

Esto tiene el mismo efecto que:

     (%i1) foo: [x, y];

La función Lisp `displa' imprime una expresión en formato Maxima.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Las funciones definidas en Maxima no son funciones Lisp ordinarias.
La función Lisp `mfuncall' llama a una función Maxima.  Por ejemplo:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Algunas funciones Lisp son compartidas en el paquete Maxima, las
cuales se listan a continuación:

   `complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', y `gcd'.


File: maxima.info,  Node: Recolector de Basura,  Next: Documentación,  Prev: Lisp y Maxima,  Up: Ayuda

3.3 Recolector de Basura
========================

La computación simbólica tiende a crear una buena cantidad de basura, y
un manejo efectivo de esto puede ser crucial para el término exitoso de
algunos programas.

   Bajo GCL (GNU Common Lisp), en los sistemas UNIX donde la llamada al
sistema mprotect esta disponible (incluyendo SUN OS 4.0 y algunas
variantes de BSD) un recolector de basura estratificado está disponibe.
Estos límites de colección para memoria virtual, han sido escritos
recientemente. Mire la documentación de GCL bajo ALLOCATE y GBC.  En el
nivel lisp haga (setq si::*notify-gbc* t) eso le ayudará a determinar
cuales áreas necesitan más espacio.


File: maxima.info,  Node: Documentación,  Next: Definiciones para la Ayuda,  Prev: Recolector de Basura,  Up: Ayuda

3.4 Documentación
=================

El manual en línea del usuario de Maxima puede ser visto en diferentes
formas.  Desde el prompt interactivo de Maxima, el manual de usuario es
visto como texto plano por medio del comando  `?' (i.e., la función
`describe').  El manual de usuario también puede ser visto como
hipertexto tipo `info' por medio del programa `info' y como una página
web a través de cualquier navegador.

   El comando `example' muestra ejemplos para muchas funciones Maxima.
Por ejemplo:

     (%i1) example (integrate);

   produce:

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   y salidas adicionales.


File: maxima.info,  Node: Definiciones para la Ayuda,  Prev: Documentación,  Up: Ayuda

3.5 Definiciones para la Ayuda
==============================

 -- Función: demo (<archivo>)
     Evalua las expresiones Maxima contenidas en <archivo> y muestra
     los resultados.  `demo' hace pausas después de evaluar  cada
     expresión y continua después de que el usuario ingrese un retorno
     de carro.  (Si se ejecuta en Xmaxima, `demo' puede que necesite un
     punto y coma `;' a continuación del retorno de carro.)

     `demo' busca la lista de directorios `file_search_demo' para
     encontrar `archivo'.  Si el archivo tiene el sufijo `dem', el
     sufijo puede ser omitido.  Ver también `file_search'.

     `demo' evalua su argumento.  `demo' retorna el nombre del archivo
     demostración.

     Ejemplo:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)

 -- Función: describe (<cadena>)
     Encuentra todos los documentos los cuales contengan <cadena> es
     sus títulos y los despliega como opciones.  Si hay más de una
     opción, Maxima preguntará al usuario para que seleccione las
     opciones que desee consultar.  En el prompt interactivo, `? foo'
     (con espacio entre `?' y `foo') es equivalente a  `describe
     ("foo")'.

     `describe ("")' produce una lista de todos los temas documentados
     en el manual en línea.

     `describe' no evalua su argumento.  `describe' siempre retorna
     `false'.

     Ejemplo:

          (%i1) ? integ
           0: (maxima.info)Introduction to Elliptic Functions and Integrals.
           1: Definitions for Elliptic Integrals.
           2: Integration.
           3: Introduction to Integration.
           4: Definitions for Integration.
           5: askinteger :Definitions for Simplification.
           6: integerp :Definitions for Miscellaneous Options.
           7: integrate :Definitions for Integration.
           8: integrate_use_rootsof :Definitions for Integration.
           9: integration_constant_counter :Definitions for Integration.
          Enter space-separated numbers, `all' or `none': 7 8

          Info from file /use/local/maxima/doc/info/maxima.info:
           - Function: integrate (expr, var)
           - Function: integrate (expr, var, a, b)
               Attempts to symbolically compute the integral of `expr' with
               respect to `var'.  `integrate (expr, var)' is an indefinite
               integral, while `integrate (expr, var, a, b)' is a definite
               integral, [...]

     En este ejemplo las opciones 7 y 8 fueron seleccionadas.  Todas o
     ninguna de las opciones pueden ser seleccionadas escribiendo `all'
     o `none', las cuales pueden ser abrevidas por `a' o `n',
     respectivamente.


 -- Función: example (<tema>)
 -- Función: example ()
     `example (<tema>)' mostrará algunos ejemplos de <tema>, el cual es
     un símbolo (no una cadena).  La mayoría de los temas son nombres
     de funciones.  `example ()' retorna la lista de todos los temas
     conocidos.

     El nombre del archivo que contiene los ejemplos esta dado por la
     variable global `manual_demo', cuyo valor por defecto es
     `"manual.demo"'.

     `example' no evalua su argumento.  `example' retorna `done' a
     menos que haya un error o que no haya argumento, en cuyo caso
     `example' retornará la lista de todos los temas conocidos.

     Ejemplos:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done



File: maxima.info,  Node: Línea de Comandos,  Next: Operadores,  Prev: Ayuda,  Up: Top

4 Línea de Comandos
*******************

* Menu:

* Introducción a la Línea de Comandos::
* Definiciones para  la Línea de Comandos::


File: maxima.info,  Node: Introducción a la Línea de Comandos,  Next: Definiciones para la Línea de Comandos,  Prev: Línea de Comandos,  Up: Línea de Comandos

4.1 Introducción a la Línea de Comandos
=======================================

 -- Operador: "'"
     El operador comilla sencilla `'' evita la evaluación.

     Aplicado a un símbolo, la comilla sencilla evita la evaluación del
     símbolo.

     Aplicado a la llamada de una función, la comilla sencilla evita la
     evaluación de la función llamada, aunque los argumentos de la
     función son evaluados (siempre y cuando la evaluación no se evite
     de otra manera).  El resultado es una forma de nombre de la
     función llamada.

     Aplicado a una expresión con paréntesis, la comilla simple evita
     la evaluación de todos los símbolos y llamadas a funciones que
     hayan en la expresión.  E.g., `'(f(x))' significa que no se evalua
     la expresión `f(x)'.  `'f(x)' (con la comilla simple aplicada a
     `f' en cambio de a `f(x)') significa el retorno de la forma de
     nombre de `f' aplicada a `[x]'.

     La comilla simple no evita la simplificación.

     Cuando el interruptor global `noundisp' es `true', los nombres se
     muestran con una comilla simple.  Este interruptor siempre tiene
     como valor `true' cuando se muestran definiciones de funciones.

     Ver también los operadores comilla-comilla `''' y `nouns'.

     Ejemplos:

     Aplicado a un símbolo, la comilla sencilla evita la evaluación del
     símbolo.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Aplicado a la llamada de una función, la comilla sencilla evita la
     evaluación de la función llamada, aunque los argumentos de la
     función son evaluados (siempre y cuando la evaluación no se evite
     de otra manera).  El resultado es una forma de nombre de la
     función llamada.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Aplicado a una expresión con paréntesis, la comilla simple evita
     la evaluación de todos los símbolos y llamadas a funciones que
     hayan en la expresión.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     La comilla sencilla no evita la simplificación.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1


 -- Operador: "''"
     El operador `''' (doble comilla simple) causa que una evaluación
     extra tenga lugar.  E.g., `''%i4' reevaluará la línea de entrada
     `%i4'.  `''(f(x))' significa evaluar la expresión `f(x)' en tiempo
     extra.  `''f(x)' (con la doble comilla simple aplicada a `f' en
     vez de a `f(x)') significa el retorno de la forma verbal de `f'
     aplicada a `[x]'.


File: maxima.info,  Node: Definiciones para la Línea de Comandos,  Prev: Introducción a la Línea de Comandos,  Up: Línea de Comandos

4.2 Definiciones para la Línea de Comandos
==========================================

 -- Función: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provee un nombre alternativo para una (bien sea definida por el
     usuario o por el sistema) función, variable, arreglo, etc.
     Cualquier número par de argumentos puede ser usado.


 -- Variable opcional: debugmode
     Valor por defecto: `false'

     Cuando en Maxima ocurre un error, Maxima inicializará el depurador
     si `debugmode' tiene el valor `true'.  El usuario puede ingresar
     comandos para examinar la pila de llamadas, los puntos de
     interrupción; en pocas palabras ir a través del código de Maxima.
     Vea `debugging' para una lista de los comandos del depurador.

     Habilitando `debugmode' no se capturarán los errores tipo Lisp.


 -- Función: ev (<expr>, <arg_1>, ..., <arg_n>)
     Evalua la expresión <expr> en el entorno especificado por los
     argumentos <arg_1>, ..., <arg_n>.  Los argumentos son
     interruptores (Variables Booleanas), variables de asignación,
     ecuaciones y funciones.  `ev' retorna el resultado (otra
     expresión) de la evaluación.

     La evaluación se realiza por etapas, como sigue:

       1. Primero se configura el entorno de acuerdo a los argumentos
          los cuales pueden ser algunos o todos de la siguiente lista:

             * `simp' causa que <expr> sea simplificada sin importar el
               valor de la variable interruptor `simp' la cual inhibe
               la simplificación cuando su valor es `false'.

             * `noeval' suprime la fase de evaluación de `ev' (Vea el
               paso (4) más adelante).  Esto es muy útil en conjunción
               con otras variables interruptor y causan en <expr> que
               sea resimplificada sin ser reevaluada.

             * `nouns' causa que la evaluación de las formas de nombre
               (típicamente funciones sin evaluar tales como
               `'integrate' or `'diff') en `expr'.

             * `expand' causa expansión.

             * `expand (<m>, <n>)' causa expansión, asignando los
               valores de `maxposex' y `maxnegex' a <m> y <n>,
               respectivamente.

             * `detout' causa que cualesquiera matrices inversas
               computadas en <expr> conserven su determinante fuera de
               la inversa en vez de que divida a cada elemento.

             * `diif' causa que todas las diferenciaciones indicadas en
               <expr> sean llevadas a cabo.

             * `derivlist (<x>, <y>, <z>, ...)' causa que sólo las
               diferenciaciones con respecto a las variables indicadas
               se lleven a cabo.

             * `float' causa que los números racionales no-enteros sean
               convertidos a números de tipo flotante.

             * `numer' causa que algunas funciones matemáticas
               (incluyendo potenciación) con argumentos numéricos sean
               evaluados como punto flotante. Esto causa que las
               variables en <expr> las cuales hayan sido declaradas
               como variables numéricas sean reemplazadas por sus
               respectivos valores. Esto también configura la variable
               interruptor `float' a `true'.

             * `pred' causa que los predicados (expresiones las cuales
               se evaluan a `true' o `false') sean evaluados.

             * `eval' causa que una post-evaluación extra de <expr>
               ocurra. (Vea el paso (5) más adelante).

             * `A', donde `A' es un átomo declarado como una variable
               de tipo interruptor, (Vea `evflag') causa que `A' tenga
               como valor `true' durante la evaluación de <expr>.

             * `V: expresion' (o alternativamente `V=expresion') causa
               que `V' tenga el valor de `expresion' durante la
               evaluación de <expr>. Notese que si `V' es una opción
               Maxima, entonces `expresion' se usa como su valor
               durante la evaluación de <expr>. Si más de un argumento
               de `ev' es de este tipo entonces el vínculo se hace en
               paralelo. Si `V' es una expresión no atómica entonces se
               hace una sustitución más que un vínculo.

             * `F' donde `F', un nombre de función, ha sido declarado
               para ser una función de evaluación (Vea `evfun') causa
               que `F' sea aplicada a <expr>.

             * Cualquier otro nombre de función (e.g., `sum') causa la
               evaluación de las ocurrencias de esos nombres en `expr'
               como si ellos fueran verbos.

             * En adición de que una función ocurra en <expr> (digamos
               `F(x)') puede ser definida localmente para el propósito
               de esta evaluación de <expr> pasando `F(x) := expresion'
               como un argumento a `ev'.

             * Si un átomo no mencionado anteriormente o una variable o
               expresión con subíndices fueran pasadas como un
               argumento, esta es evaluada y si el resultado es una
               ecuación o una asignación entonces el vínculo o
               sustitución se llevará a cabo. Si el resultado es una
               lista entonces los miembros de la lista tratados como si
               ellos fueran argumentos adicionales pasados a `ev'. Esto
               permite que una lista de argumentos sea pasada (e.g.,
               `[X=1, Y=A**2]') o una lista de nombres de ecuaciones
               (e.g., `[%t1, %t2]' donde `%t1' y `%t2' son ecuaciones)
               tal como lo que es retornado por `solve'.

          Los argumentos de `ev' pueden ser pasados en cualquier orden
          con excepción de la sustitución de ecuaciones las cuales son
          manipuladas en secuencia, de izquierda a derecha y las
          funciones de evaluación las cuales son compuestas, e.g., `ev
          (<expr>, ratsimp, realpart)' es manipulada como `realpart
          (ratsimp (<expr>))'.

          Los interruptores `simp', `numer', `float' y `pred' pueden
          también ser configurados localmente en una sentencia block, o
          globalmente en Maxima para que su efecto permanezca hasta que
          sean reconfiguradas.

          Si <expr> es una Expresión Racional Canónica (CRE, por sus
          siglas en inglés), entonces la expresión retornada por `ev'
          es también de tipo CRE, siempre que los interruptores `numer'
          y `float' no sean `true'.

       2. Durante el paso (1), se fabrica una lista de las variables
          que no contienen subíndices que aparecen en el lado izquierdo
          de las ecuaciones en los argumentos o en el valor de algunos
          argumentos si el valor es una ecuación. Las variables
          (variables que contienen subíndices las cuales no tienen
          asociado un arreglo de funciones como también las variables
          que no contienen subíndices) en la expresión <expr> son
          reemplazadas por sus valores globales, excepto por aquellos
          que aparezcan en esa lista.  Usualmente, <expr> es sólo una
          etiqueta o un `%' (como en `%i2' en el ejemplo de más abajo)
          así que este paso simplemente recupera la expresión a la que
          hace referencia la etiqueta y así `ev' puede trabajarla.

       3. Si algunas sustituciones son indicadas por los argumentos,
          ellas serán llevadas a cabo ahora.

       4. La expresión resultante es también reevaluada (a menos que
          uno de los argumentos fuese `noeval') y simplificada de
          acuerdo a los argumentos. Notese que cualquier llamada a una
          función en <expr> será llevada a cabo después de que las
          variables sean evaluadas en ella y que `ev(F(x))' pueda
          comportarse como `F(ev(x))'.

       5. Si uno de los argumentos fuese `eval', los pasos (3) y (4) se
          repiten.

     Ejemplos

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     Una sintaxis alternativa de alto nivel ha sido proveida para `ev',
     por medio de la cual uno puede escribir solamente sus argumentos,
     sin el comando `ev()'. Esto es, una forma sencilla de escritura:

          <expr>, <arg_1>, ..., <arg_n>

     Esto no es permitido como parte de otra expresión , e.g., en
     funciones, sentencias block, etc.

     Nótese el proceso de vínculo en paralelo en el siguiente ejemplo:

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solución

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Propiedad: evflag
     Algunos interruptores booleanos tienen la propiedad `evflag'.
     `ev' trata de forma especial tales interruptores.  Un interruptor
     con la propiedad `evflag' será puesto a `true' durante la
     ejecución de `ev' si este es mencionado en la llamada a `ev'.  Por
     ejemplo, `demoivre' y `ratfac' son puestos a `true' durante la
     llamada a `ev (%, demoivre, ratfac)'.

     Los interruptores que tienen la propiedad `evflag' son:

     `algebraic', `cauchysum', `demoivre', `dotscrules', `%emode',
     `%enumer', `exponentialize', `exptisolate', `factorflag', `float',
     `halfangles', `infeval', `isolate_wrt_times', `keepfloat',
     `letrat', `listarith', `logabs', `logarc', `logexpand',
     `lognegint', `lognumer', `m1pbranch', `numer_pbranch',
     `programmode', `radexpand', `ratalgdenom', `ratfac', `ratmx',
     `ratsimpexpons', `simp', `simpsum', `sumexpand', y `trigexpand'.

     La instrucción `:lisp (putprop '|$foo| t 'evflag)' da la propiedad
     `evflag' a la variable `foo', así que `foo' es puesta a `true'
     durante la llamada a `ev (%, foo)'.  De forma equivalente, `ev ($,
     foo:true)' tiene el mismo efecto.

 -- Propiedad: evfun
     Algunas funciones tienen la propiedad `evfun'.  `ev' trata tales
     funciones de forma especial.  Una función con la propiedad `evfun'
     será aplicada durante la ejecución de `ev' si ésta es mencionada
     en la llamada a `ev'.  Por ejemplo, `ratsimp' y `radcan' serán
     aplicadas durante la llamada a `ev (%, ratsimp, radcan)'.

     Las funciones que tienen la propiedad `evfun' son:

     `bfloat', `factor', `fullratsimp', `logcontract', `polarform',
     `radcan', `ratexpand', `ratsimp', `rectform', `rootscontract',
     `trigexpand', y `trigreduce'.

     La instrucción `:lisp (putprop '|$foo| t 'evfun)' da la propiedad
     `evfun' a la función `foo', así que `foo' es aplicada durante la
     llamada a `ev (%, foo)'.  De forma equivalente, `foo (ev(%))'
     tiene el mismo efecto.

 -- Variable opcional: infeval
     Habilita el modo de "evaluación infinita". `ev' repetidamente
     evalua una expresión hasta que se interrumpa la acción. Para
     prevenir que una variable, digamos `X', sea evaluada sin parar en
     este modo, simplemente incluya `X='X' como argumento de `ev'.
     Esta claro que expresiones como: `ev (X, X=X+1, infeval)'
     generarán un bucle infinito.

 -- Función: kill (<symbol_1>, ..., <symbol_n>)
 -- Función: kill (labels)
 -- Función: kill (inlabels, outlabels, linelabels)
 -- Función: kill (<n>)
 -- Función: kill ([<m>, <n>])
 -- Función: kill (values, functions, arrays, ...)
 -- Función: kill (all)
 -- Función: kill (allbut (<symbol_1>, ..., <symbol_n>))
     Remueve todos los vínculos (valor, función, arreglo o regla) de los
     argumentos <symbol_1>, ..., <symbol_n>.  Un argumento puede ser un
     simple arreglo de elementos o funciones con subíndices.

     Varios argumentos especiales son reconocidos.  Diferentes clases
     de argumentos pueden ser combinados, e.g., `kill (inlabels,
     functions, allbut (foo, bar))'.

     `kill (labels)' elimina todas las etiquetas de entrada, salida y
     expresiones intermedias creadas hasta el momento.

     `kill (inlabels)' elimina sólo las etiquetas de entrada las cuales
     empiezan con el valor de `inchar' en ese momento.

     Igualmente, `kill (outlabels)' elimina sólo las etiquetas de salida
     las cuales empiezan con el valor de `outchar' de ese momento, y
     `kill (linelabels)' elimina sólo las etiquetas de expresiones
     intermedias las cuales empiezan con el valor de `linchar' de ese
     momento.

     `kill (<n>)', donde <n> es un entero, elimina las <n> etiquetas de
     entrada y salida más recientes.

     `kill ([<m>, <n>]' elimina las etiquetas de entrada y salida <m>
     hasta <n>.

     `kill (<infolist>)', donde <infolist> es cualquier item de
     `infolists' (tales como `values', `functions' o `arrays'), elimina
     todos los items en <infolist>.  Véase también `infolists'.

     `kill (all)' elimina todos los items de todas las listas de
     información (infolists).  `kill (all)' no reconfigura las
     variables globales a sus valores por defecto; vea `reset' para más
     información sobre este punto.

     `kill (allbut (<symbol_1>, ..., <symbol_n>))' elimina todos los
     items de todas las listas de información (infolists) excepto para
     <symbol_1>, ..., <symbol_n>.

     `kill (allbut (<infolist>))' elimina todos los items excepto para
     los que aparezcan en <infolist>, donde <infolist> es `values',
     `functions', `arrays', etc.

     `kill' no evalua sus argumentos.  El operador de doble comilla
     simple, `''', rechaza

     La función `kill' no evalúa sus argumentos. El operador de dobles
     comillas simples, `''', hace que los argumentos se evalúen.

     La llamada `kill (<symbol>)' elimina todas las propiedades de
     <symbol>.  En contraste, `remvalue', `remfunction', `remarray' y
     `remrule' elimina a propiedad en específico.

     `kill' siempre retorna `done', incluso si un argumento no fue
     eliminado.


 -- Función: labels (<symbol>)
 -- Variable del sistema: labels
     Retorna la lista de etiquetas de entrada, salida o de expresiones
     intermedias las cuales empiezan con <symbol>.  Típicamente
     <symbol> es el valor de las variables `inchar', `outchar' o
     `linechar'.  El caractér de etiqueta puede ser pasado con o sin
     signo de porcentaje, así, por ejemplo, `i' y `%i' producen el
     mismo resultado.

     Si ninguna etiqueta empieza con <symbol>, `labels' retorna a una
     lista vacía.

     La función `labels' no evalua su arguemento.  Por ejemplo, `labels
     (''inchar)' retorna las etiquetas de entrada las cuales empiezan
     con el caractér de etiqueta de entrada actual.

     La variable `labels' es una lista de las etiquetas de entrada,
     salida y expresiones intermedias, incluyendo todas las etiquetas
     anteriores en el caso de que `inchar', `outchar' o `linechar'
     hayan sido redefinidas.

     Por defecto, Maxima muestra el resultado de cada expresión
     introducida por el usuario, asignando al resultado una etiqueta de
     salida.  La salida (es decir el resultado) puede ser suprimida
     terminando la expresión de entrada con un `$' (signo de dólar) en
     vez de un `;' (punto y coma).  En este caso, se crea la etiqueta
     de salida y se le asigna el resultado, aunque éste no se muestre;
     aún así, la etiqueta puede ser referenciada de la misma forma que
     se hace con aquéllas cuyos resultados sí son muestrados.

     Véanse también: `%', `%%' y `%th'.

     Las etiquetas de expresiones intermedias pueden ser generadas por
     algunas funciones. El interruptor `programmode' controla si
     `solve' y algunas otras funciones generan etiquetas de expresiones
     intermedias en vez de retornar una lista de expresiones.  Algunas
     otras funciones, tales como `ldisplay', siempre generan etiquetas
     de expresiones intermedias.

     Véase también: `inchar', `outchar', `linechar' y `infolists'.


 -- Variable del sistema: linenum
     El número de la línea del par de expresiones de entrada y salida
     actuales.

 -- Variable del sistema: myoptions
     Valor por defecto: `[]'

     `myoptions' es la lista de todas las opciones que nunca fueron
     reconfiguradas por el usuario, aunque éstas hayan sido
     reconfiguradas a su valor por defecto.


 -- Variable opcional: nolabels
     Valor por defecto: `false'

     Cuando `nolabels' vale `true', las etiquetas de entrada y salida
     (`%i' y `%o', respectivamente) son mostradas, pero a éstas no se
     les asignan los resultados; además, las etiquetas no se incorporan
     a la lista `labels'.  Puesto que a las etiquetas no se les asignan
     resultados, el colector de basura puede recuperar la memoria
     ocupada por los éstos.

     En el caso contrario, a las etiquetas de entrada y salida se les
     asignan los resultados correspondientes y son añadidas a la lista
     `labels'.

     Las etiquetas de expresiones intermedias (`%t') no se ven
     afectadas por la variable `nolabels'; independientemente de que
     `nolabels' valga `true' o `false', a las etiquetas de expresiones
     intermedias se les asignan siempre valores, además de ser añadidas
     a la lista `labels'.

     Véanse también `batch', `batchload' y `labels'.


 -- Variable opcional: optionset
     Valor por defecto: `false'

     Cuando `optionset' tiene como valor `true', Maxima imprime un
     mensaje cada vez que una opción de Maxima es reconfigurada. Esto es
     muy útil si el usuario duda con frecuencia de la correctitud de
     alguna opción y quiere estar seguro de la variable a la que él
     asignó un valor fue verdaramente una variable opción (o
     interruptor).


 -- Función: playback ()
 -- Función: playback (<n>)
 -- Función: playback ([<m>, <n>])
 -- Función: playback ([<m>])
 -- Función: playback (input)
 -- Función: playback (slow)
 -- Función: playback (time)
 -- Función: playback (grind)
     Muestra las entradas, salidas y expresiones intermedias sin
     recalcularlas.  `playback' sólo muestra las expresiones asociadas
     con etiquetas; cualquier otra salida (tal como texto impreso por
     `print' o `describe', o mensajes de error) no es mostrada.  Véase
     también: `labels'.

     `playback' no evalua sus argumentos.  `playback' siempre retorna
     `done'.

     `playback ()' (sin argumentos) muestra todas las entradas, salidas
     y expresiones intermedias generadas hasta el momento.  Una
     expresión de salida es mostrada incluso si ésta fue suprimida por
     el caracter de terminación `$', cuando fue originalmente calculada.

     `playback (<n>)'  muestra las <n> expresiones más recientes. Cada
     entrada, salida y expresión intermedia cuenta como una.

     `playback ([<m>, <n>])' muestra entradas, salidas y expresiones
     intermedias con los números desde <m> hasta <n>, ambos inclusive.

     `playback ([<m>])' es equivalente a `playback ([<m>, <m>])'; esto
     usualmente imprime un par de expresiones de entrada y salida.

     `playback (input)' muestra todas las expresiones de entrada
     generadas hasta el momento.

     `playback (slow)' hace pausas entre expresiones y espera a que el
     usuario pulse la tecla `enter' para continuar.  Esto es un
     comportamiento similar a `demo'.

     `playback (slow)' es muy útil en conjunción con `save' o
     `stringout' cuando se crea un archivo secundario de almacenamiento
     con el objetivo de elegir cuidadosamente las expresiones realmente
     útiles.

     `playback (time)' muestra el tiempo de computo por cada expresión.

     `playback (grind)' muestra las expresiones de entrada en el mismo
     formato como la función `grind'.  Las expresiones de salida no se
     ven afectadas por la opción `grind'.  Vea `grind'.

     Los argumentos pueden ser combinandos, e.g., `playback ([5, 10],
     grind, time, slow)'.


 -- Función: printprops (<a>, <i>)
 -- Función: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Función: printprops (all, <i>)
     Muestra la propiedad con el indicador <i> asociado con el átomo
     <a>. <a> pueder ser también una lista de átomos o el átomo `all'
     en cuyo caso todos los átomos a los cuales se les haya dado esa
     propiedad serán usados.  Por ejemplo, `printprops ([f, g],
     atvalue)'. `printprops' es para propiedades que no pueden ser
     mostradas de otra manera, i.e. para `atvalue', `atomgrad',
     `gradef', y `matchdeclare'.


 -- Variable opcional: prompt
     Valor por defecto: `_'

     `prompt' es el símbolo del prompt de la función `demo', del modo
     `playback (slow)' y del bucle de interrupción de Maxima (el que se
     invoca con `break').


 -- Función: quit ()
     Termina una sesión de Maxima.  Nótese que la función debe ser
     invocada como `quit();' o `quit()$', no como `quit'.

     Para parar un cálculo muy demorado pulse `Control-C'.  La acción
     por defecto es retornar a prompt de Maxima.  Si `*debugger-hook*'
     tiene como valor `nil', pulsar `Control-C' abrirá el depurador de
     Lisp.  Vea también: `debugging'.


 -- Función: remfunction (<f_1>, ..., <f_n>)
 -- Función: remfunction (all)
     Desliga las definiciones de función de sus símbolos <f_1>, ...,
     <f_n>.  Los argumentos pueden ser nombres de funciones ordinarias
     (creadas con `:=' o `define') o de funciones macro (creadas con
     `::=').

     La instrucción `remfunction (all)' desliga todas las definiciones
     de funciones.

     La función `remfunction' no evalúa sus argumentos.

     La función `remfunction' devuelve una lista con los símbolos para
     los que la definición de función fue desligada. Devuelve `false'
     en el lugar de cualquier símbolo para el que no hay función
     definida.


 -- Función: reset ()
     Reconfigura muchas variables y opciones globales y algunas otras
     variables a sus valores por defecto.

     `reset' procesa las variables que se encuentran en la lista Lisp
     `*variable-initial-values*'.  La macro Lisp `defmvar' pone las
     variables en ésta lista (entre otras acciones).  Muchas, pero no
     todas, las variables y opciones globales son definidas por
     `defmvar', y algunas variables definidas por `defmvar' no son ni
     variables ni opciones globales.


 -- Variable opcional: showtime
     Valor por defecto: `false'

     Cuando `showtime' tiene como valor `true', el tiempo de cálculo y
     el tiempo de retardo se imprimen junto con la salida de cada
     expresión.

     El tiempo de cálculo se almacena siempre, de manera que `time' y
     `playback' puedan mostrar el tiempo de cálculo incluso cuando
     `showtime' vale `false'.

     Véase también `timer'.


 -- Función: sstatus (<feature>, <package>)
     Configura el estado de <feature> en <package>.  Después de que
     `sstatus (<feature>, <package>)' es ejecutado `status (<feature>,
     <package>)' retorna `true'.  Esto puede ser muy útil para
     escritores de paquetes, con el objetivo de conservar las pistas de
     que caracterísiticas han cargado estos.


 -- Function: to_lisp ()
     Entra en el intérprete Lisp bajo Maxima. `(to-maxima)' retorna de
     nuevo a Maxima.


 -- Variable del sistema: values
     Valor inicial: `[]'

     `values' es una lista de todas las variables que el usuario ha
     creado (no constituye las opciones Maxima ni los interruptores).
     La lista comprende los símbolos `:' , `::', o `:='.



File: maxima.info,  Node: Operadores,  Next: Expresiones,  Prev: Línea de Comandos,  Up: Top

5 Operadores
************

* Menu:

* n-arios::
* no-fijos::
* operador::
* postfijos::
* prefijos::
* Definiciones para Operadores::


File: maxima.info,  Node: n-arios,  Next: no-fijos,  Prev: Operadores,  Up: Operadores

5.1 n-arios
===========

Un operador de tipo `nary'(`n'-ario, en Maxima nary) es usado para
denotar una función cuyo número de argumentos es arbitrario; los
argumentos se separa por el símbolo del operador, como en A+B o A+B+C.
La función `nary("x")' es una extensión de la función `syntax' para
declarar a x como un operador `n'-ario. Las funciones pueden ser
declaradas para ser `nary'. Si se hace `declare(J,nary);', se esta
diciendo al simplificador que haga la reducción de `j(j(a,b),j(c,d))' a
`j(a, b, c, d)'.

   Funciones relacionadas: `syntax'.


File: maxima.info,  Node: no-fijos,  Next: operador,  Prev: n-arios,  Up: Operadores

5.2 no-fijos
============

Los operadores de tipo `nofix' (no-fijos, en Maxima nofix) son usados
para denotar funciones que no reciben argumentos. La mera presencia de
tal operador en un comando causará que la correspondiente función sea
evaluada. Por ejemplo, cuando se escribe "exit;" para salir de una
interrupción de Maxima, "exit" se está comportando de forma similar a
un operador no-fijo (`nofix'). La función `nofix("x")' es una extensión
de la función syntax la cual declara a x como un operador `nofix'.

   Funciones relacionadas `syntax'.


File: maxima.info,  Node: operador,  Next: postfijos,  Prev: no-fijos,  Up: Operadores

5.3 operadores
==============

Véase `operadores'.


File: maxima.info,  Node: postfijos,  Next: prefijos,  Prev: operador,  Up: Operadores

5.4 postfijos
=============

Un operador de tipo `postfix' (postfijo), al contrario de los de tipo
`prefix', denota funciones de un solo argumento, pero en este caso el
argumento precede inmediatamente la ocurrencia del operador en la
cadena de entrada, como en `3!'. La función `postfix("x")' es una
extensión de la función syntax para declarar a x como un operador
`postfix'.

   Funciones relacionadas: `syntax'.


File: maxima.info,  Node: prefijos,  Next: Definiciones para Operadores,  Prev: postfijos,  Up: Operadores

5.5 prefijos
============

Un operador de tipo `prefix' (prefijo, en Maxima prefix) indica una
función de un (1) argumento, dicho argumento viene inmediatamente
después de una ocurrencia del operador. La función `prefix("x")' es una
extensión de la función syntax para declarar a x como un operador de
`prefix'.

   Funciones relacionadas: `syntax'.


File: maxima.info,  Node: Definiciones para Operadores,  Prev: prefijos,  Up: Operadores

5.6 Definiciones para Operadores
================================

 -- Operador: "!"
     El operador factorial.  Para cualquier número complejo `x'
     (incluyendo enteros, racionales  y números reales) excepto para
     enteros negativos, `x!' se define como `gamma(x+1)'.

     Para un entero `x', `x!' simplifica el producto de los enteros
     desde 1 hasta `x'.  `0!' simplifica a 1.  Para a un número de
     punto flotante `x', `x!' calcula al valor de `gamma(x+1)'.  Para
     `x' igual a `n/2' donde `n' es un entero impar, `x!' simplifica a
     un factor racional por `sqrt(%pi)' (donde `gamma(1/2)') es igual a
     `sqrt(%pi)').  Si `x' es cualquier otra cosa, `x!' no se
     simplifica.

     Las variables `factlim', `minfactorial' y  `factcomb' controlan la
     simplificación de expresiones que contienen factoriales.

     Las funciones `gamma', `bffac' y `cbffac' son variaciones la
     función gamma.  `makegamma' substituye a `gamma' para factoriales
     y funciones relacionadas.

     Funciones relacionadas: `binomial'

        * El factorial de un entero, semi-entero o de punto flotante es
          simplificado a menos que el operando sea mayor que `factlim'.

               (%i1) factlim: 10$
               (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
                         105 sqrt(%pi)
               (%o2) [1, -------------, 81.44668037931193, 40320, 20!]
                              16

        * El factorial de un número complejo, constante  conocida (por
          ejemplo `%e') o una expresión general no es simplificado.

          Sin embargo puede ser posible simplificar el factorial
          después evaluar el operando.

               (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
               (%o1)    [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
               (%i2) ev (%, numer, %enumer);
               (%o2) [(%i + 1)!, 7.188082728976031, 4.260820476357003,

                                                         1.227580202486819]

        * El factorial de un símbolo no se simplifica.

               (%i1) kill (foo)$
               (%i2) foo!;
               (%o2)                       foo!

        * Los factoriales son simplificados no evaluados.  Así `x!'
          puede ser reemplazado en una expresión antecedida por el
          operador comilla.

               (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                         105 sqrt(%pi)
               (%o1) [1, -------------, 81.44668037931193, 40320, 20!]
                              16


 -- Operador: "!!"
     El operador doble factorial.

     Para un número entero, de punto flotante o racional `n', `n!!' se
     evaluará como el producto de `n (n-2) (n-4) (n-6) ... (n - 2
     (k-1))' donde `k' es igual a `entier(n/2)', que es, el mayor entero
     menor o igual a `n/2'.  Note que esta definición no coincide con
     otras definciones publicadas para argumentos, los cuales no son
     enteros.

     Para un entero par (o impar) `n', `n!' se evalua el producto de
     todos los enteros pares (o impares) consecutivos desde 2 (o 1) por
     `n'inclusive.

     Para un argumento `n' el cual no es un número entero, punto
     flotante o racional, `n!!' produce una forma de nombre `genfact
     (n, n/2, 2)'.


 -- Operador: "#"
     Representa la negación de la igualdad sintáctica `='.

     Nótese que debido a las reglas de evaluación de expresiones de
     tipo predicado (en concreto debido a que `not <expr>' obliga a la
     evaluación previa de <expr>), `not <a> = <b>' no será equivalente
     a `<a> # <b>' en algunos casos.

     Ejemplos:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not a = b);
          (%o6)                         true


 -- Operador: "."
     El operador punto, para multiplicación de matrices
     (no-conmutativo).  Cuando "." se usa de esta forma, se dejarán
     espacios a ambos lados de éste, como en `A . B'. Así se evita que
     se confunda con el punto decimal de los números.

     Véanse: `dot', `dot0nscsimp', `dot0simp', `dot1simp', `dotassoc',
     `dotconstrules', `dotdistrib', `dotexptsimp', `dotident' y
     `dotscrules'.


 -- Operador: ":"
     El operador de asignación. Por ejemplo, `A:3' se asigna a la
     variable <A> el valor de 3.

 -- Operador: "::"
     Operador de asignación. :: asigna el valor de una expresión en su
     derecha a el valor de la cantidad en su izquierda, la cual debe
     evaluarse a una variable de tipo atómica o una variable
     subindicada.


 -- Operador: "::="
     El operador de definición de macros `::=' define una función
     (llamada macro por razones históricas) que no evalúa sus
     argumentos, siendo la expresión que retorna (llamada
     "macroexpansión") evaluada dentro del contexto desde el cual se ha
     invocado la macro. En cualquier otro sentido, una función macro es
     igual que una función ordinaria.

     `macroexpand' devuelve la expresión que a su vez fue devuelta por
     una macro (sin evaluar la expresión); `macroexpand (foo (x))'
     seguida de `''%' es equivalente a `foo (x)' si `foo' es una
     función macro.

     `::=' coloca el nombre de la nueva función macro en la lista
     global `macros'. Por otro lado, las funciones `kill', `remove' y
     `remfunction' borran las definiciones de las funciones macro y
     eliminan sus nombres de la lista `macros'.

     Las funciones `fundef' y `dispfun' devuelven la definición de una
     función macro y le asignan una etiqueta, respectivamente.

     Las funciones macro normalmente contienen expresiones `buildq' y
     `splice' para construir una expresión, que luego será evaluada.

     Ejemplos:

     Una función macro no evalúa sus argumentos, por lo que el mensaje
     (1) muestra `y - z', no el valor de `y - z'.  La macroexpansión
     (es decir, la expresión no evaluada `'(print ("(2) x is equal to",
     x))') se evalúa en el contexto desde el cual se produjo la llamada
     a la macro, imprimiendo el mensaje (2).

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printq1 (x) ::= block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
          (%o4) printq1(x) ::= block(print("(1) x is equal to", x),
                                          '(print("(2) x is equal to", x)))
          (%i5) printq1 (y - z);
          (1) x is equal to y - z
          (2) x is equal to %pi
          (%o5)                          %pi

     Una función ordinaria evalúa sus argumentos, por lo que el mensaje
     (1) muestra el valor de `y - z'.  El valor de retorno no se
     evalúa, por lo que el mensaje (2) no se imprime hasta la
     evaluación explícita `''%'.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printe1 (x) := block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
          (%o4) printe1(x) := block(print("(1) x is equal to", x),
                                          '(print("(2) x is equal to", x)))
          (%i5) printe1 (y - z);
          (1) x is equal to 1234 - 1729 w
          (%o5)              print((2) x is equal to, x)
          (%i6) ''%;
          (2) x is equal to %pi
          (%o6)                          %pi

     `macroexpand' devuelve la macroexpansión; `macroexpand (foo (x))'
     seguida de `''%' es equivalente a `foo (x)' si `foo' es una
     función macro.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) g (x) ::= buildq ([x], print ("x is equal to", x));
          (%o4)    g(x) ::= buildq([x], print("x is equal to", x))
          (%i5) macroexpand (g (y - z));
          (%o5)              print(x is equal to, y - z)
          (%i6) ''%;
          x is equal to 1234 - 1729 w
          (%o6)                     1234 - 1729 w
          (%i7) g (y - z);
          x is equal to 1234 - 1729 w
          (%o7)                     1234 - 1729 w


 -- operator: ":="
     El operador de definición de funciones. Por ejemplo,
     `f(x):=sin(x)' define  una función `f'.


 -- Operador: "="
     Denota una ecuación para Maxima. El patrón de emparejamiento en
     Maxima denota una relación total que se sostiene entre dos
     expresiones si y sólo si las expresiones son sintácticamente
     idénticas.

     La negación de `=' se representa por `#'.  Nótese que debido a las
     reglas de evaluación de expresiones de tipo predicado (en concreto
     debido a que `not <expr>' obliga a la evaluación previa de
     <expr>), `not <a> = <b>' no será equivalente a `<a> # <b>' en
     algunos casos.


 -- Operador: and
     Operador de conjunción lógica. El operador `and' es un operador
     infijo `n'-ario; sus operandos son expresiones booleanas y su
     resultado es un valor lógico.

     El operador `and' impone la evaluación (igual que `is') de uno o
     más operandos, y puede forzar la evaluación de todos los operandos.

     Los operandos se evalúan en el orden en el que aparecen; `and'
     sólo evalúa tantos operandos como sean necesarios para determinar
     el resultado. Si un operando vale `false', el resultado es `false'
     y ya no se evalúan más operandos.

     La variable global `prederror' controla el comportamiento de `and'
     cuando la evaluación de un operando no da como resultado `true' o
     `false'; `and' imprime un mensaje de error cuando `prederror' vale
     `true'.  En caso contrario, `and' devuelve `unknown'.

     El operador `and' no es conmutativo: `a and b' puede no ser igual
     a `b and a' debido al tratamiento de operandos indeterminados.


 -- Operador: or
     Operador de disyunción lógica. El operador `or' es un operador
     infijo `n'-ario; sus operandos son expresiones booleanas y su
     resultado es un valor lógico.

     El operador `or' impone la evaluación (igual que `is') de uno o
     más operandos, y puede forzar la evaluación de todos los operandos.

     Los operandos se evalúan en el orden en el que aparecen; `or' sólo
     evalúa tantos operandos como sean necesarios para determinar el
     resultado. Si un operando vale `true', el resultado es `true' y ya
     no se evalúan más operandos.

     La variable global `prederror' controla el comportamiento de `or'
     cuando la evaluación de un operando no da como resultado `true' o
     `false'; `or' imprime un mensaje de error cuando `prederror' vale
     `true'.  En caso contrario, `and' devuelve `unknown'.

     El operador `or' no es conmutativo: `a or b' puede no ser igual a
     `b or a' debido al tratamiento de operandos indeterminados.


 -- Operador: not
     Operador de negación lógica. El operador `not' es un operador
     prefijo; su operando es una expresión booleana y su resultado es
     un valor lógico.

     El operador `not' impone la evaluación (igual que `is') de su
     operando.

     La variable global `prederror' controla el comportamiento de `not'
     cuando la evaluación de su operando no da como resultado `true' o
     `false'; `not' imprime un mensaje de error cuando `prederror' vale
     `true'.  En caso contrario, `not' devuelve `unknown'.


 -- Función: abs (<expr>)
     Devuelve el valor absoluto de <expr>. Si la expresión es compleja,
     retorna el módulo de <expr>.


 -- Clave: additive
     Si `declate(f,additive)' ha sido ejecutado, entonces:

     (1) Si `f' es univariado, cada vez que el simplificador encuentre
     `f' aplicada a una suma, `f' será distribuida bajo esta suma. Por
     ejemplo, `f(x+y)' se simplificará a `f(x)+f(y)'.

     (2) Si `f' es una función de 2 o más argumentos, aditivamente es
     definida como aditiva en el primer argumento de `f', como en el
     caso de `sum' o `integrate'. Por ejemplo, `f(h(x)+g(x),x)' se
     simplificará a `f(h(x),x)+f(g(x),x)'. Esta simplificación no
     ocurre cuando `f' se aplia a expresiones de la forma
     `sum(x[i],i,lower-limit,upper-limit)'.


 -- Clave: allbut
     Opera con los comandos `part' (como `part', `inpart', `substpart',
     `substinpart', `dpart' y `lpart'). Por ejemplo:

          (%i1) expr: e+d+c+b+a$
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     mientras que:

          (%i3) part (expr, allbut (2, 5));
          (%o3)                       e + c + b

     También trabaja con el comando `kill',

          kill (allbut (name_1, ..., name_k))

     lo cual hará un `kill(all)' excepto a aquellos nombres
     especificados a `kill', en este caso. Nota: `name_i' representa un
     nombre de función tal como `u', `f', `foo' o `g', no una lista
     como `functions'.


 -- Declaración: antisymmetric
     Si `declare(h,antisymmetric)' es ejecutado, esto dice al
     simplificador que `h' es antisimétrico. E.g. `h(x,z,y)' será
     simplificado a `-h(x,y,z)'. Que es, el producto de (-1)^n por el
     resultado dado por `symmetric' o `commutative', donde n es el
     número de intercambios necesarios de dos argumentos para
     convertirle a esta forma.


 -- Función: cabs (<expr>)
     Devuelve el valor absoluto complejo (módulo complejo) de <expr>.


 -- Función: ceiling (<x>)
     Si <x> es un número real, devuelve el menor entero mayor o igual
     que <x>.

     Si <x> es una expresión constante (por ejemplo, `10 * %pi'),
     `ceiling' evalúa <x> haciendo uso de números grandes en coma
     flotante (big floats), aplicando a continuación  `ceiling' al
     número decimal obtenido. Puesto que `ceiling' hace evaluaciones en
     coma flotante, es posible, pero improbable, que esta función
     devuelva un valor erróneo para entradas constantes. Para evitar
     estos errores, la evaluación en punto flotante se lleva a cabo
     utilizando tres valores para `fpprec'.

     Para argumentos no constantes, `ceiling' intenta devolver un valor
     simplificado. Aquí se presentan algunos ejemplos sobre las
     simplificaciones que `ceiling' es capaz de hacer:

          (%i1) ceiling(ceiling(x));
          (%o1) ceiling(x)
          (%i2) ceiling(floor(x));
          (%o2) floor(x)
          (%i3) declare(n,integer)$
          (%i4) [ceiling(n), ceiling(abs(n)), ceiling(max(n,6))];
          (%o4) [n, abs(n), max(n,6)]
          (%i5) assume(x > 0, x < 1)$
          (%i6) ceiling(x);
          (%o6) 1
          (%i7) tex(ceiling(a));
             $$\left \lceil a \right \rceil$$

     La función `ceiling' no se extiende automáticamente a los
     elementos de listas y matrices.  Por último, para todos los
     argumentos que tengan una forma compleja, `ceiling' devuelve una
     forma nominal.

     Si el rango de una función es subconjunto de los números enteros,
     entonces puede ser declarada como `integervalued'. Tanto `ceiling'
     como `floor' son funciones que hacen uso de esta información; por
     ejemplo:

          (%i1) declare(f,integervalued)$
          (%i2) floor(f(x));
          (%o2) f(x)
          (%i3) ceiling(f(x) -1);
          (%o3) f(x)-1


 -- Función: charfun (<p>)
     Devuelve 0 cuando el predicado <p> toma el valor `false', y
     devuelve 1 cuando vale `true'.  Si el predicado toma un valor
     diferente de `true' y `false' (desconocido), entonces devuelve una
     forma nominal.

     Ejemplos:

          (%i1) charfun(x<1);
          (%o1) charfun(x<1)
          (%i2) subst(x=-1,%);
          (%o2) 1
          (%i3) e : charfun('"and"(-1 < x, x < 1))$
          (%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
          (%o4) [0,1,0]


 -- Declaración: commutative
     Si `declare(h,commutative)' es ejecutado, le dice al simplificador
     que `h' es una función conmutaiva. Por ejemplo, `h(x,z,y)' se
     simplificará a `h(x,y,z)'. Esto es lo mismo que `symmetric'.


 -- Función: compare (<x>, <y>)
     Devuelve un operador de comparación <op> (`<', `<=', `>', `>=',
     `=' o `#') de manera que `is (<x> <op> <y>)' tome el valor `true';
     cuando tanto <x> como <y> dependan de `%i' y `<x> # <y>', devuelve
     `notcomparable'; cuando no exista tal operador o Maxima sea
     incapaz de determinarlo, devolverá `unknown'.

     Ejemplos:

          (%i1) compare(1,2);
          (%o1) <
          (%i2) compare(1,x);
          (%o2) unknown
          (%i3) compare(%i,%i);
          (%o3) =
          (%i4) compare(%i,%i+1);
          (%o4) notcomparable
          (%i5) compare(1/x,0);
          (%o5) #
          (%i6) compare(x,abs(x));
          (%o6) <=

     La función `compare' no intenta determinar si los dominios reales
     de sus argumentos son conjuntos no vacíos; así,

          (%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
          (%o1) <

     Aquí, el dominio real de `acos (x^2 + 1)' es el conjunto vacío.


 -- Función: entier (<x>)
     Devuelve el mayor entero menor o igual a <x>, siendo <x> numérico.
     La función  `fix' (como en `fixnum') es un sinónimo, de modo que
     `fix(<x>)' hace justamente lo mismo.


 -- Función: equal (<expr_1>, <expr_2>)
     Utilizado junto con `is', devuelve `true' (o `false') si y sólo si
     <expr_1> y <expr_2> son iguales (o no) para todos los posibles
     valores de sus variables (tal como los calcula `ratsimp').  Así,
     `is (equal ((x + 1)^2, x^2 + 2*x + 1))' devuelve `true', mientras
     que si `x' no tiene valor asignado, `is ((x + 1)^2 = x^2 + 2*x +
     1)' devuelve `false'. Nótese también que `is(rat(0)=0)' da `false'
     pero `is (equal (rat(0), 0))' da `true'.

     Si algún cálculo no se puede hacer, `is (equal (a, b))' devuelve
     una expresión simplificada y equivalente, mientras que  `is (a=b)'
     siempre devuelve `true' o `false'.

     Todas las variables presentes en <expr_1> y <expr_2> se suponen
     números reales.

     La negación de  `equal' es `notequal'.  Nótese que debido a las
     reglas de evaluación de expresiones de tipo predicado (en concreto
     debido a que `not <expr>' obliga a la evaluación previa de
     <expr>), `notequal' no será equivalente a `not equal' en algunos
     casos.

     La llamada `ev (<expr>, pred)' equivale a `is (<expr>)'.

          (%i1) is (x^2 >= 2*x - 1);
          (%o1)                         true
          (%i2) assume (a > 1);
          (%o2)                        [a > 1]
          (%i3) is (log (log (a+1) + 1) > 0 and a^2 + 1 > 2*a);
          (%o3)                         true

      -- Función: floor (<x>)
          Si <x> es un número real, devuelve el mayor entero menor o
          igual que <x>.

          Si <x> es una expresión constante (por ejemplo, `10 * %pi'),
          `floor' evalúa <x> haciendo uso de números grandes en coma
          flotante (big floats), aplicando a continuación  `floor' al
          número decimal obtenido. Puesto que `floor' hace evaluaciones
          en coma flotante, es posible, pero improbable, que esta
          función devuelva un valor erróneo para entradas constantes.
          Para evitar estos errores, la evaluación en punto flotante se
          lleva a cabo utilizando tres valores para `fpprec'.

          Para argumentos no constantes, `floor' intenta devolver un
          valor simplificado. Aquí se presentan algunos ejemplos sobre
          las simplificaciones que `floor' es capaz de hacer:

               (%i1) floor(ceiling(x));
               (%o1) ceiling(x)
               (%i2) floor(floor(x));
               (%o2) floor(x)
               (%i3) declare(n,integer)$
               (%i3) [floor(n), floor(abs(n)), floor(min(n,6))];
               (%o4) [n,abs(n),min(n,6)]
               (%i4) assume(x > 0, x < 1)$
               (%i5) floor(x);
               (%o5) 0
               (%i6) tex(floor(a);
                   $$\left \lfloor a \right \rfloor$$

          La función `floor' no se extiende automáticamente a los
          elementos de listas y matrices.  Por último, para todos los
          argumentos que tengan una forma compleja, `floor' devuelve
          una forma nominal.

          Si el rango de una función es subconjunto de los números
          enteros, entonces puede ser declarada como `integervalued'.
          Tanto `ceiling' como `floor' son funciones que hacen uso de
          esta información; por ejemplo:

               (%i1) declare(f,integervalued)$
               (%i2) floor(f(x));
               (%o2) f(x)
               (%i3) ceiling(f(x) -1);
               (%o3) f(x)-1



 -- Función: notequal (<expr_1>, <expr_2>)
     Representa la negación de `equal (<expr_1>, <expr_2>)'.

     Nótese que debido a las reglas de evaluación de expresiones de
     tipo predicado (en concreto debido a que `not <expr>' obliga a la
     evaluación previa de <expr>), `notequal' no será equivalente a
     `not equal' en algunos casos.

     Ejemplos:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          `macsyma' was unable to evaluate the predicate:
          equal(a, b)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) maybe (not equal (a, b));
          (%o6)                        unknown
          (%i7) assume (a > b);
          (%o7)                        [a > b]
          (%i8) equal (a, b);
          (%o8)                      equal(a, b)
          (%i9) maybe (equal (a, b));
          (%o9)                         false
          (%i10) notequal (a, b);
          (%o10)                   notequal(a, b)
          (%i11) not equal (a, b);
          (%o11)                        true
          (%i12) maybe (notequal (a, b));
          (%o12)                        true
          (%i13) maybe (not equal (a, b));
          (%o13)                        true


 -- Operador: eval
     El operador `eval' realiza una evaluación extra de una expresión
     <expr>.  Véase `ev'.


 -- Función: evenp (<expr>)
     Devuelve `true' si <expr> es un entero par y `false' en cualquier
     otro caso.


 -- Función: fix (<x>)
     Es un sinónimo de  `entier (<x>)'.


 -- Función: fullmap (<f>, <expr_1>, ...)
     Similar a `map', pero conservará el mapeado descendente de todas
     las subexpresiones hasta que los operadores principales ya no sean
     los mismos.

     La función `fullmap' es utilizada por el simplificador de Maxima
     en algunas transformaciones matriciales, por lo que Maxima
     generará en algunas ocasiones mensajes de error relacionados con
     `fullmap' aunque el usuario no haya invocado explícitamente esta
     función.

          (%i1) a + b*c$
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)


 -- Function: fullmapl (<f>, <list_1>, ...)
     Similar a `fullmap', pero `fullmapl' sólo hace mapeo sobre listas
     y matrices.

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]


 -- Función: is (<expr>)
     Intenta determinar si el predicado <expr>  se puede deducir de los
     hechos almacenados en la base de datos gestionada por `assume'.

     Si el predicado se reduce a `true' o `false', `is' devuelve `true'
     o `false', respectivamente.  En otro caso, el valor devuelto está
     controlado por la variable global `prederror'.  Si `prederror'
     vale `false', `is' devuelve `unknown' si el predicado no se puede
     reducir a un valor de verdad lógica, retornando un mensaje de
     error si `prederror' vale `true'.

     Véanse también `assume', `facts' y `maybe'.

     Ejemplos:

     `is' hace evaluación de predicados.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     `is' evalúa predicados a partir de la base de datos de `assume'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     Si `is' no puede evaluar el valor lógico del predicado a partir de
     la base de datos gestionada por `assume', la variable global
     `prederror' controla el comportamiento de `is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          `macsyma' was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown


 -- Función: maybe (<expr>)
     Intenta determinar si el predicado <expr>  se puede deducir de los
     hechos almacenados en la base de datos gestionada por `assume'.

     Si el predicado se reduce a `true' o `false', `maybe' devuelve
     `true' o `false', respectivamente.  En otro caso, `maybe' devuelve
     `unknown'.

     La función `maybe' es funcionalmente equivalente a `is' con
     `prederror: false', pero el resultado se calcula sin asignar valor
     alguno a `prederror'.

     Véanse también `assume', `facts' y `is'.

     Ejemplos:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Función: isqrt (<x>)
     Devuelve la "raíz cuadrada entera" del valor absoluto de <x>, el
     cual debe ser un entero.


 -- Función: lmax (<L>)
     Si <L> es una lista o conjunto, devuelve `apply ('max, args
     (<L>))'.  Si <L> no es una lista o conjunto, envía un mensaje de
     error.

 -- Función: lmin (<L>)
     Si <L> es una lista o conjunto, devuelve `apply ('min, args
     (<L>))'.  Si <L> no es una lista o conjunto, envía un mensaje de
     error.

 -- Función: max (<x_1>, ..., <x_n>)
     Devuelve un valor simplificado de la mayor de las expresiones
     desde <x_1> hasta <x_n>.  Si `get (trylevel, maxmin)' es 2 o más,
     `max' aplica la simplificación `max (e, -e) --> |e|'.  Si `get
     (trylevel, maxmin)' es 3 o más, <max> intenta eliminar las
     expresiones que estén entre otros dos de los argumentos dados; por
     ejemplo, `max (x, 2*x, 3*x) --> max (x, 3*x)'. Para asignar el
     valor 2 a `trylevel' se puede hacer `put (trylevel, 2, maxmin)'.


 -- Función: min (<x_1>, ..., <x_n>)
     Devuelve un valor simplificado de la menor de las expresiones
     desde <x_1> hasta <x_n>.  Si `get (trylevel, maxmin)' es 2 o más,
     `min' aplica la simplificación `min (e, -e) --> |e|'.  Si `get
     (trylevel, maxmin)' es 3 o más, <min> intenta eliminar las
     expresiones que estén entre otros dos de los argumentos dados; por
     ejemplo, `min (x, 2*x, 3*x) --> min (x, 3*x)'. Para asignar el
     valor 2 a `trylevel' se puede hacer `put (trylevel, 2, maxmin)'.


 -- Función: polymod (<p>)
 -- Función: polymod (<p>, <m>)
     Convierte el polinomio <p> a una representación modular respecto
     del módulo actual, que es el valor almacenado en la variable
     `modulus'.

     La llamada `polymod (<p>, <m>)' especifica un módulo <m> para ser
     utilizado en lugar de valor almacenado en `modulus'.

     Véase `modulus'.

 -- Función: mod (<x>, <y>)
     Si <x> e <y> son números reales e <y> es distinto de cero,
     devuelve `<x> - <y> * floor(<x> / <y>)'.  Para todos los reales
     <x>, se tiene `mod (<x>, 0) = <x>'. Para información sobre la
     definición de  `mod (<x>, 0) = <x>', véase la sección 3.4 de
     "Concrete Mathematics", by Graham, Knuth, and Patashnik. La
     función `mod (<x>, 1)' es de diente de sierra con periodo unidad y
     con `mod (1, 1) = 0' y `mod (0, 1) = 0'.

     Para encontrar el argumento principal (un número del intervalo
     `(-%pi, %pi]') de un número complejo, hágase uso de la función
     `<x> |-> %pi - mod (%pi - <x>, 2*%pi)', donde <x> es un argumento.

     Si <x> e <y> son expresiones constantes (por ejemplo, `10 * %pi'),
     `mod' utiliza el mismo esquema de evaluación basado en números
     grandes en coma flotante (big floats) que `floor' y `ceiling'.
     También es posible, pero improbable, que `mod' pueda retornar un
     valor erróneo en tales casos.

     Para argumentos no numéricos <x> o <y>, `mod' aplica algunas
     reglas de simplificación:

          (%i1) mod(x,0);
          (%o1) x
          (%i2) mod(a*x,a*y);
          (%o2) a*mod(x,y)
          (%i3) mod(0,x);
          (%o3) 0

 -- Función: oddp (<expr>)
     Devuelve `true' si <expr> es un entero impar y `false' en caso
     contrario.


 -- Operador: pred
     El operador `pred' realiza una evaluación extra de un predicado
     (expresión cuya evaluación debe dar `true' o `false'). Véase `ev'.


 -- Función: make_random_state (<n>)
 -- Función: make_random_state (<s>)
 -- Función: make_random_state (true)
 -- Función: make_random_state (false)
     Un objeto de estado aleatorio representa el estado del generador
     de números aleatorios. El estado consiste en 627 cadenas binarias
     de 32 bits.

     La llamada `make_random_state (<n>)' devuelve un nuevo objeto de
     estado aleatorio creado a partir de una semilla entera igual a <n>
     módulo 2^32. El argumento <n> puede ser negativo.

     La llamada `make_random_state (<s>)' devuelve una copia del estado
     aleatorio <s>.

     La llamada `make_random_state (true)' devuelve un nuevo objeto de
     estado aleatorio, cuya semilla se genera a partir de la hora
     actual del reloj del sistema como semilla.

     La llamada `make_random_state (false)' devuelve una copia del
     estado actual del generador de números aleatorios.


 -- Función: set_random_state (<s>)
     Establece <s> como estado del generador de números aleatorios.

     La función `set_random_state' devuelve `done' en todo caso.


 -- Función: random (<x>)
     Devuelve un número seudoaleatorio. Si <x> es un entero, `random
     (<x>)' devuelve un entero entre 0 y `<x> - 1', ambos inclusive. Si
     <x> es un decimal en punto flotante, `random (<x>)' devuelve un
     decimal no negativo en punto flotante menor que <x>.  La función
     `random' emite un mensaje de error si <x> no es ni entero ni de
     punto flotante, o si <x> no es positivo.

     Las funciones `make_random_state' y `set_random_state' permiten
     controlar el estado del generador de números aleatorios.

     El generador de números aleatorios de Maxima implementa el
     algoritmo de Mersenne twister MT 19937.

     Ejemplos:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


 -- Función: rationalize (<expr>)
     Convierte todos los números en coma flotante de doble precisión y
     grandes (big float) presentes en una expresión <expr> de Maxima a
     a sus formas racionales exactas equivalentes. Si el usuario no
     está familiarizado con la representación binaria de números en
     coma flotante, le puede extrañar que `rationalize (0.1)' no sea
     igual que 1/10.  Este comportamiento no es único de Maxima, ya que
     el número 1/10 en su forma binaria es periódico y no exacto.

          (%i1) rationalize(0.5);
          (%o1) 1/2
          (%i2) rationalize(0.1);
          (%o2) 3602879701896397/36028797018963968
          (%i3) fpprec : 5$
          (%i4) rationalize(0.1b0);
          (%o4) 209715/2097152
          (%i5) fpprec : 20$
          (%i6) rationalize(0.1b0);
          (%o6) 236118324143482260685/2361183241434822606848
          (%i7) rationalize(sin(0.1 * x + 5.6));
          (%o7) sin((3602879701896397*x)/36028797018963968+3152519739159347/562949953421312)

     Ejemplo de uso:

          unitfrac(r) := block([uf : [], q],
             if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
             while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
             reverse(uf));

          (%i2) unitfrac(9/10);
          (%o2) [1/2,1/3,1/15]
          (%i3) apply("+",%);
          (%o3) 9/10
          (%i4) unitfrac(-9/10);
          (%o4) [-1,1/10]
          (%i5) apply("+",%);
          (%o5) -9/10
          (%i6) unitfrac(36/37);
          (%o6) [1/2,1/3,1/8,1/69,1/6808]
          (%i7) apply("+",%);
          (%o7) 36/37


 -- Función: sign (<expr>)
     Intenta determinar el signo de <expr> en base a los hechos
     almacenados en la base de datos. Devuelve una de las siguientes
     respuestas: `pos' (positivo), `neg' (negativo), `zero' (cero), `pz'
     (positivo o cero), `nz' (negativo o cero), `pn' (positivo o
     negativo), o `pnz' (positivo, negativo o cero, lo que significa
     que el signo es desconocido).


 -- Función: signum (<x>)
     Para <x> numérico, devuelve 0 si <x> es 0, en caso contrario
     devuelve -1 o +1, según que <x> sea menor o mayor que 0,
     respectivamente.

     Si <x> no es numérico, entonces se devuelve una forma simplificada
     equivalente.  Por ejemplo, `signum(-x)' devuelve `-signum(x)'.


 -- Función: sort (<list>, <p>)
 -- Función: sort (<list>)
     Ordena <list> de acuerdo con el predicado `p' de dos argumentos,
     como `"<"' o `orderlessp'.

     La llamada `sort (<list>)' ordena <list> de acuerdo con la
     ordenación preestablecida en Maxima.

     El argumento <list> puede contener elementos numéricos o no
     numéricos o de de ambos tipos.


 -- Función: sqrt (<x>)
     Raíz cuadrada de <x>. Se representa internamente por `<x>^(1/2)'.
     Véase también `rootscontract'.

     Si la variable `radexpand' vale `true' hará que las raíces
     `n'-ésimas de los factores de un producto que sean potencias de
     `n' se extraídas del radical; por ejemplo, `sqrt(16*x^2)' se
     convertirá en `4*x' sólo si `radexpand' vale `true'.


 -- Variable opcional: sqrtdispflag
     Valor por defecto: `true'

     Si `sqrtdispflag' vale `false', hará que `sqrt' se muestre con el
     exponente 1/2.


 -- Función: sublis (<list>, <expr>)
     Realiza sustituciones  múltiples en paralelo en una expresión.

     La variable `sublis_apply_lambda' controla la simplificación
     después de `sublis'.

     Ejemplo:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)


 -- Función: sublist (<list>, <p>)
     Devuelve la lista de elementos de <list> para los cuales el
     predicado `p' retorna `true'.

     Ejemplo:

          (%i1) L: [1, 2, 3, 4, 5, 6]$
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Variable opcional: sublis_apply_lambda
     Valor por defecto: `true'

     Controla si los `lambda' sustituidos son aplicados en la
     simplificación después de invocar a `sublis', o si se tiene que
     hacer un `ev' para hacerlo. Si `sublis_apply_lambda' vale `true',
     significa que se ejecute la aplicación.


 -- Función: subst (<a>, <b>, <c>)
     Sustituye <a> por <b> en <c>. El argumento  <b> debe ser un átomo
     o una subexpresión completa de <c>.  Por ejemplo, `x+y+z' es una
     subexpresión completa de  `2*(x+y+z)/w' mientras que `x+y' no lo
     es. Cuando <b> no cumple esta característica, se puede utilizar en
     algunos casos `substpart' o `ratsubst' (ver más abajo).
     Alternativamente, si <b> no es de la forma `e/f' entonces se puede
     usar `subst (a*f, e, c)', pero si <b> es de la forma `e^(1/f)' se
     debe usar `subst (a^f, e, c)'.  La instrucción `subst' también
     reconoce `x^y' en `x^-y', de manera que  `subst (a, sqrt(x),
     1/sqrt(x))' da `1/a'. Los argumentos <a> y <b> también pueden ser
     operadores de una expresión acotados por comillas dobles `"' o
     nombres de funciones.  Si se quiere sustituir la variable
     independiente en expresiones con derivadas se debe utilizar la
     función `at' (ver más abajo).

     La función `subst' es sinónimo de `substitute'.

     La llamada `subst (<eq_1>, <expr>)' o `subst ([<eq_1>, ...,
     <eq_k>], <expr>)' están permitidas.  Las <eq_i> son ecuaciones que
     indican las sustituciones a realizar.  Para cada ecuación, el
     miembro derecho será sustituida por la expresión del miembro
     izquierdo en <expr>.

     Si la variable `exptsubst' vale `true' se permiten ciertas
     sustituciones de exponentes; por ejemplo, sustituir `y' por `%e^x'
     en `%e^(a*x)'.

     Si `opsubst' vale `false', `subst' no intentará sustituir un
     operador de una expresión. Por ejemplo, `(opsubst: false, subst
     (x^2, r, r+r[0]))' trabajará sin problemas.

     Ejemplos:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Para más ejemplos, ejecútese `example (subst)'.


 -- Función: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Es similar a `substpart', pero `substinpart' trabaja con la
     representación interna de <expr>.

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       D
          (%o1)                    x . --- (f(x))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x+1), 0);
          (%o3)                       f1(x + 1)

     Si el último argumento de la función `part' es una lista de
     índices, entonces se toman varias subexpresiones, cada una de las
     cuales en correspondencia con un índice de la lista. Así,

          (%i1) part (x+y+z, [1, 3]);
          (%o1)                         z + x

     `piece' guarda el valor de la última expresión seleccionada cada
     vez que se utiliza la función `part'. Esta asignación se se hace
     durante la ejecución de la función, con lo que puede ser
     referenciada en la propia función tal como se muestra más abajo.
     Si `partswitch' vale `true' entonces se devuelve `end' cuando la
     parte seleccionada de una expresión no existe, en caso contrario
     se muestra un mensaje de error.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Además, darle a la opción `inflag' el valor `true' y llamar a
     `part' o a `substpart' es lo mismo que llamar a `inpart' o a
     `substinpart'.


 -- Función: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Sustituye <x> por la subexpresión determinada por el resto de
     argumentos, según el esquema de `part'.  Devuelve el nuevo valor
     de <expr>. El argumento  <x> puede ser un operador a ser
     sustituido por un operador de <expr>. En algunos casos <x>
     necesita estar acotado por comillas dobles `"', como en `substpart
     ("+", a*b, 0)' para que retorne `b + a'.

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f (b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Además, darle a la opción `inflag' el valor `true' y llamar a
     `part' o a `substpart' es lo mismo que llamar a `inpart' o a
     `substinpart'.


 -- Función: subvarp (<expr>)
     Devuelve `true' si <expr> es una variable subindicada, como `a[i]'.


 -- Función: symbolp (<expr>)
     Devuelve `true' si <expr> es un símbolo y `false' en caso
     contrario.  La llamada `symbolp(x)' equivale al predicado `atom(x)
     and not numberp(x)'.

     Véase también `Identifiers'.


 -- Función: unorder ()
     Desactiva las asociaciones creadas por la última utilización de
     los comandos de ordenación `ordergreat' y `orderless', los cuales
     no pueden ser utilizados más de una vez sin invocar a `unorder'.
     Véase también `ordergreat' y `orderless'.

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
                                       2
          (%o4)                       a  + b x
          (%i5) %th(1) - %th(3);
                                        2    2
          (%o5)                        a  - a
          (%i6) unorder();
          (%o6)                          [a]


 -- Función: vectorpotential (<givencurl>)
     Devuelve el vector potencial de un vector rotacional en el sistema
     de coordenadas actual.  `potentialzeroloc' tiene un rol similar al
     de `potential', pero el orden del miembro izquierdo de las
     ecuaciones debe ser una permutación cíclica de las coordenadas.


 -- Función: xthru (<expr>)
     Combina todos los términos de <expr> (la cual debe ser una suma)
     sobre un común denominador sin expandir productos ni sumas
     elevadas a exponentes al modo que lo hace `ratsimp'. La función
     `xthru' cancela factores comunes en el numerador y denominador de
     expresiones racionales, pero sólo si los factores son explícitos.

     En ocasiones puede ser útil el uso de `xthru' antes de la llamada
     a `ratsimp' a fin de cancelar factores explícitos del máximo común
     divisor del numerador y denominador y así simplificar la expresión
     a la que se va a aplicar `ratsimp'.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


 -- Función: zeroequiv (<expr>, <v>)
     Analiza si la expresión <expr> de variable <v> equivale a cero,
     devolviendo `true', `false' o `dontknow'.

     La función `zeroequiv' tiene estas restricciones:
       1. No utilizar funciones que Maxima no sepa derivar y evaluar.

       2. Si la expresión tiene polos en la recta real, pueden aparecer
          errores en el resultado, aunque es poco probable.

       3. Si la expresión contiene funciones que no son soluciones de
          ecuaciones diferenciales ordinarias de primer orden (como las
          funciones de Bessel) pueden presentarse resultados
          incorrectos.

       4. El algoritmo utiliza evaluaciones en puntos aleatoriamente
          seleccionados. Esto conlleva un riesgo,aunque el algoritmo
          intenta minimizar el error.

     Por ejemplo, `zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' devuelve
     `true' y `zeroequiv (%e^x + x, x)' devuelve `false'.  Por otro
     lado `zeroequiv (log(a*b) - log(a) - log(b), a)' devuelve
     `dontknow' debido a la presencia del parámetro `b'.



File: maxima.info,  Node: Expresiones,  Next: Simplificación,  Prev: Operadores,  Up: Top

6 Expresiones
*************

* Menu:

* Introducción a las Expresiones::
* Asignación::
* Expresiones complejas::
* Nombres y verbos::
* Identificadores::
* Desigualdades::
* Sintaxis::
* Definiciones para Expresiones::


File: maxima.info,  Node: Introducción a las Expresiones,  Next: Asignación,  Prev: Expresiones,  Up: Expresiones

6.1 Introducción a las Expresiones
==================================

Existe un cierto número de palabras reservadas que no pueden utilizarse
como nombres de variables. Su uso podría causar errores críticos de
sintaxis.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   La mayoría de los objetos en Maxima son expresiones. Una secuencia
de expresiones puede constituir una expresión, separándolas por comas y
colocando paréntesis alrededor de ellas. Esto es similar a las
expresiones con coma en C.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Incluso los bucles en Maxima son expresiones, aunque el valor que
retornan (`done') no es muy útil.

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   pero quizás se quiera incluir un tercer término en la expresión con
coma para que devuelva el valor de interés.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Asignación,  Next: Expresiones complejas,  Prev: Introducción a las Expresiones,  Up: Expresiones

6.2 Asignación
==============

Existen dos operadores de asignación en Maxima, `:' y `::'.  Por
ejemplo, `a: 3' asigna a la variable `a' el valor de 3. Por otro lado,
`::' asigna el valor de la expresión de su derecha al valor de la
cantidad de su izquierda, el cual debe evaluarse a una variable de tipo
átomo o una variable subindicada.


File: maxima.info,  Node: Expresiones complejas,  Next: Nombres y verbos,  Prev: Asignación,  Up: Expresiones

6.3 Expresiones complejas
=========================

Una expresión compleja se especifica en Maxima añadiendo a la parte
real de la expresión el producto de `%i' por la parte imaginaria. Así
las raíces de la ecuación `x^2 - 4*x + 13 = 0' son `2 + 3*%i' y `2 -
3*%i'. Nótese que la simplificación de productos de expresiones
complejas puede ser efectuado expandiendo el producto. La
simplificación de cocientes, raíces y otras funciones que contengan
expresiones complejas pueden normalmente conseguirse a través de las
funciones `realpart', `imagpart', `rectform', `polarform', `abs' o
`carg'.


File: maxima.info,  Node: Nombres y verbos,  Next: Identificadores,  Prev: Expresiones complejas,  Up: Expresiones

6.4 Nombres y verbos
====================

Maxima distingue entre operadores que son "nombres" y operadores que
son "verbos".  Un verbo es un operador que puede ser ejecutado.  Un
nombre es un operador que aparece como un símbolo en una expresión pero
sin ser ejecutado.  Por defecto, los nombres de funciones son verbos.
Un verbo puede transformarse en nombre utilizando el apóstrofo o
aplicando la función `nounify'.  Un nombre puede transformarse en verbo
aplicando la función `verbify'.  La variable `nouns' hace que `ev'
evalúe los nombres presentes en una expresión.

   La forma verbal se distingue mediante la precedencia del carácter
dólar `$' al correspondiente símbolo de Lisp.  Por otro lado, la forma
nominal se distingue mediante la precedencia del carácter porcentaje
`%' al correspondiente símbolo de Lisp.  Algunos nombres gozan de
propiedades especiales para su representación, como `'integrate' o
`'derivative' (devuelto por `diff'), pero la mayoría no.  Por defecto,
las formas nominal y verbal de una función son idénticas cuando se
muestran en un terminal.  La variable global `noundisp' hace que Maxima
muestre los nombres precedidos del apóstrofo `''.

   Véanse también `noun', `nouns', `nounify' y `verbify'.

   Ejemplos:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identificadores,  Next: Desigualdades,  Prev: Nombres y verbos,  Up: Expresiones

6.5 Identificadores
===================

En Maxima, los identificadores pueden contener caracteres alfabéticos,
números del 0 al 9 y cualquier otro carácter precedido de la barra
invertida `\'.

   Un identificador puede comenzar con un carácter numérico si éste va
precedido de la barra invertida `\'.  Los caracteres numéricos que
ocupen la segunda posición o posterior no necesitan ir precedidos de la
barra invertida.

   Un carácter especial puede declararse alfabético con la función
`declare'.  Así declarado, no necesita ir precedido de la barra
invertida en un identificador.  En principio, los caracteres
alfabéticos son las letras de `A' a `Z' y `a' a `z', junto con  `%' y
`_'.

   Maxima distingue minúsculas y mayúsculas. Los identificadores `foo',
`FOO' y `Foo' son distintos.  Véase *Note Lisp y Maxima:: para más
información.

   Un identificador en Maxima es un símbolo Lisp que comienza con el
símbolo dólar `$'.  Cualquier otro símbolo de Lisp va precedido de la
interrogación `?' cuando aparece en Maxima.  Véase *Note Lisp y
Maxima:: para más información.

   Ejemplos:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Desigualdades,  Next: Sintaxis,  Prev: Identificadores,  Up: Expresiones

6.6 Desigualdades
=================

Maxima dispone de los operadores de desigualdad `<', `<=', `>=', `>',
`#' y `notequal'.  Véase `if' para una descripción de las expresiones
condicionales.


File: maxima.info,  Node: Sintaxis,  Next: Definiciones para Expresiones,  Prev: Desigualdades,  Up: Expresiones

6.7 Sintaxis
============

Es posible definir nuevos operadores con una precedencia especificada,
o eliminar o redefinir la precedencia de operadores ya existentes.  Un
operador puede ser de tipo prefijo unario o postfijo unario, infijo
binario, infijo `n'-ario, "bi-fijo" (matchfix) o "no-fijo"; "bi-fijo"
se refiere a un par de símbolos que encierran su o sus argumentos, y
"no-fijo" es un operador que no necesita argumentos.  A continuación
ejemplos sobre los diferentes tipos de operadores.

prefijo unario
     negación `- a'

postfijo unario
     factorial `a!'

infijo binario
     exponenciación `a^b'

n-ary infix
     suma `a + b'

"bi-fijo"
     construcción de una lista `[a, b]'

   (Maxima no incluye operadores "no-fijos", pero se puede ver un
ejemplo en `nofix'.)

   El mecanismo para definir un nuevo operador es sencillo.  Tan solo
es necesario declarar una función como operador; la función operador
puede estar definida o no.

   Un ejemplo de operador definido por el usuario es el siguiente.
Nótese que la llamada a función `"dd" (a)' equivale a `dd a', de igual
manera que  `"<-" (a, b)' también equivale a `a <- b'.  Nótese también
que las funciones `"dd"' y `"<-"' no están definidas en este ejemplo.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   Las funciones de Maxima que definen nuevos operadores se resumen en
esta tabla, en la que se establecen las fuerzas de enlace a izquierda
(lbp, de left binding power) y a derecha (rbp, de right binding power)
por defecto.  (La fuerza de enlace determina la precedencia del
operador. Sin embargo, puesto que las fuerzas de enlace a izquierda y
derecha pueden ser diferentes, la fuerza de enlace es algo más que la
simple precedencia.)  Algunas de las funciones para definir operadores
toman argumentos adicionales; véanse las descripciones de estas
funciones para más detalles.

`prefix'
     rbp=180

`postfix'
     lbp=180

`infix'
     lbp=180, rbp=180

`nary'
     lbp=180, rbp=180

`matchfix'
     (la fuerza de enlace no se aplica aquí)

`nofix'
     (la fuerza de enlace no se aplica aquí)

   A efectos comparativos, aquí se presentan algunos operadores de
Maxima junto con sus fuerzas de enlace a izquierda y derecha.

     Operator   lbp     rbp

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   Las funciones `remove' y `kill' eliminan propiedades de operadores
de un átomo.  La llamada `remove ("<a>", op)' sólo elimina las
propiedades de operador de <a>.  La llamada `kill ("<a>")' elimina
todas las propiedades de <a>, incluidas las propiedades de operador.
Nótese que el nombre del operador debe ir entre comillas.

     (%i1) infix ("@");
     (%o1)                           @
     (%i2) "@" (a, b) := a^b;
                                          b
     (%o2)                      a @ b := a
     (%i3) 5 @ 3;
     (%o3)                          125
     (%i4) remove ("@", op);
     (%o4)                         done
     (%i5) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i5) "@" (5, 3);
     (%o5)                          125
     (%i6) infix ("@");
     (%o6)                           @
     (%i7) 5 @ 3;
     (%o7)                          125
     (%i8) kill ("@");
     (%o8)                         done
     (%i9) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i9) "@" (5, 3);
     (%o9)                        @(5, 3)


File: maxima.info,  Node: Definiciones para Expresiones,  Prev: Sintaxis,  Up: Expresiones

6.8 Definiciones para Expresiones
=================================

 -- Función: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Función: at (<expr>, <eqn>)
     Evalúa la expresión <expr> asignando a las variables los valores
     especificados para ellas en la lista de ecuaciones `[<eqn_1>, ...,
     <eqn_n>]' o en la ecuación simple <eqn>.

     Si una subexpresión depende de cualquiera de las variables para la
     cual se especifica un valor, pero  no puede ser evaluado, entonces
     `at' devuelve una forma nominal.

     La función `at' realiza múltiples sustituciones en serie, no en
     paralelo.

     Véase también `atvalue'.  Para otras funciones que también llevan
     a cabo sustituciones, consúltense `subst' y `ev'.

     Ejemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Función: box (<expr>)
 -- Función: box (<expr>, <a>)
     Devuelve <expr> encerrada en una caja.  El valor devuelto es una
     expresión con `box' como operador y <expr> como argumento.  Se
     dibujará una caja cuando `display2d' valga `true'.

     La llamada `box (<expr>, <a>)' encierra <expr> en una caja
     etiquetada con el símbolo <a>.  La etiqueta se recorta si es más
     larga que el ancho de la caja.

     La expresión encerrada no se evalúa, siendo excluída de los
     cálculos.

     La variable `boxchar' guarda el carácter a utilizar para dibujar
     la caja en las funciones `box', `dpart' y `lpart'.

     Ejemplos:

          (%i1) box (a^2 + b^2);
                       """""""""
                       " 2   2 "
          (%o1)        "b  + a "
                       """""""""
          (%i2) box (a^2 + b^2, term_1);
                       term_1"""
                       " 2   2 "
          (%o2)        "b  + a "
                       """""""""
          (%i3) 1729 - box (1729);
                            """"""
          (%o3)      1729 - "1729"
                            """"""
          (%i4) boxchar: "-";
          (%o4)            -
          (%i5) box (sin(x) + cos(y));
                          -----------------
          (%o5)           -COS(y) + SIN(x)-
                          -----------------
          (%i6)


 -- Variable opcional: boxchar
     Valor por defecto: `"'

     La variable `boxchar' guarda el carácter a utilizar para dibujar
     la caja en las funciones `box', `dpart' y `lpart'.

     Todas las cajas en una expresión se dibujan con el valor actual de
     `boxchar', carácter que no se almacena con las expresión encerrada.


 -- Función: carg (<z>)
     Devuelve el argumento complejo de <z>.  El argumento complejo es
     un ángulo `theta' en `(-%pi, %pi]' tal que `r exp (theta %i) =
     <z>' donde `r' es la magnitud de <z>.

     La función `carg' es computacional, no simplificativa.

     La función `carg' ignora la declaración `declare (<x>, complex)',
     y trata a <x> como una variable real.  Se trata de un fallo
     conocido en Maximo.  Véanse también `abs' (módulo complejo),
     `polarform', `rectform', `realpart' y `imagpart'.

     Ejemplos:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Operator especial: constant
     La llamada `declare (<a>, constant)' declara <a> como constante.
     Véase `declare'.


 -- Función: constantp (<expr>)
     Devuelve `true' si <expr> es una expresión constante y `false' en
     caso contrario.

     Una expresión se considera constante si sus argumentos son números
     (incluidos los números racionales que se muestran con `/R/'),
     constantes simbólicas como `%pi', `%e' o `%i', variables con valor
     constante o declarada como constante por `declare', o funciones
     cuyos argumentos son constantes.

     La función `constantp' evalúa sus argumentos.

     Ejemplos:

          (%i1) constantp (7 * sin(2));
          (%o1) 				     TRUE
          (%i2) constantp (rat (17/29));
          (%o2) 				     TRUE
          (%i3) constantp (%pi * sin(%e));
          (%o3) 				     TRUE
          (%i4) constantp (exp (x));
          (%o4) 				     FALSE
          (%i5) declare (x, constant);
          (%o5) 				     DONE
          (%i6) constantp (exp (x));
          (%o6) 				     TRUE
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7) 				     FALSE
          (%i8)

 -- Función: declare (<a_1>, <f_1>, <a_2>, <f_2>, ...)
     Asigna al átomo <a_i> la característica <f_i>.  Las <a_i> y las
     <f_i> también pueden ser listas de átomos y características,
     respectivamente, en cuyo caso cada átomo toma todas las
     características.

     La función `declare' no evalúa sus argumentos y devuelve siempre
     `done'.

     Las posibles características y sus significados son:

     `constant' convierte a <a_i> en una constante, como `%pi'.

     `mainvar' convierte a <a_i> en `mainvar'.  Ordenación de los
     átomos: números < constantes (como `%e', `%pi') < escalares <
     otras variables < mainvars.

     `scalar' convierte a <a_i> en escalar.

     `nonscalar' hace que <a_i> se comporte como una lista o matriz
     ante el operador punto.

     `noun' convierte la función <a_i> en un nombre, de manera que no
     se evalúe automáticamente.

     `evfun' hace que <a_i> sea reconocida por la función `ev' de
     manera que se aplique cuando se mencione su nombre.  Véase `evfun'.

     `evflag' hace que <a_i> sea reconocida por la función `ev' de
     manera que tome el valor `true' durante la ejecución de `ev' si es
     mencionada.  Véase `evflag'.

     `bindtest' hace que <a_i> envíe un error si en algún momento es
     utilizada en un cálculo sin habérsele asignado un valor.

     Maxima reconoce y utiliza las siguientes propiedades de objetos:

          even, odd, integer, rational, irrational, real, imaginary,
          and complex

     Propiedades útiles para funciones son:

          increasing,
          decreasing, oddfun (odd function), evenfun (even function),
          commutative (or symmetric), antisymmetric, lassociative and
          rassociative

     La llamada `featurep (<object>, <feature>)' determina si <object>
     ha sido declarado con la propiedad <feature>.

     Véase también `features'.


 -- Función: disolate (<expr>, <x_1>, ..., <x_n>)
     Es similar a `isolate (<expr>, <x>)', excepto que permite al
     usuario aislar más de una variable simultáneamente. Puede ser útil
     para hacer un cambio de variables en integrales múltiples en las
     que tales variables dependan de de dos o más variables de
     integración.  Esta función se carga automáticamente desde
     `simplification/disol.mac'.  Se dispone de una demostyración en
     `demo("disol")$'.


 -- Función: dispform (<expr>)
     Devuelve la representación externa de <expr> con respecto a su
     operador principal. Es útil cuando se usa conjuntamente con
     `part', que también trata de la representación externa.  Sipóngase
     que  <expr> es -A .  Entonces la representación interna de  <expr>
     es "*"(-1,A), mientras que la representación externa es "-"(A). La
     llamada `dispform (<expr>, all)' convierte la expresión entera al
     formato externo.  Por ejemplo, si `expr: sin (sqrt (x))', entonces
     `freeof (sqrt, expr)' y `freeof (sqrt, dispform (expr))' dan
     `true', mientras que `freeof (sqrt, dispform (expr, all))' da
     `false'.


 -- Función: distrib (<expr>)
     Diistribuye sumas sobre productos.  Difiere de `expand' en que
     trabaja sólo al nivel superior de una expresión, siendo más rápida
     que `expand'.  Difiere de  `multthru' en que expande todas las
     sumas del nivel superior.

     Ejemplos:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Función: dpart (<expr>, <n_1>, ..., <n_k>)
     Selecciona la misma expresión que `part', pero en lugar de
     devolver esa expresión como su valor, devuelve la expresión
     completa con la subexpresión seleccionada dentro de una caja. La
     caja es parte de la expresión.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """


 -- Función: exp (<x>)
     Representa la función exponencial.  La expresión  `exp (<x>)' en
     la entrada se simplifica en `%e^<x>'; `exp' no aparece en
     expresiones simplificadas.

     Si la variable `demoivre' vale `true' hace que `%e^(a + b %i)' se
     simplifique a `%e^(a (cos(b) + %i sin(b)))' si `b' no contiene a
     `%i'. Véase `demoivre'.

     Si la variable `%emode' vale `true', hace que  `%e^(%pi %i x)' se
     simplifique. Véase `%emode'.

     Si la variable `%enumer' vale `true' hace que `%e' se reemplace por
     2.718...  siempre que `numer' valga `true'. Véase `%enumer'.


 -- Variable opcional: %emode
     Valor por defecto: `true'

     Si `%emode' vale `true', `%e^(%pi %i x)' se simplifica como sigue.

     `%e^(%pi %i x)' se simplifica a `cos (%pi x) + %i sin (%pi x)' si
     `x' es un entero o múltiplo de 1/2, 1/3, 1/4 o 1/6, y luego se
     sigue simplificando.

     Para otros valores numéricos de `x', `%e^(%pi %i x)' se simplifica
     a `%e^(%pi %i y)' donde `y' es `x - 2 k' para algún entero `k' tal
     que `abs(y) < 1'.

     Si `%emode' vale `false', no se realizan simplificaciones
     especiales a `%e^(%pi %i x)'.


 -- Variable opcional: %enumer
     Valor por defecto: `false'

     Si la variable `%enumer' vale `true' hace que `%e' se reemplace por
     2.718...  siempre que `numer' valga `true'.

     Si `%enumer' vale `false', esta sustitución se realiza sólo si el
     exponente en `%e^x' tiene un valor numérico.

     Véanse también `ev' y `numer'.


 -- Variable opcional: exptsubst
     Valor por defecto: `false'

     Si `exptsubst' vale `true' permite la sustitución `y' por `%e^x'
     en `%e^(a x)'.


 -- Función: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof (<x_1>, <expr>)' Devuelve `true' si ninguna subexpresión
     de  <expr> es igual a <x_1> o si  <x_1> aparece como variable muda
     en <expr>, devolviendo `false' en otro caso.

     La llamada `freeof (<x_1>, ..., <x_n>, <expr>)' equivale a `freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     Los argumentos <x_1>, ..., <x_n> pueden seer nombres de funciones
     y variables, nombres subindicados, operadores (encerrados entre
     comillas dobles) o expresiones generales.  La función `freeof'
     evalúa sus argumentos.

     Una variable es una variable muda en una expresión si no tiene
     valor asignado fuera de la expresión.  Variable mudas reconocidas
     por  `freeof' son el índice de una suma o producto, la variable
     límite en `limit', la variable de integración en la versión de
     integral definida de `integrate', la variable original en
     `laplace', variables formales en expresiones `at' y los argumentos
     de las expresiones  `lambda'.  Las variables locales en  `block'
     no son reconocidas por `freeof' como variables mudas; esto es un
     fallo de Maxima.

     La versión indefinida de  `integrate' no está libre de su variable
     de integración.

        * Los argumentos son nombres de funciones, variables, nombres
          subindicados, operaores y expresiones. La llamada `freeof (a,
          b, expr)' equivale a `freeof (a, expr) and freeof (b, expr)'.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        * `freeof' evalúa sus argumentos.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        * `freeof' no considera funciones equivalentes.  La
          simplificación puede dar una expresión equivalente pero
          diferente.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        * Un sumatorio o integral definida está libre de su variable
          muda.  Una integral indefinida de  `integrate' no está libre
          de su variable de integración

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false


 -- Función: genfact (<x>, <y>, <z>)
     Devuelve el factorial generalizado, definido como `x (x-z) (x - 2
     z) ... (x - (y - 1) z)'.  Así, para el entero <x>, `genfact (x, x,
     1) = x!' y `genfact (x, x/2, 2) = x!!'.


 -- Función: imagpart (<expr>)
     Devuelve la parte imaginaria de la expresión <expr>.

     La función `imagpart' es computacional, no simplificativa.

     Véanse también `abs', `carg', `polarform', `rectform' y `realpart'.


 -- Función: infix (<op>)
 -- Función: infix (<op>, <lbp>, <rbp>)
 -- Función: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declara <op> como operador infijo.  Un operador infijo es una
     función de dos argumentos, con el nombre de la función escrito
     entre sus argumentos.  Por ejemplo, el operador de sustracción `-'
     es un operador infijo.

     `infix (<op>)' declara <op> como operador infijo con fuerzas de
     ligadura por la izquierda y por la derecha iguales a 180, que es
     el valor por defecto, y partes izquierda y derecha iguales a `any'.

     `infix (<op>, <lbp>, <rbp>)' declara <op> como operador infijo con
     fuerzas de ligadura por la izquierda y por la derecha declaradas
     en los argumentos, siendo las partes izquierda y derecha iguales a
     `any'.

     `infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declara <op>
     como operador infijo con fuerzas de ligadura por la izquierda y
     por la derecha y partes declaradas en los argumentos.

     La precedencia de <op> con respecto a otros operadores deriva de
     las fuerzas de ligadura de los operadores en cuestión.  Si las
     fuerzas de ligadura a izquierda y derecha de <op> son ambas
     mayores que las fuerzas de ligadura a izquierda y derecha de otro
     operador, entonces <op> tiene preferencia sobre el otro operador.
     Si las fuerzas de ligadura no son ambas mayores o menores, se
     aplican otras relaciones más complejas.

     La asociatividad de <op> depende de las fuerzas de ligadura.  Una
     mayor fuerza de ligadura a la izquierda (<lbp>) implica que <op>
     sea evaluado antes que otros operadores a su izquierda en la
     expresión, mientras que mayor fuerza de ligadura a la derecha
     (<rbp>) implica que <op> sea evaluado antes que otros operadores a
     su derecha en la expresión.  Así, si <lbp> es mayor, <op> es
     asociativo por la derecha, mientras que si <rbp> es mayor, <op> es
     asociativo por la izquierda.

     Véase también `Syntax'.

     Ejemplos:

        * Si las fuerzas de ligadura a izquierda y derecha de <op> son
          ambas mayores que las fuerzas de ligadura a izquierda y
          derecha de otro operador, entonces <op> tiene preferencia
          sobre el otro operador.

          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) :lisp (get '$+ 'lbp)
          100
          (%i2) :lisp (get '$+ 'rbp)
          100
          (%i2) infix ("@", 101, 101)$
          (%i3) 1 + a@b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("@", 99, 99)$
          (%i5) 1 + a@b + 2;
          (%o5)                       (a+1,b+2)

        * Mayor <lbp> hace a <op> asociativo por la derecha, mientras
          que mayor  <rbp> hace a <op> asociativo por la izquierda.

          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) infix ("@", 100, 99)$
          (%i3) foo @ bar @ baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("@", 100, 101)$
          (%i5) foo @ bar @ baz;
          (%o5)                    ((foo,bar),baz)


 -- Variable opcional: inflag
     Valor por defecto: `false'

     Si `inflag' vale `true', las funciones para la extracción de
     partes inspeccionan la forma interna de `expr'.

     Nótese que el simplificador reordena expresiones.  Así,  `first (x
     + y)' devuelve `x' si `inflag' vale `true' y `y' si `inflag' vale
     `false'.  (`first (y + x)' devuelve el mismo resultado.)

     Además, dándole a  `inflag' el valor `true' y llamando a `part' o
     a `substpart' es lo mismo que llamar a `inpart' o a `substinpart'.

     Las funciones que se ven afectadas por el valor de `inflag' son:
     `part', `substpart', `first', `rest', `last', `length', la
     construcción `for' ... `in', `map', `fullmap', `maplist', `reveal'
     y `pickapart'.


 -- Función: inpart (<expr>, <n_1>, ..., <n_k>)
     Similar a `part', pero trabaja con la representación interna de la
     expresión, siendo más rápida. Se debe tener cuidado con el orden
     de subexpresiones en sumas y productos, pues el orden de las
     variables en la forma interna es normalmente diferente al que se
     muestra por el terminal, y cuando se trata con el signo menos
     unario, resta y división, pues estos operadores desaparecen de la
     expresión. Las llamadas `part (x+y, 0)' o `inpart (x+y, 0)'
     devuelven `+', siendo necesario encerrar el operador entre
     comillas dobles cuando se haga referencia aél. Por ejemplo, `...
     if inpart (%o9,0) = "+" then ...'.

     Ejemplos:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Función: isolate (<expr>, <x>)
     Devuelve <expr> con subexpresiones que son sumas y que no
     contienen variables reemplazadas por etiquetas de expresiones
     intermedias (tales etiquetas son símbolos atómicos como `%t1',
     `%t2', ...).  Esta función es de utilidad para evitar la expansión
     innecesaria de subexpresiones que no contienen la variable de
     interés. Puesto que las etiquetas intermedias toman el valor de
     subexpresiones pueden ser todas sustituidas evaluando la expresión
     en la que aparecen.

     Si la variable `exptisolate', cuyo valor por defecto es `false',
     vale `true' hará que `isolate' busque exponentes de átomos (como
     `%e') que contengan la variable.

     Si `isolate_wrt_times' vale `true', entonces `isolate' también
     aislará respecto de productos. Véase `isolate_wrt_times'.

     Para ejemplos, ejecútese `example (isolate)'.


 -- Variable opcional: isolate_wrt_times
     Valor por defecto: `false'

     Si `isolate_wrt_times' vale `true', entonces `isolate' también
     aislará respecto de productos. Compárese el comportamiento de
     `isolate' al cambiar el valor de esta variable global en el
     siguiente ejemplo,

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Variable opcional: listconstvars
     Valor por defecto: `false'

     Si `listconstvars' vale `true', hará que `listofvars' incluya
     `%e', `%pi', `%i' y cualquier otra variable que sea declarada
     constante de las que aparezcan en el argumento de `listofvars'.
     Estas constantes se omiten por defecto.


 -- Variable opcional: listdummyvars
     Valor por defecto: `true'

     Si `listdummyvars' vale `false', las "variables mudas" de la
     expresión no serán incluídas en la lista devuelta por
     `listofvars'. (La definición de "variables mudas" se encuentra en
     la descripción de `freeof'.  "Variables mudas" son objetos
     matemáticos como el índice de un sumatorio o producto, una
     variable límite o la variable de una integración definida.)
     Ejemplo:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Función: listofvars (<expr>)
     Devuelve una lista con las variables presentes en <expr>.

     Si la variable `listconstvars' vale `true' entonces  `listofvars'
     incluirá `%e', `%pi', `%i'y cualquier otra variable declarada
     constante de las que aparezcan en <expr>.  Estas constantes se
     omiten por defecto.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Función: lfreeof (<list>, <expr>)
     Para cada miembro  <m> de <list>, realiza la llamada `freeof (<m>,
     <expr>)'.  Devuelve `false' si alguna de estas llamadas a `freeof'
     retornó `false', y `true' en caso contrario.

 -- Función: lopow (<expr>, <x>)
     Devuelve el mínimo exponente de <x> que aparece explícitamente en
     <expr>.  Así,

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)


 -- Función: lpart (<label>, <expr>, <n_1>, ..., <n_k>)
     Similar a `dpart' pero utiliza una caja etiquetada. Una caja
     etiquetada es similar a la que produce `dpart', pero con un nombre
     en la línea superior.


 -- Función: multthru (<expr>)
 -- Función: multthru (<expr_1>, <expr_2>)
     Multiplica un factor (que debería ser una suma) de <expr> por los
     otros factores de <expr>.  Esto es, <expr> es `<f_1> <f_2> ...
     <f_n>', donde al menos un factor, por ejemplo <f_i>, es una suma
     de términos.  Cada término en esta suma se multiplica por los
     otros factores del producto, excepto el propio <f_i>. La función
     `multthru' no expande sumas elevadas a exponentes, siendo el
     método más rápido para distribuir productos (sean o no
     conmutativos) sobre sumas. Puesto que los cocientes se representan
     como productos, puede utilizarse`multthru' para dividir sumas
     entre productos.

     La llamada `multthru (<expr_1>, <expr_2>)' multiplica cada término
     de <expr_2> (que debería ser una suma o una ecuación) por
     <expr_1>.  Si <expr_1> no es ella misma una suma, entonces la
     llamada es equivalente a `multthru (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Función: nounify (<f>)
     Devuelve la forma nominal de la función cuyo nombre es <f>.  Puede
     ser útil cuando se quiera hacer referencia al nombre de una
     función sin que ésta se ejecute.  Nótese que algunas funciones
     verbales devolverán su forma nominal si no pueden ser evaluadas
     para ciertos argumentos.  Esta es también la expresión que se
     obtiene cuando la llamada a una función va precedida por del
     apóstrofo.


 -- Función: nterms (<expr>)
     Devuelve el número de términos que  <expr> llegaría a tener si
     fuese completamente expandida y no hubiesen cancelaciones ni
     combinaciones de términos semejantes.  Nótese que expresiones como
     `sin (<expr>)', `sqrt (<expr>)', `exp (<expr>)', etc.  cuentan
     como un sólo término, independientemente de cuántos términos tenga
     a su vez <expr> en caso de tratarse de una suma.


 -- Función: op (<expr>)
     Devuelve el operador principal de la expresión <expr>. La llamada
     `op (<expr>)' equivale a `part (<expr>, 0)'.

     La función `op' devuelve una cadena si el operador principal es un
     operador prefijo, infijo (binario o `n'-ario), postfijo, "bi-fijo"
     o "no-fijo" ("bi-fijo"  se refiere a un par de símbolos que
     encierran su o sus argumentos, y "no-fijo" es un operador que no
     necesita argumentos).  En cualquier otro caso `op' devuelve un
     símbolo.

     La función `op' observa el valor de la variable global `inflag'.

     La función `op' evalúa sus argumentos.

     Véase también `args'.

     Ejemplos:

          (%i1) ?stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"


 -- Función: operatorp (<expr>, <op>)
 -- Función: operatorp (<expr>, [<op_1>, ..., <op_n>])
     La llamada `operatorp (<expr>, <op>)' devuelve `true' si <op> es
     igual al operador de <expr>.

     La llamada `operatorp (<expr>, [<op_1>, ..., <op_n>])' devuelve
     `true' si algún elemento  <op_1>, ..., <op_n> es igual al operador
     de <expr>.


 -- Función: optimize (<expr>)
     Devuelve una expresión que produce el mismo valor y efectos
     secundarios que <expr>, pero de forma más eficiente al evitar
     recalcular subexpresiones comunes. La función `optimize' también
     tiene el efecto secundario de colapsar su argumento de manera que
     se compartan todas sus subexpresiones comunes.  Hágase `example
     (optimize)' para ver ejemplos.


 -- Variable opcional: optimprefix
     Valor por defecto: `%'

     La variable `optimprefix' es el prefijo utilizado para los
     símbolos generados por la instrucción `optimize'.


 -- Función: ordergreat (<v_1>, ..., <v_n>)
     Establece una ordenación para las variables <v_1>, ..., <v_n> de
     manera que <v_1> > <v_2> > ...  > <v_n> y <v_n> > cualquier otra
     variable no mencionada como argumento.

     Véase también `orderless'.


 -- Función: ordergreatp (<expr_1>, <expr_2>)
     Devuelve `true' si <expr_2> precede a <expr_1> según el orden
     establecido con la función `ordergreat'.


 -- Función: orderless (<v_1>, ..., <v_n>)
     Establece una ordenación para las variables <v_1>, ..., <v_n> de
     manera que <v_1> < <v_2> < ...  < <v_n> y <v_n> < cualquier otra
     variable no mencionada como argumento.

     Así, la ordenación completa de objetos es: constantes numéricas <
     constantes declaradas < escalares declarados < primer argumento de
     `orderless' < ...  < último argumento de `orderless' < variables
     que empiezan por A < ...  < variables que empiezan por Z < último
     argumento de  `ordergreat' <  ... < primer argumento de
     `ordergreat' < objetos declarados como `mainvar'.

     Véanse también `ordergreat' y `mainvar'.


 -- Función: orderlessp (<expr_1>, <expr_2>)
     Devuelve `true' si <expr_1> precede a <expr_2> según el orden
     establecido con la función `orderless'.


 -- Función: part (<expr>, <n_1>, ..., <n_k>)
     Devuelve partes de la forma mostrada de `expr'. Obtiene la parte
     de `expr' que se especifica por los índices <n_1>, ..., <n_k>.
     Primero se obtiene la parte <n_1> de `expr', después la parte
     <n_2> del resultado anterior, y así sucesivamente.  El resultado
     que se obtiene es la parte <n_k> de ... la parte <n_2> de la parte
     <n_1> de `expr'.

     La función `part' se puede utilizar para obtener un elemento de
     una lista, una fila de una matriz, etc.

     Si el último argumento de la función `part' es una lista de
     índices, entonces se toman varias subexpresiones, cada una de las
     cuales correspondiente a un índice de la lista.  Así, `part (x + y
     + z, [1, 3])' devuelve `z+x'.

     La variable `piece' guarda la última expresión seleccionada con la
     función `part'. Se actualiza durante la ejecución de la función,
     por lo que puede ser referenciada en la misma función.

     Si `partswitch' vale `true' entonces de devuelve `end' cuando no
     exista la parte seleccionada de una expresión, si vale `false' se
     mostrará un mensaje de error.

     Ejemplo: `part (z+2*y, 2, 1)' devuelve 2.

     La instrucción `example (part)' muestra más ejemplos.


 -- Función: partition (<expr>, <x>)
     Devuelve una lista con dos expresiones, que son: (1) los factores
     de <expr> si es un producto, los términos de <expr> si es una
     suma, o los elementos de <expr>, si es una lista, que no contengan
     a <x>, (2) los factores, términos o lista que contengan a <x>.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Variable opcional: partswitch
     Valor por defecto: `false'

     Si `partswitch' vale `true' entonces de devuelve `end' cuando no
     exista la parte seleccionada de una expresión, si vale `false' se
     mostrará un mensaje de error.


 -- Función: pickapart (<expr>, <n>)
     Asigna etiquetas de expresiones intermedias a subexpresiones de
     <expr> al nivel de profundidad <n>, que es un entero. A las
     subexpresiones a un nivel de profundidad mayor o menor no se les
     asignan etiquetas. La función `pickapart' devuelve una expresión
     en términos de expresiones intermedias equivalente a la expresión
     original <expr>.

     Véanse también `part', `dpart', `lpart', `inpart' y `reveal'.

     Ejemplos:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- System variable: piece
     Guarda la última expresión seleccionada por las funciones `part'.


 -- Función: polarform (<expr>)
     Devuelve una expresión de la forma `r %e^(%i theta)' equivalente a
     <expr>, con `r' y `theta' son reales.


 -- Función: powers (<expr>, <x>)
     Devuelve las potencias de <x> dentro de <expr>.

     La instrucción `load (powers)' carga esta función.


 -- Función: product (<expr>, <i>, <i_0>, <i_1>)
     Representa el producto de los valores de `expr' según el índice
     <i> varía de <i_0> hasta <i_1>.  La forma nominal `'product' se
     presenta en forma de letra pi mayúscula.

     La función `product' evalúa <expr> y los límites inferior y
     superior, <i_0> y <i_1>, pero no evalúa el índice <i>.

     Si la diferencia entre los límites superior e inferior es un
     número entero, la expresión <expr> se evalúa para cada valor del
     índice <i>, siendo el resultado un producto en forma explícita.

     En caso contrario, el rango del índice no está definido,
     aplicándose entonces algunas reglas que permitan simplificar el
     producto.  Cuando la variable global `simpproduct' valga `true',
     se aplicarán reglas adicionales.  En ciertos casos, la
     simplificación dará lugar a un resultado que ya no tenga el
     formato del producto; en caso contrario se devolverá una forma
     nominal `'product'.

     Véanse también `nouns' y `evflag'.

     Ejemplos:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b


 -- Función: realpart (<expr>)
     Devuelve la parte real de <expr>. La funciones `realpart' y
     `imagpart' operan también con expresiones que contengan funciones
     trigonométricas e hiperbólicas, raíces cuadradas, logaritmos y
     exponentes.


 -- Función: rectform (<expr>)
     Devuelve una expresión de la forma `a + b %i' equivalente a
     <expr>, con <a> y <b> reales.


 -- Función: rembox (<expr>, unlabelled)
 -- Función: rembox (<expr>, <label>)
 -- Función: rembox (<expr>)
     Elimina cajas de <expr>.

     La llamada `rembox (<expr>, unlabelled)' elimina todas las cajas
     no etiquetadas de <expr>.

     La llamada `rembox (<expr>, <label>)' sólo elimina las cajas
     etiquetadas con <label>.

     La llamada `rembox (<expr>)' elimina todas las caajs,
     independientemente de que estén etiquetadas o no.

     Las cajas son dibujadas por las funciones `box', `dpart' y `lpart'.

     Ejemplos:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Función: sum (<expr>, <i>, <i_0>, <i_1>)
     Representa la suma de los valores de `expr' según el índice <i>
     varía de <i_0> hasta <i_1>.  La forma nominal `'sum' se presenta
     en forma de letra sigma mayúscula.

     La función `sum' evalúa su sumando <expr> y los límites inferior y
     superior, <i_0> y <i_1>, pero no evalúa el índice <i>.

     Si la diferencia entre los límites superior e inferior es un
     número entero, el sumando <expr> se evalúa para cada valor del
     índice <i>, siendo el resultado una suma en forma explícita.

     En caso contrario, el rango del índice no está definido,
     aplicándose entonces algunas reglas que permitan simplificar la
     suma.  Cuando la variable global `simpsum' valga `true', se
     aplicarán reglas adicionales.  En ciertos casos, la simplificación
     dará lugar a un resultado que ya no tenga el formato del
     sumatorio; en caso contrario se devolverá una forma nominal
     `'product'.

     Cuando `cauchysum' vale `true', el producto de sumatorios se
     expresa como un producto de Cauchy, en cuyo caso el índice del
     sumatorio interior es función del índice del exterior, en lugar de
     variar independientemente.

     La variable global `genindex' guarda el prefijo alfabético a
     utilizar cuando sea necesario generar automáticamente el siguiente
     índice de sumatorio.

     La variable global `gensumnum' guarda el sufijo numérico a
     utilizar cuando sea necesario generar automáticamente el siguiente
     índice de sumatorio. Si `gensumnum' vale `false', un índice
     generado automáticamente constará sólo de `genindex', sin sufijo
     numérico.

     Véanse también `sumcontract', `intosum', `bashindices',
     `niceindices', `nouns' y `evflag'.

     Ejemplos:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
          Incorrect syntax: Too many )'s
          else b^k, k, 1, 10))
                            ^
          (%i12) linenum:11;
          (%o11)                         11
          (%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o12)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a


 -- Función: lsum (<expr>, <x>, <L>)
     Representa la suma de <expr> para cada elemento <x> en <L>.

     Se retornará la forma nominal `'lsum' si el argumento <L> no es
     una lista.

     Ejemplos:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)


 -- Función: verbify (<f>)
     Devuelve la forma verbal del nombre de función <f>.

     Véanse también `verb', `noun' y `nounify'.

     Ejemplos:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Simplificación,  Next: Gráficos,  Prev: Expresiones,  Up: Top

7 Simplificación
****************

* Menu:

* Definiciones para Simplificación::


File: maxima.info,  Node: Definiciones para Simplificación,  Prev: Simplificación,  Up: Simplificación

7.1 Definiciones para Simplificación
====================================

* Menu:

 -- Variable del sistema: askexp
     Cuando se invoca a `asksign', la expresión que se va a analizar es
     precisamente `askexp'.


 -- Función: askinteger (<expr>, integer)
 -- Función: askinteger (<expr>)
 -- Función: askinteger (<expr>, even)
 -- Función: askinteger (<expr>, odd)
     La llamada `askinteger (<expr>, integer)' intenta determinar a
     partir de la base de datos de `assume' si <expr> es un entero. La
     función `askinteger' pide más información al usuario si no
     encuentra la respuesta, tratando de almacenar la nueva información
     en la base de datos si es posible. La llamada `askinteger
     (<expr>)' equivale a `askinteger (<expr>, integer)'.

     La llamadas `askinteger (<expr>, even)' ay `askinteger (<expr>,
     odd)' intentan determinar si <expr> es un entero par o impar,
     respectivamente.


 -- Función: asksign (<expr>)
     Primero intenta determinar si la expresión especificada es
     positiva, negativa o cero.  Si no lo consigue, planteará al
     usuario preguntas que le ayuden a conpletar la deducción. Las
     respuestas del usuario son almacenadas en la base de datos durante
     el tiempo que dure este cálculo. El valor que al final devuelva
     `asksign' será `pos', `neg' o `zero'.


 -- Función: demoivre (<expr>)
 -- Variable opcional: demoivre
     La función `demoivre (expr)' convierte una expresión sin modificar
     la variable global `demoivre'.

     Cuando `demoivre' vale `true', los exponenciales complejos se
     convierten en expresiones equivalentes pero en términos de las
     funciones trigonométricas: `exp (a + b*%i)' se reduce a `%e^a *
     (cos(b) + %i*sin(b))' si `b' no contiene a `%i'. Las expresiones
     `a' y `b' no se expanden.

     El valor por defecto de `demoivre' es `false'.

     La función `exponentialize' convierte funciones trigonométricas e
     hiperbólicas a la forma exponencial, por lo que  `demoivre' y
     `exponentialize' no pueden valer `true' al mismo tiempo.


 -- Variable opcional: domain
     Valor por defecto: `real'

     Si `domain' vale `complex', `sqrt (x^2)' permanecerá como `sqrt
     (x^2)' en lugar de devolver `abs(x)'.


 -- Función: expand (<expr>)
 -- Función: expand (<expr>, <p>, <n>)
     Expande la expresión <expr>. Los productos de sumas y de sumas con
     exponentes se multiplican, los numeradores de las expresiones
     racionales que son sumas se separan en sus respectivos términos, y
     las multiplicaciones (tanto las que son conmutativas como las que
     no) se distribuyen sobre las sumas en todos los niveles de <expr>.

     En el caso de los polinomios es más aconsejable utilizar
     `ratexpand', que utiliza un algoritmo más eficiente.

     Las variables `maxnegex' y `maxposex' controlan los máximos
     exponentes negativos y positivos que se van a expandir.

     La llamada `expand (<expr>, <p>, <n>)' expande <expr> asignando a
     `maxposex' el valor <p> y a `maxnegex' el <n>. Esto es útil para
     expandir sólo parte de la expresión.

     La variable `expon' guarda el mayor exponente negativo que será
     expandido automáticamente, independientemente de `expand'. Por
     ejemplo, si `expon' vale 4 entonces `(x+1)^(-5)' no se expandirá
     automáticamente.

     La variable `expop' guarda el mayor exponente positivo que será
     expandido automáticamente.  Así, `(x+1)^3' se expandirá
     automáticamente sólo si `expop' es mayor o igual que 3. Si se
     quiere expandir `(x+1)^n', siendo `n' mayor que `expop', entonces
     `expand ((x+1)^n)' se desarrollará sólo si `maxposex' no es menor
     que `n'.

     La variable `expand' utilizada con `ev' provocará una expansión.

     El fichero `simplification/facexp.mac' contiene algunas funciones
     relacionadas con `expand' (en concreto, `facsum', `factorfacsum' y
     `collectterms', que se cargan automáticamente) y variables
     (`nextlayerfactor' y `facsum_combine') que permiten al usuario
     estructurar las expresiones controlando la expansión.  En
     `simplification/facexp.usg' se pueden encontrar breves
     descripciones de estas funciones.  Se accederá a una demostración
     con la instrucción `demo("facexp")'.


 -- Función: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expande la expresión `expr' con respecto a las variables <x_1>,
     ..., <x_n>.  Todos los productos que contengan a las variables
     aparecen explícitamente. El resultado que se obtenga no tendr'a
     productos de sumas de expresiones que contengan a las variables.
     Los argumentos  <x_1>, ..., <x_n> pueden ser variables, operadores
     o expresiones.

     Por defecto, no se expanden los denominadores, pero esto puede
     cambiarse mediante el uso de la variable `expandwrt_denom'.

     Esta función se carga automáticamente de
     `simplification/stopex.mac'.


 -- Variable opcional: expandwrt_denom
     Valor por defecto: `false'

     La variable `expandwrt_denom' controla el tratamiento de las
     expresiones racinales por parte de `expandwrt'. Si vale `true', se
     expandirán tanto el numerador como el denominador de la expresión
     respecto de los argumentos de `expandwrt', pero si
     `expandwrt_denom' vale `false', sólo se expandirá el numerador.


 -- Función: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     Es similar a `expandwrt', pero trata a las expresiones que son
     productos de una forma algo diferente. La función
     `expandwrt_factored' expande sólo aquellos factores de `expr' que
     contienen a las variables <x_1>, ..., <x_n>.

     Esta función se carga automáticamente de
     `simplification/stopex.mac'.


 -- Variable opcional: expon
     Valor por defecto: 0

     La variable `expon' guarda el mayor exponente negativo que será
     expandido automáticamente, independientemente de `expand'. Por
     ejemplo, si `expon' vale 4 entonces `(x+1)^(-5)' no se expandirá
     automáticamente.


 -- Función: exponentialize (<expr>)
 -- Variable opcional: exponentialize
     La función `exponentialize (expr)' convierte las funciones
     trigonométricas e hiperbólicas de <expr> a exponenciales, sin
     alterar la variable global `exponentialize'.

     Cuando la variable `exponentialize' vale `true', todas las
     funciones trigonométricas e hiperbólicas se convierten a forma
     exponencial. El valor por defecto es `false'.

     La función `demoivre' convierte funciones trigonométricas e
     hiperbólicas a la forma exponencial, por lo que  `demoivre' y
     `exponentialize' no pueden valer `true' al mismo tiempo.


 -- Variable opcional: expop
     Valor por defecto: 0

     La variable `expop' guarda el mayor exponente positivo que será
     expandido automáticamente.  Así, `(x+1)^3' se expandirá
     automáticamente sólo si `expop' es mayor o igual que 3. Si se
     quiere expandir `(x+1)^n', siendo `n' mayor que `expop', entonces
     `expand ((x+1)^n)' se desarrollará sólo si `maxposex' no es menor
     que `n'.


 -- Variable opcional: factlim
     Valor por defecto: -1

     La variable `factlim' especifica el mayor factorial que será
     expandido automáticamente.  Si su valor es -1, entonces se
     expandirán todos los enteros.


 -- Función: intosum (<expr>)
     Mueve los factores multiplicativos que están fuera de un sumatorio
     hacia dentro de éste. Si el índice aparece en la expresión
     exterior, entonce `intosum' busca un índice razonable, lo mismo
     que hace con `sumcontract'. Se trata de la operación contraria a
     extraer factores comunes de los sumatorios.

     En algunos caos puede ser necesario hacer `scanmap (multthru,
     <expr>)' antes que `intosum'.


 -- Declaración: lassociative
     La instrucción `declare (g, lassociative)' le indica al
     simplificador de Maxima que `g' es asociativo por lña izquierda.
     Por ejemplo, `g (g (a, b), g (c, d))'se reduce a `g (g (g (a, b),
     c), d)'.


 -- Declaración: linear
     Es una de las propiedades de operadores de Maxima. Si la función
     univariante `f' se declara lineal, la expansión de  `f(x + y)'
     produce `f(x) + f(y)', `f(a*x)' produce `a*f(x)' si `a' es una
     constante.  Si la función tiene dos o más argumentos, la
     linealidad se interpreta como la de `sum' o `integrate', esto es,
     `f (a*x + b, x)' produce `a*f(x,x) + b*f(1,x)' si `a' y `b' no
     contienen a `x'.

     `linear' equivale a `additive' y `outative'.  Véase también
     `opproperties'.


 -- Declaración: mainvar
     Se pueden declarar variables de tipo `mainvar'.  El orden de los
     átomos es: números < constantes (como `%e' o `%pi') < escalares <
     otras variables < "mainvars".  Por ejemplo, compárese `expand
     ((X+Y)^4)' con `(declare (x, mainvar), expand ((x+y)^4))'.  (Nota:
     Se debe tener cuidado si se quiere hacer uso de esta declaración.
     Por ejemplo, si se resta una expresión en la que `x' ha sido
     declarada como `mainvar' de otra en la que `x' no es `mainvar',
     puede ser necesario volver a simplificar, `ev (expr, simp)', a fin
     de obtener cancelaciones.  Además, si se guarda una expresión en
     la que `x' es `mainvar', quizás sea necesario guardar también `x'.)


 -- Variable opcional: maxapplydepth
     Valor por defecto: 10000

     La variable `maxapplydepth' es la máxima profundidad a la que van
     a introducirse `apply1' y  `apply2'.


 -- Variable opcional: maxapplyheight
     Valor por defecto: 10000

     La variable `maxapplyheight' es la m2'axima altura a la que
     escalará `applyb1' antes de detenerse.


 -- Variable opcional: maxnegex
     Valor por defecto: 1000

     La variable `maxnegex' es el mayor exponente negativo que
     expandirá la función `expand'. Véase también `maxposex'.


 -- Variable opcional: maxposex
     Valor por defecto: 1000

     La variable `maxposex' es el mayor exponenteque expandirá la
     función `expand'. Véase también `maxnegex'.


 -- Declaración: multiplicative
     La instrucción `declare (f, multiplicative)' indica al
     simplificador de Maxima que `f' is multiplicativa.

       1. Si `f' es univariante, cada vez que el simplificador
          encuentre a `f' aplicad a un producto, `f' se distribuirá
          sobre ese producto.  Por ejemplo, `f(x*y)' se reduciría a
          `f(x)*f(y)'.

       2. Si `f' es una función de 2 o más argumentos, la
          multiplicabilidad se define como multiplicabilidad para el
          primer argumento de `f', de modo que `f (g(x) * h(x), x)' se
          reduciría a `f (g(x) ,x) * f (h(x), x)'.

     Esta transformación no se realiza cuando `f' se aplica a
     expresiones de la forma `product (x[i], i, m, n)'.


 -- Variable opcional: negdistrib
     Valor por defecto: `true'

     Si `negdistrib' vale `true', -1 se distribuye sobre una expresión.
     Por ejemplo, `-(x + y)' se transforma en `- y - x'.  Dándole el
     valor `false' se mostrará `- (x + y)' tal cual. Esto puede ser
     útil, pero también peligroso; al igual que el indicador `simp', no
     conviene asignarle el valor `false'.


 -- Variable opcional: negsumdispflag
     Valor por defecto: `true'

     Si `negsumdispflag' vale `true', `x - y' se muestra como `x - y'
     en lugar de `- y + x'.  Dándole el valor `false' se realiza un
     análisis adicional para que no se representen de forma muy
     diferente dos expresiones similares.  Una aplicación puede ser
     para que `a + %i*b' y `a - %i*b' se representen ambas de la misma
     manera.


 -- Símbolo especial: noeval
     El símbolo `noeval' evita la fase de evaluación de `ev'. Es útil
     conjuntamente con otras variables globales y para poder volver a
     simplificar expresiones sin tener que evaluarlas otra vez.


 -- Declaración: noun
     El símbolo `noun' es una de las opciones de la instrucción
     `declare'. Hace que una función se declare como "nombre", lo que
     significa que no se evaluará automáticamente.


 -- Variable opcional: noundisp
     Valor por defecto: `false'

     Si `noundisp' vale `true', los nombres se muestran precedidos de
     un apóstrofo. Siempre debe valer `true' cuando se quiera
     representar la definición de funciones.


 -- Símbolo especial: nouns
     El símbolo `nouns' es una `evflag', lo que significa que cuando se
     utilice como una opción de la instrucción `ev', todas las formas
     nominales que aparezcan en una expresión las convierte en
     verbales, esto es, las evalúa.  Véanse también `noun', `nounify',
     `verb' y `verbify'.


 -- Símbolo especial: numer
     El símbolo `numer' hace que algunas funciones matemáticas,
     incluida la exponenciación, con argumentos numéricos se evalúen
     como decimales de punto flotante. También reemplaza las variables
     que haya en `expr', y a las cuales se les ha asignado previamente
     un valor, por estos mismo valores. Además, activa la variable
     `float'.


 -- Función: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declara las variables `x_1', ..., <x_n> asignándoles los valores
     numéricos `expr_1', ..., `expr_n'.  El valor numérico se evalúa y
     sustituye a la variable en cualquier expresión en la que ésta
     aparezca si `numer' toma el valor `true'. Véase también `ev'.

     Las expresiones `expr_1', ..., `expr_n' pueden ser expresiones no
     necesariamente numéricas.

 -- Variable del sistema: opproperties
     La variable `opproperties' es la lista con las propiedades
     especiales de los operadores reconocidas por el simplificador de
     Maxima: `linear', `additive', `multiplicative', `outative',
     `evenfun', `oddfun', `commutative', `symmetric', `antisymmetric',
     `nary', `lassociative', `rassociative'.


 -- Variable opcional: opsubst
     Valor por defecto: `true'

     Si `opsubst' vale `false', `subst' no sustituye el operdor de una
     expresión, de manera que `(opsubst: false, subst (x^2, r,
     r+r[0]))' trabajará correctamente.


 -- Declaración: outative
     La instrucción `declare (f, outative)' le indica al simplificador
     de Maxima que los factores constantes del argumento de la función
     `f' pueden ser extraídos.

       1. Si `f' es univariante, cada vez que el simplificador se
          encuentra con `f' aplicada a un producto, éste será
          particionado en factores que son constantes y factores que no
          lo son, siendo entonces los constantes extraídos de la
          función.  Por ejemplo, `f(a*x)' se reducirá a `a*f(x)' siendo
          `a' una constante. Las constantes no atómicas no serán
          extraídas.

       2. Si `f' es una función de 2 o más argumentos, esta propiedad
          se define como en  `sum' o `integrate', esto es, `f (a*g(x),
          x)' se reducirá a `a * f(g(x), x)' si `a' no contiene a `x'.

     Las funciones `sum', `integrate' y `limit' han sido todas
     declaradas con la propiedad `outative'.


 -- Declaración: posfun
     La instrucción `declare (f, posfun)' declara a `f' como función
     positiva, de forma que `is (f(x) > 0)' devolverá `true'.


 -- Función: radcan (<expr>)
     Simplifica la expresión <expr>, que puede contener logaritmos,
     exponenciales y radicales, convirtiéndola a una forma canónica, lo
     que significa que todas las expresiones funcionalmente equivalentes
     se reducen a una forma única.  Ciertas expresiones, sin embargo,
     son reducidas por `radcan' a una forma regular, lo que significa
     que dos expresiones equivalentes no tienen necesariamente el mismo
     aspecto, pero su diferencia puede ser reducida por `radcan' a cero.

     Con algunas expresiones `radcan' puede consunir mucho tiempo. Este
     es el coste por explorar ciertas relaciones entre las componentes
     de la expresión para simplificaciones basadas en factorizaciones y
     expansiones parciales de fracciones de exponentes.

     Si `%e_to_numlog' vale `true', `%e^(r*log(expr))' se reduce a
     `expr^r' si `r'  es un número racional.

     Si `radexpand' vale `false', ciertas transformaciones se inhiben;
     `radcan (sqrt (1-x))' se mantiene como `sqrt (1-x)' y no se reduce
     a `%i sqrt (x-1)', o `radcan (sqrt (x^2 - 2*x + 11))' se mantiene
     como  `sqrt (x^2 - 2*x + 1)' sin reducirse a`x - 1'.

     La instrucción `example (radcan)' muestra algunos ejemplos.


 -- Variable opcional: radexpand
     Valor por defecto: `true'

     La variable `radexpand' controla algunas simplificaciones de
     radicales.

     Si `radexpand' vale `all', las raíces <n>-ésimas de los factores
     de un producto que sean potencias de <n> se extraen del símbolo
     radical. Por ejemplo, si `radexpand' vale `all', `sqrt (16*x^2)'
     se reduce a `4*x'.

     Más concretamente, considérese `sqrt (x^2)'.
        * Si `radexpand' vale `all' o se ha ejecutado `assume (x > 0)',
          `sqrt(x^2)' se reduce a `x'.

        * Si `radexpand' vale `true' y `domain' es `real' (su valor por
          defecto), `sqrt(x^2)' se reduce a `abs(x)'.

        * Si `radexpand' vale `false' o `radexpand' vale `true' y
          `domain' es `complex', `sqrt(x^2)' no se simplifica.

     Nótese que  `domain' sólo se tiene en cuenta si `radexpand' vale
     `true'.


 -- Variable opcional: radsubstflag
     Valor por defecto: `false'

     Si `radsubstflag' vale `true' se permite a `ratsubst' hacer la
     sustitución `u' por `sqrt (x)' in `x'.


 -- Declaración: rassociative
     La instrucción `declare (g, rassociative)' le indica al
     simplificador de Maxima que `g' es asociativa por la derecha.  Por
     ejemplo, `g(g(a, b), g(c, d))' se reduce a `g(a, g(b, g(c, d)))'.


 -- Función: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Es el "Sequential Comparative Simplification" (método debido a
     Stoute).  La función `scsimp' intenta simplificar <expr> de
     acuerdo con las reglas <rule_1>, ..., <rule_n>.  Si se obtiene una
     expresión más pequeña, el proceso se repite. En caso contrario,
     después de que se hayan intentado todas las simplificaciones,
     devuelve la respuesta original.

     La instrucción `example (scsimp)' muestra algunos ejemplos.


 -- Variable opcional: simpsum
     Valor por defecto: `false'

     Si `simpsum' vale `true', se simplifica el resultado de un
     sumatorio `sum'. Esta simplificación podrá producir en ocasiones
     una expresión compacta.  Si `simpsum' vale `false' o si se utiliza
     la forma apostrofada `'sum', el valor es una forma nominal que
     representa la notación sigma habitual en matemáticas.


 -- Función: sumcontract (<expr>)
     Combina todos los sumatorios de una suma cuyos límites inferiores
     y superiores difieren por constantes. El resultado es una
     expresión que contiene un sumatorio para conjunto de tales
     sumatorios. La función `sumcontract' combina todos los sumatorios
     compatibles y utiliza uno de los índices de uno de los sumatorios
     si puede, si no formará un índice que sea razonable.

     Puede ser necesario hacer `intosum (<expr>)' antes que
     `sumcontract'.


 -- Variable opcional: sumexpand
     Valor por defecto: `false'

     Si `sumexpand' vale `true', productos de sumatorios y de
     sumatorios con exponentes se reducen a sumatorios anidados.

     Véase también `cauchysum'.

     Ejemplos:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


 -- Variable opcional: sumsplitfact
     Valor por defecto: `true'

     Si `sumsplitfact' vale `false', `minfactorial' se aplica después
     de  `factcomb'.


 -- Declaración: symmetric
     La instrucción `declare (h, symmetric)' le indica al simplificador
     de  Maxima que `h' es una función simétrica.  Por ejemplo, `h (x,
     z, y)'  se reduce a `h (x, y, z)'.

     El nombre `commutative' es sinónimo de `symmetric'.


 -- Función: unknown (<expr>)
     Devuelve `true' si y sólo si <expr> contiene un operador o función
     no reconocido por el simplificador de Maxima.



File: maxima.info,  Node: Gráficos,  Next: Entrada y Salida,  Prev: Simplificación,  Up: Top

8 Gráficos
**********

* Menu:

* Definiciones para Gráficos::


File: maxima.info,  Node: Definiciones para Gráficos,  Prev: Gráficos,  Up: Gráficos

8.1 Definiciones para Gráficos
==============================

 -- Variable opcional: in_netmath
     Valor por defecto: `false'

     Si `in_netmath' vale `true', `plot3d' imprime salida de OpenMath
     en la consola si `plot_format' vale `openmath', en caso contrario,
     `in_netmath' (incluso si vale `true') deja de tener efecto alguno.

     La variable `in_netmath' no afecta a `plot2d'.


 -- Función: openplot_curves (<list>, <rest_options>)
     Toma una lista de curvas como
          [[x1, y1, x2, y2, ...], [u1, v1, u2, v2, ...], ..]
     o
          [[[x1, y1], [x2, y2], ...], ...]
     y las dibuja. Es similar a xgraph_curves, pero utiliza las rutinas
     de "open plot".  Se le puede dar argumentos adicionales como
     `"{xrange -3 4}"' El siguiente ejemplo dibuja dos curvas con
     puntos grandes, etiquetando el primero con `jim' y el segundo con
     `jane'.
          openplot_curves ([["{plotpoints 1} {pointsize 6} {label jim}
                {xaxislabel {joe is nice}}"], [1, 2, 3, 4, 5, 6, 7, 8],
                ["{label jane} {color pink }"], [3, 1, 4, 2, 5, 7]]);

     Otros símbolos de elementos importantes son  `xfun', `color',
     `plotpoints', `linecolors', `pointsize', `nolines', `bargraph',
     `labelposition', `xaxislabel' y `yaxislabel'.


 -- Función: plot2d (<expr>, <range>, ..., <options>, ...)
 -- Función: plot2d (<parametric_expr>)
 -- Función: plot2d (<discrete_expr>)
 -- Función: plot2d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>)
 -- Función: plot2d ([<expr_1>, ..., <expr_n>], <x_range>)
 -- Función: plot2d (<expr>, <x_range>, <y_range>)
 -- Función: plot2d (<expr>, <x_range>)
 -- Función: plot2d ([<name_1>, ..., <name_n>], <x_range>, <y_range>)
 -- Función: plot2d ([<name_1>, ..., <name_n>], <x_range>)
 -- Función: plot2d (<name>, <x_range>, <y_range>)
 -- Función: plot2d (<name>, <x_range>)
     Muestra un gráfico de una o más expresiones como función de una
     variable.

     En todos los casos, <expr> es una expresión a ser representada en
     el eje vertical como función de una variable.  El argumento
     <x_range>, que es el rango del eje horizontal, es una lista de la
     forma `[<variable>, <min>, <max>]', donde <variable> es una
     variable que aparece en <expr>. También <y_range>, el rango del
     eje vertical, es otra lista de la forma `[y, <min>, <max>]'.

     La llamada `plot2d (<expr>, <x_range>)' dibuja plots <expr> como
     función de la variable nombrada en  <x_range>, en el rango
     especificado por <x_range>.  Si el rango vertical no se especifica
     explícitamente por medio de `set_plot_option', se escogerá
     automáticamente.  Todas las opciones toman sus valores por defecto
     a menos que se especifiquen de otra manera con `set_plot_option'.

     La llamada `plot2d (<expr>, <x_range>, <y_range>)' dibuja <expr>
     como función de la variable nombrada en  <x_range>, en el rango
     especificado por  <x_range>.  El rango vertical se ajusta a
     <y_range>.  Todas las opciones toman sus valores por defecto a
     menos que se especifiquen de otra manera con `set_plot_option'.

     La llamada `plot2d ([<expr_1>, ..., <expr_n>], <x_range>)' dibuja
     <expr_1>, ..., <expr_n> como función de la variable nombrada en
     <x_range>, en el rango especificado por <x_range>.  Si el rango
     vertical no se especifica explícitamente por medio de
     `set_plot_option', se escogerá automáticamente.  Todas las
     opciones toman sus valores por defecto a menos que se especifiquen
     de otra manera con `set_plot_option'.

     La llamada `plot2d ([<expr_1>, ..., <expr_n>], <x_range>,
     <y_range>)' dibuja <expr_1>, ..., <expr_n> como función de la
     variable nombrada en <x_range>, en el rango especificado por
     <x_range>.  El rango vertical se ajusta a <y_range>.  Todas las
     opciones toman sus valores por defecto a menos que se especifiquen
     de otra manera con `set_plot_option'.

     Cuando la función a representar ha sido definida en Maxima
     mediante  `:=' o `define', o en Lisp por DEFUN o DEFMFUN, entonces
     se podrá especificar por su nombre. Las funciones definidas a
     nivel de LISP por DEFMSPEC, las funciones de simplificación, junto
     con muchas otras funciones, no pueden especificarse directamente
     por su nombre.

     Ejemplos:

     Gráfico de una expresión y especificación de algunos parámetros de
     uso común.

          (%i1) plot2d (sin(x), [x, -5, 5])$
          (%i2) plot2d (sec(x), [x, -2, 2], [y, -20, 20], [nticks, 200])$

     Representando funciones por nombre.

          (%i1) F(x) := x^2 $

          (%i2) :lisp (defun |$g| (x) (m* x x x))

          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $

          (%i3) plot2d (F, [u, -1, 1])$

          (%i4) plot2d ([F, G, H], [u, -1, 1])$

     Allá donde vaya una expresión ordinaria, también puede ir una
     expresión paramétrica en su lugar: <parametric_expr> es una lista
     de la forma `[parametric, <x_expr>, <y_expr>, <t_range>,
     <options>]'.  Aquí <x_expr> y <y_expr> son expresiones de una
     variable  <var> que a su vez es el primer elemento del rango
     <trange>.  El dibujo que se obtiene es el lugar geométrico de los
     pares `[<x_expr>, <y_expr>]' cuando <var> varía según <trange>.

     En el siguiente ejemplo se dibuja un círculo, luego se repite lo
     mismo con pocos puntos, con lo que se obtiene una estrella, para
     finalmente dibujar todo junto con una función ordinaria en `x'.

     Ejemplos:

        * Un círculo como curva paramétrica.
               (%i1) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                       [nticks, 80]])$

        * Una estrella: la curva anterior con sólo ocho puntos.
               (%i2) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                       [nticks, 8]])$

        * Un polinomio cúbico como curva ordinaria y un círculo como
          curva paramétrica.
               (%i3) plot2d ([x^3 + 2, [parametric, cos(t), sin(t), [t, -5, 5],
                       [nticks, 80]]], [x, -3, 3])$

     También se pueden utilizar expresiones discretas en lugar de
     ordinarias o paramétricas: <discrete_expr> es una lista de la forma
     `[discrete, <x_list>, <y_list>]' o `[discrete, <xy_list>]', siendo
     <xy_list> una lista de pares `[<x>,<y>]'.

     Ejemplos:

        * Se crean algunas listas.
               (%i1) xx:makelist(x,x,0,10)$
               (%i2) yy:makelist(exp(-x*1.0),x,0,10)$
               (%i3) xy:makelist([x,x*x],x,0,5)$

        * Dibujo con segmentos lineales.
               (%i4) plot2d([discrete,xx,yy])$

        * Dibujo con segmentos lineales, utilizando una lista de pares.
               (%i5) plot2d([discrete,xy])$

        * Dibujo con puntos.
               (%i6) plot2d([discrete,xx,yy],[gnuplot_curve_styles,["with points"]])$

        * Dibujo de la curva `cos(<x>)' con segmentos y (<xx>,<yy>) con
          puntos.
               plot2d([cos(x),[discrete,xx,yy]],[x,0,10],[gnuplot_curve_styles,["with lines","with points pointsize 3"]])$

     Véase también `plot_options', que describe las opciones gráficas y
     tiene más ejemplos.


 -- Función: xgraph_curves (<list>)
     Dibuja el conjunto de puntos de la lista del argumento <list> con
     el programa xgraph.

     El conjunto de puntos puede ser de la forma

          [x0, y0, x1, y1, x2, y2, ...]
     o
          [[x0, y0], [x1, y1], ...]

     Un conjunto de puntos también puede contener símbolos con
     etiquetas u otra información.

          xgraph_curves ([pt_set1, pt_set2, pt_set3]);

     dibuja los tres conjuntos de puntos como tres curvas.

          pt_set: append (["NoLines: True", "LargePixels: true"], [x0, y0, x1, y1, ...]);

     construye el conjunto de puntos, declara que no haya segmentos
     rectilíneos entre ellos y que se utilicen píxeles grandes. Véase
     el manual de xgraph para más opciones.

          pt_set: append ([concat ("\"", "x^2+y")], [x0, y0, x1, y1, ...]);

     construye una etiqueta con el contenido "x^2+y" para este conjunto
     particular de puntos. Las comillas dobles `"' al comienzo son las
     que le indican a xgraph que se trata de una etiqueta.

          pt_set: append ([concat ("TitleText: Datos muestrales")], [x0, ...])$

     establece el título principal del gráfico como "Datos muestrales"
     en lugar de "Maxima Plot".

     Para hacer un gráfico de barras con columnas de 0.2 unidades de
     ancho y para dibujar dos diagramas diferentes de este tipo:
          xgraph_curves ([append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
              create_list ([i - .2, i^2], i, 1, 3)),
              append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
              create_list ([i + .2, .7*i^2], i, 1, 3))]);
     Se utiliza un fichero temporal `xgraph-out'.


 -- Variable del sistema: plot_options
     Los elementos de esta lista establecen las opciones por defecto
     para los gráficos.  Si una opción está presente en una llamada a
     `plot2d' o a `plot3d', este valor adquiere prevalencia sobre las
     opciones por defecto.  En otro caso se utilizará el valor que
     tenga en `plot_options'.  Las opciones por defecto se asignan
     mediante la función `set_plot_option'.

     Cada elemento de `plot_options' es una lista de dos o más
     elementos, el primero de los cuales es el nombre de la opción,
     siendo los siguientes los valores de aquélla. En algunos casos el
     valor asignado es a su vez una lista, que puede contener varios
     elementos.

     Las opciones gráficas que reconocen `plot2d' y `plot3d' son:

        * Opción: `plot_format' determina qué módulo gráfico van a
          utilizar `plot2d' y `plot3d'.

             * Valor por defecto: `gnuplot' Gnuplot es el programa por
               defecto y el más avanzado. Requiere de una instalación
               externa de gnuplot.

             * Valor: `mgnuplot' Mgnuplot es una interface para gnuplot
               basada en Tk. Se incluye en la distribución de Maxima.
               Mgnuplot ofrece una interface gráfica de usuario
               rudimentaria para gnuplot, pero tiene algunas mejoras
               respecto de la interface propia de gnuplot. Mgnuplot
               requiere de una instalación externa de gnuplot y de
               Tcl/Tk.

             * Valor: `openmath' Openmath es un programa gráfico
               escrito en Tcl/Tk. Se incluye en la distribución de
               Maxima.

             * Valor: `ps' Genera ficheros PostScript directamente
               desde Maxima. Se tendrán resultados PostScript mejores
               utilizando gnuplot, dejando la opción `plot_format' sin
               especificar (aceptando la que tiene por defecto), y
               dándole a `gnuplot_term' el valor `ps'.

        * Opción: `run_viewer' controla si el visor apropiado para la
          salida gráfica debe ejecutarse o no.

             * Valor por defecto: `true', ejecuta el visor.

             * Valor: `false', no ejecuta el visor.

        * `gnuplot_term' establece el terminal de gnuplot.
             * Valor por defecto: `default' La salidad de gnuplot se
               muestra en una ventana gráfica.

             * Valor: `dumb' GLa salidad de gnuplot se muestra en la
               consola de Maxima con caracteres ASCII.

             * Valor: `ps' Gnuplot genera comandos en lenguaje
               PostScript. Si la opción `gnuplot_out_file' vale
               <filename>, gnuplot escribe los comandos PostScript en
               <filename>.  En otro caso, los comandos se imprimen en
               la consola de Maxima.

        * Opción: `gnuplot_out_file' escribe la salida de gnuplot en un
          fichero.

             * Valor por defecto: `false' No se especifica ningún
               archivo de salida.

             * Valor: <filename> Ejemplo: `[gnuplot_out_file,
               "myplot.ps"]' Este ejemplo envía código PostScript al
               fichero `myplot.ps' cuando se utiliza conjuntamente con
               el terminal PostScript de gnuplot.

        * Opción: `x' Rango horizontal por defecto.
               [x, - 3, 3]
          Establece el rango horizontal como [-3, 3].

        * Opción: `y' Rango vertical por defecto.
               [y, - 3, 3]
          Establece el rango vertical como [-3, 3].

        * Opción: `t' El rango por defecto para el parámetro de las
          representaciones paramétricas.
               [t, 0, 10]
          Establece el rango de la variable paramétrica como [0, 10].

        * Opción: `nticks' Número inicial de puntos a utilizar por el
          algoritmo adaptativo de representación gráfica.
               [nticks, 20]
          El valor por defecto para `nticks' es 10.

        * Opción: `adapt_depth' Número máximo de particiones utilizado
          por el algoritmo adaptativo de representación gráfica.
               [adapt_depth, 5]
          El valor por defecto para `adapt_depth' es 10.

        * Opción: `grid' Establece el número de puntos de la retícula a
          utilizar en las direcciones x e y en los gráficos de tres
          dimensiones.
               [grid, 50, 50]
          establece la retícula en 50 por 50 puntos. El valor por
          defecto es 30 por 30.

        * Opción: `transform_xy' Permite que se realicen
          transformaciones en los gráficos de tres dimensiones.
               [transform_xy, false]
          El valor por defecto de `transform_xy' es `false'. Cuando
          vale `false', da el resultado de
               make_transform ([x, y, z], f1(x, y, z), f2(x, y, z), f3(x, y, z))$
          La transformación `polar_xy' está definida en Maxima.
          Devuelve la misma transformación que
               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

        * Opción: `colour_z' es específico del formato gráfico `ps'.
               [colour_z, true]
          El valor por defecto de `colour_z' es `false'.

        * Opción: `view_direction' Específico del formato gráfico `ps'.
               [view_direction, 1, 1, 1]
          El valor por defecto de `view_direction' es [1, 1, 1].

     Hay varias opciones gráficas que son específicas de gnuplot.
     Todas ellas (excepto `gnuplot_pm3d') son comandos propios de
     gnuplot que se especifican como cadenas alfanuméricas. Consúltese
     la documentación de gnuplot para más detalles.

        * Opción: `gnuplot_pm3d' Controla la utilización del modo PM3D,
          que tiene capacidades avanzadas para gráficos
          tridimensionales. PM3D sólo está disponible en versiones de
          gnuplot posteriores a la 3.7. El valor por defecto de
          `gnuplot_pm3d' es `false'.

          Ejemplo:

               [gnuplot_pm3d, true]

        * Opción: `gnuplot_preamble' Introduce instrucciones de gnuplot
          antes de que se haga el dibujo. Puede utilizarse cualquier
          comando válido de gnuplot. Si interesa introducir varios
          comandos se separarán con punto y coma. El ejemplo que se
          muestra produce un gráfico en escala logarítmica. El valor
          por defecto de `gnuplot_preamble' es la cadena vacía `""'.

          Ejemplo:

               [gnuplot_preamble, "set log y"]

        * Opción: `gnuplot_curve_titles'

          Controla los títulos dados a la clave del gráfico. El valor
          por defecto es  `[default]', el cual establece
          automáticamente los títulos para cada curva representada. Si
          no es `[default]', `gnuplot_curve_titles' debe contener una
          lista de cadenas, cada una de las cuales es `"title
          '<title_string>'"'. (Para desactivar la clave del gráfico,
          añádase `"set nokey"' a `gnuplot_preamble'.)

          Ejemplo:

               [gnuplot_curve_titles, ["title 'My first function'", "title 'My second function'"]]

        * Opción: `gnuplot_curve_styles' Es una lista de cadenas que
          controlan el aspecto de las curvas, como el color, el ancho,
          la discontinuidad, etc., y que deben enviarse al comando
          `plot' de gnuplot. El valor por defecto es `["with lines 3",
          "with lines 1", "with lines 2", "with lines 5", "with lines
          4", "with lines 6", "with lines 7"]', que realiza un ciclo
          sobre un conjunto de colores diferentes. Consúltese la
          documentación de gnuplot sobre `plot' para más información.

          Ejemplo:

               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Opción: `gnuplot_default_term_command' Comando de gnuplot
          para establecer el tipo de terminal para el terminal por
          defecto. El valor por defecto es la cadena vacía `""', esto
          es, utiliza el valor por defecto de gnuplot.

          Ejemplo:

               [gnuplot_default_term_command, "set term x11"]

        * Opción: `gnuplot_dumb_term_command' Comando de gnuplot para
          establecer el tipo de terminal para el terminal oculto. El
          valor por defecto es `"set term dumb 79 22"', que da una
          salida de texto de 79 por 22 caracteres.

          Ejemplo:

               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Opción: `gnuplot_ps_term_command' Comando de gnuplot para
          establecer el tipo de terminal para el terminal PostScript.
          El valor por defecto es `"set size 1.5, 1.5;set term
          postscript eps enhanced color solid 24"', que establece un
          tamaño de 1.5 veces el valor por defecto de gnuplot, junto
          con un tamaño de fuente de 24, entre otras cosas. Consúltese
          la documentación de gnuplot para más información sobre `set
          term postscript'.

          Ejemplo:

               [gnuplot_ps_term_command, "set term postscript eps enhanced color solid 18"]


     Ejemplos:

        * Almacena un gráfico de `sin(x)' en el fichero `sin.eps'.

          plot2d (sin(x), [x, 0, 2*%pi], [gnuplot_term, ps], [gnuplot_out_file, "sin.eps"])$

        * Utiliza la opción y para saltarse las singularidades, así
          como la opción `gnuplot_preamble' para colocar la clave en la
          parte inferior del dibujo.

          plot2d ([gamma(x), 1/gamma(x)], [x, -4.5, 5], [y, -10, 10], [gnuplot_preamble, "set key bottom"])$

        * Utiliza un `gnuplot_preamble' bastante complicado a fin de
          producir etiquetas en el eje x.  (Nótese que la cadena de
          `gnuplot_preamble' debe introducirse sin saltos de línea.)

          my_preamble: "set xzeroaxis; set xtics ('-2pi' -6.283, '-3pi/2' -4.712, '-pi' -3.1415, '-pi/2' -1.5708, '0' 0,'pi/2' 1.5708, 'pi' 3.1415,'3pi/2' 4.712, '2pi' 6.283)"$
          plot2d ([cos(x), sin(x), tan(x), cot(x)], [x, -2*%pi, 2*%pi],
              [y, -2, 2], [gnuplot_preamble, my_preamble]);

        * Utiliza un `gnuplot_preamble' bastante complicado a fin de
          producir etiquetas en el eje x, produciendo una salida
          PostScript que aprovecha el formateo avanzado de texto
          disponible en gnuplot.  (Nótese que la cadena de
          `gnuplot_preamble' debe introducirse sin saltos de línea.)

          my_preamble: "set xzeroaxis; set xtics ('-2{/Symbol p}' -6.283, '-3{/Symbol p}/2' -4.712, '-{/Symbol p}' -3.1415, '-{/Symbol p}/2' -1.5708, '0' 0,'{/Symbol p}/2' 1.5708, '{/Symbol p}' 3.1415,'3{/Symbol p}/2' 4.712, '2{/Symbol p}' 6.283)"$
          plot2d ([cos(x), sin(x), tan(x)], [x, -2*%pi, 2*%pi], [y, -2, 2],
              [gnuplot_preamble, my_preamble], [gnuplot_term, ps], [gnuplot_out_file, "trig.eps"]);

        * Un gráfico tridimensional utilizando el terminal pm3d de
          gnuplot.

          plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4], [grid, 50, 50], [gnuplot_pm3d, true])$

        * Un gráfico tridimensional sin malla y con contornos
          proyectados sobre el plano inferior.

          my_preamble: "set pm3d at s;unset surface;set contour;set cntrparam levels 20;unset key"$
          plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4], [grid, 50, 50],
              [gnuplot_pm3d, true], [gnuplot_preamble, my_preamble])$

        * Un gráfico en el que el eje z sólo se representa por el color.
          (Nótese que la cadena de `gnuplot_preamble' debe introducirse
          sin saltos de línea.)

          plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [gnuplot_preamble, "set view map; unset surface"], [gnuplot_pm3d, true], [grid, 150, 150])$


 -- Función: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Función: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>,
          <y_range>, ..., <options>, ...)
 -- Function: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_rge>, <y_rge>)
 -- Function: plot3d ([<name_1>, <name_2>, <name_3>], <x_range>,
          <y_range>, ..., <options>, ...)
     Representa gráficamente una o tres expresiones como funciones de
     dos variables.

          plot3d (2^(-u^2 + v^2), [u, -5, 5], [v, -7, 7]);
     dibuja `z = 2^(-u^2+v^2)' con `u' y `v' variando en [-5,5] y
     [-7,7] respectivamente, y con  <u> sobre el eje x, y con `v' sobre
     el eje y.

     Un ejemplo del tercer patrón de argumentos es

          plot3d ([cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)), y*sin(x/2)],
             [x, -%pi, %pi], [y, -1, 1], ['grid, 50, 15]);

     que dibuja una banda de Moebius, parametrizada por las tres
     expresiones dadas como primer argumento a `plot3d'. Un argumento
     opcional `['grid, 50, 15]' da el número de intervalos en las
     direcciones x e y, respectivamente.

     Cuando la función a representar ha sido definida en Maxima
     mediante  `:=' o `define', o en Lisp por DEFUN o DEFMFUN, entonces
     se podrá especificar por su nombre. Las funciones definidas a
     nivel de LISP por DEFMSPEC, las funciones de simplificación, junto
     con muchas otras funciones, no pueden especificarse directamente
     por su nombre.

     Este ejemplo muestra un gráfico de la parte real de `z^1/3'.

           plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
               ['grid, 12, 80], ['plot_format, ps],
               ['transform_xy, polar_to_xy], ['view_direction, 1, 1, 1.4],
               ['colour_z, true]);

     Aquí la opción `view_direction' indica la dirección desde la que
     se hace la proyección. Se hace esto desde una posición infinita
     pero paralela a la línea que va desde  `view_direction' hasta el
     origen.  Esto sólo se utiliza cuando `plot_format' está en `ps',
     puesto que los otros visores permiten la rotación interactiva del
     objeto.

     Otro ejemplo es la botella de Klein:

          expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0) - 10.0;
          expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0);
          expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y));

          plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi], [y, -%pi, %pi], ['grid, 40, 40]);

     o un toro

          expr_1: cos(y)*(10.0+6*cos(x));
          expr_2: sin(y)*(10.0+6*cos(x));
          expr_3: -6*sin(x);

          plot3d ([expr_1, expr_2, expr_3], [x, 0, 2*%pi], [y, 0, 2*%pi], ['grid, 40, 40]);

     También se puede hacer con gnuplot:

          plot3d (2^(x^2 - y^2), [x, -1, 1], [y, -2, 2], [plot_format, gnuplot]);

     En ocasiones puede ser necesario definir una función para
     representarla. Todos los argumentos de `plot3d' se evalúan, de
     manera que puede ser difícil escribir una expresión que haga lo
     que el usuario realmente quiere; en tales casos facilita las cosas
     definir previamente la función.

          M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4], [1, 2, 3, 3])$
          f(x, y) := float (M [?round(x), ?round(y)])$
          plot3d (f, [x, 1, 4], [y, 1, 4], ['grid, 4, 4])$

     Véase  `plot_options' para más ejemplos.


 -- Función: make_transform (<vars>, <fx>, <fy>, <fz>)
     Devuelve una función apropiada para la función de transformación
     de `plot3d'. Debe usarse con la opción gráfica `transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     es una transformación para pasar a coordenadas polares.

 -- Función: plot2d_ps (<expr>, <range>)
     Escribe en el <pstream> una secuencia de comandos PostScript que
     dibujan <expr> sobre <range>.

     El argumento <expr> es una expresión y <range> es una lista de la
     forma `[<x>, <min>, <max>]' en la cual <x> es una variable que
     aparece en <expr>.

     Véase también `closeps'.


 -- Función: closeps ()
     Esta función debería invocarse al final de una secuencia de
     comandos gráficos.  Cierra el <pstream> y le asigna `nil'. También
     puede ser invocado antes de empezar un dibujo, para asegurar que
     se cierre el <pstream> si estaba abierto.  Todas las instrucciones
     que se envían al <pstream> lo abren si es necesario. La función
     `closeps' es independiente de otras instrucciones gráficas, ya que
     si se quiere dibujar dos rangos o sobreponer varios gráficos,
     <pstream> debe permanecer abierto.

 -- Función: set_plot_option (<option>)
     Asigna un valor a una de las variables globales que controlan los
     gráficos. El argumento <option> se especifica como una lista de
     dos o más elementos, en la que el primero es el nombre de una de
     las opciones de la lista `plot_options'.

     La función `set_plot_option' evalúa sus argumentos y devuelve
     `plot_options' tal como queda después de la actualización.

     Véanse también `plot_options', `plot2d' y `plot3d'.

     Ejemplos:

     Se modifican los valores de `grid' y `x'.  Si a un nombre de
     opción de `plot_options' tiene ya un valor asignado, hacerlo
     preceder de un apóstrofo para evitar su evaluación.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [view_direction, 1, 1, 1], [colour_z, false],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [view_direction, 1, 1, 1], [colour_z, false],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]


 -- Función: psdraw_curve (<ptlist>)
     Dibuja una curva uniendo los puntos de <ptlist>, que puede ser de
     la forma `[x0, y0, x1, y1, ...]' o `[[x0, y0], [x1, y1], ...]'

     La función `join' se puede utilizar para tomar una lista con las x
     y otra con las y para luego formar pares.

     La función <psdraw_curve> tan sólo llama a la función <pscurve>.
     Esta es su definición:

          (defun $psdraw_curve (lis)
            (p "newpath")
            ($pscurve lis)
            (p "stroke"))


 -- Función: pscom (<cmd>)
     El argumento <cmd> se añade al fichero PostScript.  Ejemplo:
          pscom ("4.5 72 mul 5.5 72 mul translate 14 14 scale");



File: maxima.info,  Node: Entrada y Salida,  Next: Aritmética de punto flotante,  Prev: Gráficos,  Up: Top

9 Entrada y Salida
******************

* Menu:

* Introducción a  Entrada y Salida::
* Archivos::
* Definiciones para Entrada y Salida::


File: maxima.info,  Node: Introducción a Entrada y Salida,  Next: Archivos,  Prev: Entrada y Salida,  Up: Entrada y Salida

9.1 Introducción a Entrada y Salida
===================================


File: maxima.info,  Node: Archivos,  Next: Definiciones para Entrada y Salida,  Prev: Introducción a Entrada y Salida,  Up: Entrada y Salida

9.2 Archivos
============

Un archivo no es más que una área de un cierto dispositivo de
almacenamiento que contiene datos o texto.  Los archivos se agrupan en
los discos en "directorios", que son listas de archivos.  Instrucciones
que operan con archivos son: `save', `load', `loadfile', `stringout',
`batch', `demo', `writefile', `closefile' y `appendfile'.


File: maxima.info,  Node: Definiciones para Entrada y Salida,  Prev: Archivos,  Up: Entrada y Salida

9.3 Definiciones para Entrada y Salida
======================================

 -- Variable del sistema: __
     `__' es la expresión de entrada que está siendo actualmente
     evaluada.  Esto es, mientras se está evaluando una expresión de
     entrada, `__' es igual a <expr>.

     A `__' se le asigna la expresión de entrada antes de que ésta sea
     simplificada o evaluada. Sin embargo, el valor de `__' es
     simplificado, pero no evaluado, cuando su valor es mostrado en el
     terminal.

     La variable `__' es reconocida por  `batch', pero no por `load'.

     Véanse también `_' y `%'.

     Ejemplos:

          (%i1) print ("I was called as", __);
          I was called as print(I was called as, __)
          (%o1)              print(I was called as, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Current input expression =", __), 0);
          (%o3) g(x) := (print("Current input expression =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                      cc + bb + aa
          Current input expression = --------------
                                     g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd


 -- Variable del sistema: _
     El símbolo `_' representa la última expresión de entrada (esto es,
     `%i1', `%i2', `%i3', ...).

     Al símbolo `_' se le asigna la expresión de entrada antes de que
     ésta sea simplificada o evaluada. Sin embargo, el valor de `_' se
     simplifica (pero no se evalúa) cuando se muestra en el terminal.

     El símbolo `_' es reconocido por `batch', pero no por `load'.

     Véanse también `__' y `%'.

     Ejemplos:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42


 -- Variable del sistema: %
     El símbolo `%' representa la expresión de salida (esto es, `%o1',
     `%o2', `%o3', ...)  más reciente calculada por Maxima,
     independientemente de que la haya mostrado o no.

     El símbolo `%' es reconocido por `batch', pero no por `load'.

     Véanse también `_', `%%' y `%th'.


 -- Variable del sistema: %%
     En una sentencia compuesta, como `block', `lambda' o `(<s_1>, ...,
     <s_n>)', `%%' es el valor de la sentencia previa.  Por ejemplo,

          block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
          block ([prev], prev: integrate (x^5, x), ev (prev, x=2) - ev (prev, x=1));

     devuelven el mismo resultado  `21/2'.

     Una sentencia compuesta puede contener otras sentencias compuestas.
     Independientemente de que una sentencia sea simple o compuesta,
     `%%' es el valor de la sentencia previa.  Por ejemplo,

          block (block (a^n, %%*42), %%/6)

     devuelve `7*a^n'.

     Dentro de una sentencia compuesta, el valor de `%%' puede
     inspeccionarse en un punto de interrupción que se abra ejecutando
     la función `break'. Por ejemplo, en el punto de interrupción
     abierto por

          block (a: 42, break ())$

     introduciendo `%%;' se obtiene `42'.

     En la primera sentencia de una sentencia compuesta, o fuera de una
     sentencia compuesta, `%%' no está definido.

     El símbolo `%%' es reconocido tanto por `batch' como por `load'.

     Véase también `%'.


 -- Variable opcional: %edispflag
     Valor por defecto: `false'

     Si `%edispflag' vale `true', Maxima muestra `%e' elevado a un
     exponente negativo como un cociente.  Por ejemplo, `%e^-x' se
     muestra como `1/%e^x'.


 -- Función: %th (<i>)
     Es el valor de la expresión de salida previa <i>-ésima.  Esto es,
     si la siguiente expresión a calcular es la salida <n>-ésima, `%th
     (<m>)' es la salida  (<n> - <m>)-ésima.

     La función `%th' es útil en archivos tipo `batch' o para hacer
     referencia a un grupo de expresiones de salida.  Por ejemplo,

          block (s: 0, for i:1 thru 10 do s: s + %th (i))$

     asigna a `s' la suma de las diez últimas expresiones de salida.

     La función `%th' es reconocida por `batch', pero no por `load'.

     Véase también `%'.


 -- Special symbol: "?"
     Como prefijo de una función o nombre de variable, `?' significa
     que el nombre es de Lisp, no de Maxima.  Por ejemplo, `?round'
     representa la función de Lisp `ROUND'.  Véase `Lisp y Maxima' para
     más información.

     La notación `? word' (un símbolo de interrogación seguido de una
     palabra y separados por un espacio) equivale a `describe ("word")'.


 -- Variable opcional: absboxchar
     Valor por defecto: `!'

     La variable `absboxchar' es el carácter utilizado para representar
     el valor absoluto de una expresión que ocupa más de una línea de
     altura.


 -- Variable opcional: file_output_append
     Valor por defecto: `false'

     La variable `file_output_append' controla si las funciones de
     escritura de ficheros añaden información o sustituyen el fichero
     de salida. Cuando `file_output_append' toma el valor `true', estas
     funciones amplían el contenido de sus ficheros de salida; en otro
     caso, sustituyen el fichero anterior de igual nombre por otro con
     el nuevo contenido.

     Las funciones `save', `stringout' y `with_stdout' se ven afectadas
     por el valor que tome la variable `file_output_append'. Otras
     funciones que también escriben en ficheros de salida no tienen en
     cuenta este valor; en concreto, las funciones para la
     representación de gráficos y las de traducción siempre sustituyen
     el fichero anterior por uno nuevo de igual nombre, mientras que
     las funciones `tex' y `appendfile' siempre añaden información al
     fichero de salida sin eliminar la información anterior.


 -- Función: appendfile (<filename>)
     Añade información de la consola a <filename>, de igual manera que
     lo hace `writefile', pero con la salvedad de que si el archivo ya
     existe la información queda añadida al final de su contenido.

     La función `closefile' cierra los archivos abiertos por
     `appendfile' o `writefile'.


 -- Función: batch (<filename>)
     Lee expresiones de Maxima desde <filename> y las evalúa. La función
     `batch' busca <filename> en la lista `file_search_maxima'.  Véase
     `file_search'.

     El contenido de <filename> debe ser una secuencia de expresiones
     de Maxima, cada una de las cuales termina en `;' o `$'.  La
     variable especial `%' y la función `%th' se refieren a resultados
     previos dentro del archivo.  El archivo puede incluir
     construcciones del tipo `:lisp'.  Espacios, tabulaciones y saltos
     de línea en el archivo se ignoran.  Un archivo de entrada válido
     puede crearse con un editor de texto o con la función `stringout'.

     La función `batch' lee las expresiones del archivo <filename>,
     muestra las entradas en la consola, realiza los cálculos
     solicitados y muestra las expresiones de los resultados.  A las
     expresiones de entrada se les asignan etiquetas, así como a las de
     salida. La función `batch' evalúa todas las expresiones de entrada
     del archivo a menos que se produzca un error.  Si se le solicita
     información al usuario (con `asksign' o `askinteger', por ejemplo)
     `batch' se detiene para leer la nueva información para luego
     continuar.

     Es posible detener  `batch' tecleando `control-C' desde la consola.
     El efecto de `control-C' depende del entorno Lisp instalado.

     La función `batch' tiene diversas aplicaciones, tales como servir
     de almacén de líneas de instrucciones, suministrar demostraciones
     libres de errores o ayudar a organizar el trabajo del usuario en
     la resolución de problemas complejos.

     La función `batch' evalúa su argumento.

     Véanse también  `load', `batchload' y `demo'.


 -- Función: batchload (<filename>)
     Lee expresiones de Maxima desde <filename> y las evalúa sin
     mostrar las entradas ni las salidas y sin asignarles etiquetas.
     Sin embargo, las salidas producidas por  `print' o `describe' sí
     se muestran.

     La variable especial `%' y la función `%th' se refieren a
     resultados previos del intérprete interactivo, no a los del propio
     archivo. El archivo no puede incluir construcciones del tipo
     `:lisp'.

     La función `batchload' devuelve la ruta de <filename> en formato
     de cadena.

     La función `batchload' evalúa sus argumentos.

     Véanse también `batch' y `load'.


 -- Función: closefile ()
     La función `closefile' cierra los archivos abiertos por
     `appendfile' o `writefile'.


 -- Función: concat (<arg_1>, <arg_2>, ...)
     Concatena sus argumentos, que deben ser todos átomos.  El valor
     devuelto es un símbolo si el primer argumento es a su vez un
     símbolo, o una cadena de Maxima en caso contrario.

     La función `concat' evalúa sus argumentos.  El apátrofo  `'' evita
     la evaluación.

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     A un símbolo construido por `concat' se le puede asignar un valor
     y ser utilizado posteriormente en expresiones.  La asignación con
     el operador `::' evalúa su expresión izquierda.

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     Nótese que aunque `concat (1, 2)' parezca un número, se trata de
     una cadena de Maxima.

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3


 -- Función: sconcat (<arg_1>, <arg_2>, ...)
     Concatena sus argumentos para producir una cadena.  Al contrario
     que `concat', sus argumentos no necesitan ser átomos.

     El resultado es una cadena de Lisp.

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3


 -- Función: disp (<expr_1>, <expr_2>, ...)
     Es como `display' pero sólo se muestran los valores de los
     argumentos, no las ecuaciones. Es útil para argumentos complicados
     que no tienen nombre o en situaciones en las que solamente es de
     interés el valor del argumento pero no su nombre.


 -- Función: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Función: dispcon (all)
     Muestra las propiedades contractivas de sus argumentos tal como
     fueron asignadas por `defcon'. La llamada `dispcon (all)' muestra
     todas propiedades contractivas que fueron definidas.


 -- Función: display (<expr_1>, <expr_2>, ...)
     Muestra las ecuaciones cuyos miembros izquierdos son <expr_i> sin
     evaluar y cuyos miembros derechos son los valores de las
     expresiones. Esta función es útil en los bloques y en las
     sentencias `for' para mostrar resultados intermedios.  Los
     argumentos de `display' suelen ser átomos, variables subindicadas
     o llamadas a funciones. Véase también `disp'.

          (%i1) display(B[1,2]);
                                                2
                                   B     = X - X
                                    1, 2
          (%o1)                            done


 -- Variable opcional: display2d
     Valor por defecto: `true'

     Si `display2d' vale `false', la salida por consola es una cadena
     unidimensional, en lugar de una expresión bidimensional.


 -- Variable opcional: display_format_internal
     Valor por defecto: `false'

     Si `display_format_internal' vale `true', las expresiones se
     muestran sin ser transformadas de manera que oculten su
     representación matemática interna. Se representa lo que la función
     `inpart' devolvería, en oposición a `part'.

     Ejemplos:

          User     part       inpart
          a-b;      A - B     A + (- 1) B

                     A            - 1
          a/b;       -         A B
                     B
                                 1/2
          sqrt(x);   sqrt(X)    X

                    4 X        4
          X*4/3;    ---        - X
                     3         3


 -- Función: dispterms (<expr>)
     Muestra <expr> en partes, una debajo de la otra.  Esto es, primero
     se muestra el operador de <expr>, luego cada término si se trata
     de una suma, o cada factor si es un producto, o si no se muestra
     separadamente la parte de una expresión más general. Es útil si
     <expr> es demasiado grande para representarla de otra forma.  Por
     ejemplo, si `P1', `P2', ...  son expresiones muy grandes, entonces
     el programa de representación puede superar el espacio de
     almacenamiento tratando de mostrar `P1 + P2 + ...' todo junto.
     Sin embargo, `dispterms (P1 + P2 + ...)' muestra `P1', debajo
     `P2', etc.  Cuando una expresión exponencial es demasiado ancha
     para ser representada como `A^B', si no se utiliza `dispterms',
     entonces aparecerá como `expt (A, B)' (o como `ncexpt (A, B)', en
     lugar de `A^^B').


 -- Variable opcional: error_size
     Valor por defecto: 10

     La variable `error_size' modifica los mensajes de error de acuerdo
     con el tamaño de las expresiones que aparecen en él. Si el tamaño
     de una expresión (tal como lo determina la función Lisp
     `ERROR-SIZE') es mayor que `error_size', la expresión se reemplaza
     en el mensaje por un símbolo, asignándole a éste una expresión.
     Los símbolos se toman de la lista `error_syms'.

     En caso contrario, si la expresión es menor que `error_size', la
     expresión se muestra en el propio mensaje.

     Véanse también `error' y `error_syms'.

     Ejemplo:

     El tamaño de `U', tal como lo determina `ERROR-SIZE', es 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Variable opcional: error_syms
     Valor por defecto: `[errexp1, errexp2, errexp3]'

     En los mensajes de error, las expresiones mayores que `error_size'
     son reemplazadas por símbolos a los cuales se les asignas estas
     expresiones.  Los símbolos se toman de la lista `error_syms'. La
     primera expresión que resulte ser demasiado larga se reemplaza por
     `error_syms[1]', la segunda por `error_syms[2]' y así
     sucesivamente.

     Si hay más expresiones largas que elementos en `error_syms', los
     símbolos se construyen automáticamente, siendo el <n>-ésimo
     símbolo equivalente a `concat ('errexp, <n>)'.

     Véanse también `error' y `error_size'.


 -- Función: expt (<a>, <b>)
     Si una expresión exponencial es demasiado ancha para ser mostrada
     como `<a>^<b>' aparecerá como `expt (<a>, <b>)' (o como `ncexpt
     (<a>, <b>)' en lugar de `<a>^^<b>').

     Las funciones `expt' y `ncexpt' no se reconocen en una entrada.


 -- Variable opcional: exptdispflag
     Valor por defecto: `true'

     Si `exptdispflag' vale `true', Maxima muestra las expresiones con
     exponentes negativos como cocientes; por ejemplo, `X^(-1)' se
     muestra como `1/X'.


 -- Función: filename_merge (<path>, <filename>)
     Construye una ruta modificada a partir de <path> y <filename>.  Si
     la componente final de <path> es de la forma `###.<something>', la
     componente se reemplaza con `<filename>.<something>'.  En otro
     caso, la componente final se reemplaza simplemente por <filename>.


 -- Función: file_search (<filename>)
 -- Función: file_search (<filename>, <pathlist>)
     La función `file_search' busca el archivo <filename> y devuelve su
     ruta como una cadena; si no lo encuentra,  `file_search' devuelve
     `false'. La llamada `file_search (<filename>)' busca en los
     directorios de búsqueda por defecto, que son los especificados por
     las variables `file_search_maxima', `file_search_lisp' y
     `file_search_demo'.

     La función `file_search' analiza primero si el nombre del
     argumento existe antes de hacerlo coincidir con los comodines de
     los patrones de búsqueda de archivos.  Véase `file_search_maxima'
     para más información sobre patrones de búsqueda de archivos.

     El argumento <filename> puede ser una ruta con nombre de archivo,
     o simplemente el nombre del archivo, o, si el directorio de
     búsqueda de archivo incluye un patrón de búsqueda, es suficiente
     con el nombre de archivo sin extensión.  Por ejemplo,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     todos buscan el mismo archivo, dando por hecho que el archivo
     existe y que `/home/wfs/special/###.mac' está en
     `file_search_maxima'.

     La llamada `file_search (<filename>, <pathlist>)' busca solamente
     en los directorios especificados por <pathlist>, que es una lista
     de cadenas.  El argumento <pathlist> ignora los directorios de
     búsqueda por defecto, de manera que si se da la lista de rutas,
     `file_search' busca solamente en ellas y no en los directorios por
     defecto.  Incluso si hay un único directorio en <pathlist>, debe
     ser suministrado como una lista de un único elemento.

     El usuario puede modificar los directorios de búsqueda por
     defecto; véase para ello See `file_search_maxima'.

     La función `file_search' es llamada por `load' con los directorios
     de búsqueda `file_search_maxima' y `file_search_lisp'.


 -- Variable opcional: file_search_maxima
 -- Variable opcional: file_search_lisp
 -- Variable opcional: file_search_demo
     Estas variables especifican listas de directorios en los que deben
     buscar la funciones  `load', `demo' y algunas otras. Los valores
     por defecto de estas variables nombran directorios de la
     instalación de Maxima.

     El usuario puede modificar estas variables, bien reemplazando los
     valores por defecto, bien añadiendo nuevos directorios.  Por
     ejemplo,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     reemplaza el valor por defecto de `file_search_maxima', mintras que

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     añade dos directorios más. Puede ser conveniente colocar una
     expresión como esta en el archivo `maxima-init.mac', de manera que
     la ruta de búsqueda de ficheros se asigne automáticamente cada vez
     que arranca Maxima.

     Se pueden especificar varias extensiones de archivos y rutas con
     comodines especiales.  La cadena `###' representa el nombre del
     archivo buscado y una lista separada de comas y encerrada entre
     llaves,  `{foo,bar,baz}' representa múltiples cadenas.  Por
     ejemplo, suponiendo que se busca el nombre `neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     se interpreta como `/home/wfs/neumann.lisp',
     `/home/gcj/neumann.lisp', `/home/wfs/neumann.mac' y
     `/home/gcj/neumann.mac'.


 -- Función: file_type (<filename>)
     Devuelve una descripción del contenido de <filename> basada en la
     extensión, sin intentar abrir el archivo para inspeccionar su
     contenido.

     El valor que la función retorna puede ser cualquiera de los
     siguientes: `object', `lisp' o `maxima'.  Si la extensión comienza
     por `m' o `d', `file_type' devuelve `maxima'.  Si la extensión
     comienza por `l', `file_type' devuelve `lisp'.  En cualquier otro
     caso, `file_type' devuelve `object'.


 -- Función: grind (<expr>)
 -- Variable opcional: grind
     La función `grind' imprime <expr> en la consola en un formato
     admisible como entrada para Maxima. La función `grind' devuelve
     siempre `done'.

     Cuando <expr> es el nombre de una función o macro, `grind' muestra
     la definición de la función o de la macro en lugar de sólo su
     nombre.

     Véase también `string', que devuelve una cadena en lugar de
     imprimir la salida. La función `grind' intenta imprimir la
     expresión de forma que sea lago más sencilla de leer que la salida
     de `string'.

     Cuando la variable `grind' vale `true', la salida de `string' y
     `stringout' tienen el mismo formato que la de `grind'; en caso
     contrario no se formatea la salida de esas funciones.  El valor
     por defecto de la variable `grind' es `false'.

     La variable `grind' también se puede utilizar como  argumento en
     `playback'.  Si `grind' está presente, `playback' imprime las
     expresiones de entrada en el mismo formato que lo hace la función
     `grind'; en caso contrario no se formatean la expresiones de
     entrada.

     La función `grind' evalúa sus argumentos.

     Ejemplos:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10
          (%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
          p : makelist (0, i, 1, length (A))], for i thru n do for j : i thru n do
          (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1), if i = j then
          p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]), for i thru n do L[i, i] : 1 / p[i],
          for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
          (%i15) grind (cholesky);
          cholesky(A):=block(
                   [n:length(A),L:copymatrix(A),
                    p:makelist(0,i,1,length(A))],
                   for i thru n do
                       (for j from i thru n do
                            (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                             if i = j then p[i]:1/sqrt(x)
                                 else L[j,i]:x*p[i])),
                   for i thru n do L[i,i]:1/p[i],
                   for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
          (%o15)                        done
          (%i16) string (fundef (cholesky));
          (%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
          t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
          [i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
          ) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
          n do (for j from i+1 thru n do L[i,j]:0),L)

 -- Variable opcional: ibase
     Valor por defecto: 10

     Los enteros que se escriban en Maxima se interpretan como dados en
     base `ibase'.

     A la variable `ibase' se le puede asignar cualquier entero entre 2
     y 35 (decimal), ambos inclusive.  Si `ibase' es mayor que 10, las
     cifras serán los números decimales entre 0 y 9, más las letras
     mayúsculas A, B, C, ..., sgún sea necesario.  Las cifras en base
     35, la mayor base que acepta Maxima, son los dígitos de 0 a 9 y
     las letras de A a Y.

     Véase también `obase'.


 -- Variable opcional: inchar
     Valor por defecto: `%i'

     La variable `inchar' es el prefijo de las etiquetas de las
     expresiones introducidas por el usuario.  Maxima crea
     automáticamente una etiqueta para cada expresión de entrada
     concatenando `inchar' y `linenum'; a `inchar' se le puede asignar
     cualquier símbolo o cadena, no necesariamente un caracácter
     sencillo.

          (%i1) inchar: "input";
          (%o1)                                input
          (input1) expand ((a+b)^3);
                                      3        2      2      3
          (%o1)                      b  + 3 a b  + 3 a  b + a
          (input2)

     Véase también `labels'.


 -- Función: ldisp (<expr_1>, ..., <expr_n>)
     Muestra las expresiones <expr_1>, ..., <expr_n> en la consola con
     el formato de salida; `ldisp' asigna una etiqueta a cada argumento
     y devuelve la lista de etiquetas.

     Véase también `disp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a


 -- Función: ldisplay (<expr_1>, ..., <expr_n>)
     Muestra las expresiones <expr_1>, ..., <expr_n> en la consola con
     el formato de salida.  Cad expresión se muestra como una ecuación
     de la forma `lhs = rhs' en la que `lhs' es uno de los argumentos
     de `ldisplay' y `rhs' su valor. Normalmente, cada argumento será
     el nombre de una variable. La función `ldisp' asigna una etiqueta
     a cada ecuación y devuelve la lista de etiquetas.

     Véase también `display'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a


 -- Variable opcional: linechar
     Valor por defecto: `%t'

     La variable `linechar' es el prefijo de las etiquetas que genera
     Maxima para expresiones intermedias. Cuando sea necesario, Maxima
     creará una etiqueta para cada expresión intermedia concatenando
     `linechar' y `linenum'. A `linechar' se le puede asignar cualquier
     cadena o símbolo, no necesariamente un carácter simple.

     Las expresiones intermedias pueden ser mostradas o no.  Véanse
     también `programmode' y `labels'.


 -- Variable opcional: linel
     Valor por defecto: 79

     La variable `linel' es la anchura (medida en número de caracteres)
     de la consola que se le da a Maxima para que muestre las
     expresiones. A `linel' se le puede asignar cualquier valor, pero
     si éste es muy pequeño o grande resultará de poca utilidad. El
     texto que impriman las funciones internas de Maxima, como los
     mensajes de error y las salidas de la función `describe', no se ve
     afectado por el valor de `linel'.


 -- Variable opcional: lispdisp
     Valor por defecto: `false'

     Si `lispdisp' vale `true', los símbolos de Lisp se muestran
     precedidos del carácter de interrogación `?'. En caso contrario,
     los símbolos de Lisp se muestran sin esta marca.

     Ejemplos:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar


 -- Función: load (<filename>)
     Evalúa las expresiones del archivo <filename>, trayendo variables,
     funciones y otros objetos a Maxima.  Una asignación hecha
     previamente a una variable en Maxima será destruida por otra
     asignación que se le haga en <filename>. Para encontrar el
     fichero, `load' llama a `file_search' con `file_search_maxima' y
     `file_search_lisp' como directorios de búsqueda. Si la llamada a
     `load' funciona correctamente, devuelve el nombre del fichero; en
     caso contrario, `load' muestra un mensaje de error.

     La función `load' trabaja indistintamente con código Lisp y Maxima.
     Los ficheros creados con `save', `translate_file' y
     `compile_file', que crea código Lisp, y `stringout', que crea
     código Maxima, todos ellos pueden ser procesados por `load'. La
     función `load' llama a `loadfile' para cargar archivos en Lisp y a
     `batchload' para cargar archivos en Maxima.

     Véanse también `loadfile', `batch', `batchload' y `demo';
     `loadfile' procesa archivos en Lisp; `batch', `batchload' y `demo'
     procesan archivos en Maxima.

     Véase `file_search' para más detalles sobre el mecanismo de
     búsqueda de archivos.

     La función `load' evalúa sus argumentos.


 -- Función: loadfile (<filename>)
     Evalúa las expresiones Lisp del archivo <filename>. La función
     `loadfile' no llama a `file_search', de manera que `filename' debe
     incluir la extensión del archivo y su ruta completa.

     La función `loadfile' puede procesar ficheros creados por  `save',
     `translate_file' y `compile_file'.  Puede ser más conveniente
     utilizar `load' en lugar de `loadfile'.

     La función `loadfile' no evalúa su argumento, de manera que
     `filename' debe ser una cadena, no una variable que la contenga.
     La utilización de doble comilla simple sí permite la evaluación.


 -- Variable opcional: loadprint
     Valor por defecto: `true'

     La variable `loadprint' indica si mostrar un mensaje cuando se
     carga un archivo.

        * Si `loadprint' vale `true', se muestra siempre un mensaje.

        * Si `loadprint' vale `'loadfile', muestra un mensaje sólo si
          el archivo es cargado con la función `loadfile'.

        * Si `loadprint' vale `'autoload', muestra un mensaje sólo
          cuandi un archivo se carga automáticamente. Véase
          `setup_autoload'.

        * Si `loadprint' vale `false', nunca mostrará mensajes.


 -- Variable opcional: obase
     Valor por defecto: 10

     La variable `obase' es la base de los enteros mostrados por
     Maxima; se le puede asignar cualquier entero entre 2 y 35
     (decimal), ambos inclusive. Si `obase' es mayor que 10, las cifras
     serán los números decimales entre 0 y 9, más las letras mayúsculas
     A, B, C, ..., sgún sea necesario.  Las cifras en base 35, la mayor
     base que acepta Maxima, son los dígitos de 0 a 9 y las letras de A
     a Y.

     Véase también `ibase'.


 -- Variable opcional: outchar
     Valor por defecto: `%o'

     La variable `outchar' es el prefijo de las etiquetas de las
     expresiones calculadas por Maxima.  Maxima crea automáticamente
     una etiqueta para cada expresión calculada concatenando `outchar'
     y `linenum'; a `outchar' se le puede asignar cualquier símbolo o
     cadena, no necesariamente un caracácter sencillo.

          (%i1) outchar: "output";
          (output1)                           output
          (%i2) expand ((a+b)^3);
                                      3        2      2      3
          (output2)                  b  + 3 a b  + 3 a  b + a
          (%i3)

     Véase también `labels'.


 -- Variable opcional: packagefile
     Valor por defecto: `false'

     Los desarrolladores de paquetes que utilizan  `save' o `translate'
     para crear paquetes (ficheros) que van a ser utilizados por
     terceros pueden hacer `packagefile: true' para evitar que se añada
     información a la listas de información de Maxima (por ejemplo,
     `values', `functions') excepto allí donde sea necesario cuando el
     archivo sea cargado en memoria.


 -- Variable opcional: pfeformat
     Valor por defecto: `false'

     Si `pfeformat' vale `true', una fracción de enteros será mostrada
     con el carácter de barra inclinada `/' entre ellos.

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)


 -- Función: print (<expr_1>, ..., <expr_n>)
     Evalúa y muestra las expresiones  <expr_1>, ..., <expr_n>
     secuencialmente de izquierda a derecha, comenzando la impresión
     por el borde izquierdo de la consola.

     El valor devuelto por `print' es el valor de su último argumento.
     La función `print' no genera etiquetas para las expresiones
     intermedias.

     Véanse también `display', `disp', `ldisplay' y `ldisp', que
     muestran una expresión por línea, mientras que `print' trata de
     mostrar dos o más expresiones por línea.

     Para mostrar el contenido de un archivo véase `printfile'.

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)


 -- Función: read (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n> y a continuación lee una expresión
     desde la consola y devuelve la expresión evaluada. La expresión
     termina con un punto y coma `;' o con el símbolo de dólar `$'.

     Véase también `readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo vale", foo, " -- nuevo valor.")$
          foo vale 42  -- nuevo valor.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)


 -- Función: readonly (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n> y a continuación lee una expresión
     desde la consola y devuelve la expresión sin evaluar. La expresión
     termina con un punto y coma `;' o con el símbolo de dólar `$'.

          (%i1) aa: 7$
          (%i2) foo: readonly ("Introducir expresion:");
          Introducir expresion:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Introducir expresion:");
          Introducir expresion:
          2^aa;
          (%o3)                            128

     Véase también `read'.


 -- Función: reveal (<expr>, <nivel>)
     Reemplaza partes de <expr> al <nivel> especificado y las sutituye
     por descripciones cortas.

        * Las sumas y restas se reemplazan por `sum(<n>)', siendo <n>
          el número de términos de la suma.

        * Los productos se reemplazan por `product(<n>)', siendo <n> el
          número de factores del producto.

        * Las potencias se reemplazan por `expt'.

        * Los cocientes se reemplazan por `quotient'.

        * El símbolo negativo se reemplaza por `negterm'.

     Si el entero  <depth> es mayor o igual que la profundidad máxima
     de <expr>, `reveal (<expr>, <depth>)' devuelve <expr> sin
     modificar.

     La función `reveal' evalúa sus argumentos y devuelve la expresión
     con las modificaciones solicitadas.

     Ejemplo:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       quotient
          (%i3) reveal (e, 2);
                                       sum(3)
          (%o3)                        ------
                                       sum(3)
          (%i4) reveal (e, 3);
                               expt + negterm + expt
          (%o4)               ------------------------
                              product(2) + expt + expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - product(3) + a
          (%o5)         ------------------------------------
                                   product(2)     product(2)
                        2 expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e


 -- Variable opcional: rmxchar
     Valor por defecto: `]'

     La variable `rmxchar' es el carácter que se dibuja al lado derecho
     de una matriz.

     Véase también `lmxchar'.


 -- Función: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Función: save (<filename>, values, functions, labels, ...)
 -- Función: save (<filename>, [<m>, <n>])
 -- Función: save (<filename>, <name_1>=<expr_1>, ...)
 -- Función: save (<filename>, all)
     Alamacena los valores actuales de <name_1>, <name_2>, <name_3>,
     ..., en el archivo <filename>.  Los argumentos son nombres de
     variables, funciones u otros objetos.  Si un nombre no tiene un
     valor o una función asociado a él, entonces se ignora.

     La función `save' devuelve <filename>.

     La función `save' almacena datos en forma de expresiones Lisp.
     Los datos almacenados por `save' pueden recuperarse con `load
     (<filename>)'.  El resultado de ejecutar  `save' cuando <filename>
     ya existe depende del soporte Lisp implementado; el archivo puede
     ser sobreescrito o que `save' envíe un mesaje de error.

     La llamada `save (<filename>, values, functions, labels, ...)'
     almacena los elementos cuyos nombres son `values', `functions',
     `labels', etc.  Los nombres pueden ser cualesquiera de los
     especificados por la variable `infolists'; `values' incluye todas
     las variables definidas por el usuario.

     La llamada `save (<filename>, [<m>, <n>])' almacenas los valores
     de las etiquetas de entrada y salida desde <m> hasta <n>.  Nótese
     que <m> y <n> deben ser números o nombres de variables precedidas
     de doble comilla simple.  Las etiquetas de entrada y salida
     también se pueden almacenar una a una, por ejemplo, `save
     ("foo.1", %i42, %o42)'.  La llamada `save (<filename>, labels)'
     almacena todas las etiquetas de entrada y salida.  Cuando las
     etiquetas almacenadas en el archivo sean posteriormente
     recuperadas, se sobreescribirán las activas en ese momento.

     La llamada `save (<filename>, <name_1>=<expr_1>,
     <name_2>=<expr_2>, ...)' almacena los valores de <expr_1>,
     <expr_2>, ..., con los nombres <name_1>, <name_2>, ....  Es útil
     hacer este tipo de llamada para con etiquetas de entrada y salida,
     por ejemplo, `save ("foo.1", aa=%o88)'.  El miembro derecho de la
     igualdad puede ser cualquier expresión, que será evaluada.  Esta
     llamada a la función `save' no incorpora nuevos nombres a la
     sesión actual de Maxima, simplemente los almacena en el archivo
     <filename>.

     Todas estas formas de llamar a la función `save' se pueden
     combinar a voluntad.  Por ejemplo, `save (<filename>, aa, bb,
     cc=42, functions, [11, 17])'.

     La llamada `save (<filename>, all)' almacena el estado actual de
     Maxima, lo que incluye todas las variables definidas por el
     usuario, funciones, arreglos, etc., así como algunos objetos
     definidos automáticamente.  Los elementos almacenados incluyen
     variables del sistema, como `file_search_maxima' o `showtime', si
     han sido modificadas por el usuario. Véase `myoptions'.

     La función `save' no evalúa sus argumentos.  El argumento
     <filename> debe ser una cadena, no una variable que contenga una
     cadena. Si se especifican números de etiquetas, éstos deben ser
     enteros.  El operador de doble comilla simple evalúa una variable
     de cadena devolviendo su valor, por ejemplo, `s: "foo.1"$ save
     (''s, all)$', y de las variables enteras devuelve sus valores
     enteros, como en `m: 5$ n: 12$ save ("foo.1", [''m, ''n])$'.


 -- Variable opcional: savedef
     Valor por defecto: `true'

     Si `savedef' vale `true', se mantiene la versión Maxima de una
     función definida por el usuario cuando ésta se traduce, lo que
     permite mostrar su código con `dispfun' y que la función pueda ser
     editada.

     Si `savedef' vale `false', los nombres de las funciones traducidas
     se eliminan de la lista `functions'.


 -- Función: show (<expr>)
     Muestra `expr' con sus objetos indexados que tengan índices
     covariantes como subíndices y los contravariantes como
     superíndices.  Los índices derivados se muestran como subíndices,
     separados por una coma de los covariantes.


 -- Función: showratvars (<expr>)
     Devuelve una lista de las variables de expresiones canónicas
     racionales (CRE) en la expresión `expr'.

     Véase también `ratvars'.


 -- Variable opcional: stardisp
     Valor por defecto: `false'

     Si `stardisp' vale `true', la multiplicación se muestra con un
     asterisco `*' entre los operandos.


 -- Función: string (<expr>)
     Convierte `expr' a la notación lineal de Maxima, tal como si fuese
     tecleada.

     El valor que retorna la función `string' es una cadena, por lo que
     no puede ser utilizada en los cálculos.


 -- Variable de Lisp: stringdisp
     Valor por defecto: `false'

     Si `?stringdisp' vale `true', las cadenas alfanuméricas se
     muestran encerradas entre comillas dobles. En caso contrario, no
     se nuestran las comillas.

     La variable `?stringdisp' vale siempre `true' cuando se muestra la
     definición de una función.

     La variable `?stringdisp' es una variable Lisp, por lo que debe
     ser escrita precedida de un signo de interrogación `?'.

     Ejemplos:

          (%i1) ?stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () := print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) ?stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."


 -- Función: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Función: stringout (<filename>, [<m>, <n>])
 -- Función: stringout (<filename>, input)
 -- Función: stringout (<filename>, functions)
 -- Función: stringout (<filename>, values)
     La función `stringout' escribe expresiones en un archivo de la
     misma forma en que se escribirían como expresiones de entrada. El
     archivo puede ser utilizado entonces como entrada a las funciones
     `batch' o `demo', y puede ser editado para cualquier otro
     propósito.

     La forma general de `stringout' escribe los valores de una o más
     expresiones en el archivo de salida. Nótese que si una expresión
     es una variable, solamente se escribirá el valor de la variable y
     no el nombre de ésta. Como caso especial, y muy útil en algunas
     ocasiones, las expresiones pueden ser etiquetas de entrada (`%i1',
     `%i2', `%i3', ...) o de salida (`%o1', `%o2', `%o3', ...).

     Si `grind' vale `true', `stringout' formatea la salida utilizando
     `grind'. En caso contrario, se utilizará el formato `string'.
     Véanse `grind' y `string'.

     La forma especial `stringout (<filename>, [<m>, <n>])' escribe los
     valores de las etiquetas de entrada desde la m hasta la n, ambas
     inclusive.

     La forma especial `stringout (<filename>, input)' escribe todas
     las etiquetas de entrada en el archivo.

     La forma especial `stringout (<filename>, functions)' escribe
     todas las funciones definidas por el usuario, contenidas en la
     lista global `functions', en el archivo.

     La forma especial `stringout (<filename>, values)' escribe todas
     las variables asignadas por el usuario, contenidas en la lista
     global `values', en el archivo. Cada variable se escribe como una
     sentencia de asignación, con el nombre de la variable seguida de
     dos puntos y a continuación su valor. Nótese que la forma general
     de `stringout' no escribe las variables como sentencias de
     asignación.


 -- Función: tex (<expr>
 -- Función: tex (<label>)
 -- Función: tex (<expr>, <filename>)
 -- Función: tex (<label>, <filename>)
     Devuelve la expresión en un formato apropiado para para ser
     incorporado a un documento basado en TeX.  El resultado que se
     obtiene es un fragmento de código que puede incluirse en un
     documento mayor, pero que no puede ser procesado aisladamente.

     La instrucción `tex (<expr>)' imprime en la consola la
     representación en TeX de <expr>.

     La instrucción `tex (<label>)' imprime en la consola la
     representación en TeX de la expresión a la que hace referencia la
     etiqueta <label>, asignándole a su vez una etiqueta de ecuación
     que será mostrada al lado izquierdo de la misma. La etiqueta de la
     expresión en TeX es la misma que la de Maxima.

     La instrucción `tex (<expr>, <filename>)' añade la representación
     TeX de <expr> al fichero <filename>. La función `tex' no evalúa el
     argumento <filename>, pero la doble comilla simple `''' fuerza su
     evaluación.

     La instrucción `tex (<label>, <filename>)' añade la representación
     TeX de la expresión a la que hace referencia la etiqueta  <label>,
     junto con una etiqueta, al fichero <filename>. La función `tex' no
     evalúa el argumento <filename>, pero la doble comilla simple `'''
     fuerza su evaluación.

     La función `tex' evalúa sus argumentos tras comprobar si se trata
     de una etiqueta. La doble comilla simple `''' fuerza la evaluación
     del argumento, anulando la comprobación sobre la etiqueta.

     Véase también `texput'.

     Ejemplos:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)


 -- Función: texput (<a>, <s>)
 -- Función: texput (<a>, <s>, <operator_type>)
 -- Función: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Función: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)
     Establece el formato en TeX del átomo <a>, el cual puede ser un
     símbolo o el nombre de un operador.

     La instrucción `texput (<a>, <s>)' hace que la función `tex'
     introduzca <s> en la salida TeX en el lugar de <a>.

     La instrucción `texput (<a>, <s>, <operator_type>)', en la que
     <operator_type> es `prefix', `infix' o `postfix', hace que la
     función `tex' introduzca <s> en la salida TeX en el lugar de <a>,
     colocándolo en el lugar correcto.

     La instrucción `texput (<a>, [<s_1>, <s_2>], matchfix)' hace que
     la función `tex' introduzca <s_1> y <s_2> en la salida TeX a los
     lados de los argumentos de <a>. Si son más de uno, los argumentos
     se separan por comas.

     La instrucción `texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)'
     hace que la función `tex' introduzca <s_1> y <s_2> en la salida
     TeX a los lados de los argumentos de <a>, con <s_3> separando los
     argumentos.

     Ejemplos:

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false
          (%i3) texput (lcm, "\\mathrm{lcm}");
          (%o3)                     \mathrm{lcm}
          (%i4) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o4)                         false
          (%i5) prefix ("grad");
          (%o5)                         grad
          (%i6) texput ("grad", " \\nabla ", prefix);
          (%o6)                          180
          (%i7) tex (grad f);
          $$ \nabla f$$
          (%o7)                         false
          (%i8) infix ("~");
          (%o8)                           ~
          (%i9) texput ("~", " \\times ", infix);
          (%o9)                          180
          (%i10) tex (a ~ b);
          $$a \times b$$
          (%o10)                        false
          (%i11) postfix ("@");
          (%o11)                          @
          (%i12) texput ("@", "!!", postfix);
          (%o12)                         160
          (%i13) tex (x @);
          $$x!!$$
          (%o13)                        false
          (%i14) matchfix ("<<", ">>");
          (%o14)                         <<
          (%i15) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o15)              \langle ( \rangle , false)
          (%i16) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o16)                        false
          (%i17) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o17)                        false
          (%i18) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], matchfix);
          (%o18)            \langle ( \rangle ,  \, | \,)
          (%i19) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o19)                        false
          (%i20) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o20)                        false


 -- Función: system (<command>)
     Ejecuta la instrucción <command> como un proceso independiente de
     Maxima.  La instrucción se le pasa a la consola del sistema para
     su ejecución.  La función `system' no está soportada por todos los
     sistemas operativos, pero suele estarlo en todos los entornos
     Unix y similares.

     Suponiendo que `_hist.out' es una lista de frecuencias que se
     quieren representar en un diagrama de barras utilizando el
     programa `xgraph',

          (%i1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));

     A fin de hacer el diagrama y eliminar el archivo temporal
     posteriormente, hágase:

          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")


 -- Variable opcional: ttyoff
     Valor por defecto: `false'

     Si `ttyoff' vale `true', no se muestran las expresiones
     resultantes, pero éstas se calculan de todos modos y se les
     asignan etiquetas. Véase `labels'.

     El texto que escriban las funciones internas de Maxima, tales como
     los mensajes de error y las salidas de `describe', no se ven
     afectadas por `ttyoff'.


 -- Macro: with_stdout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
     Abre el archivo <filename> y a continuación evalúa <expr_1>,
     <expr_2>, <expr_3>, ....  Los valores de los argumentos no se
     almacenan <filename>, pero cualquier resultado a imprimir por
     `print', `display', `disp' o `grind', va a parar al archivo
     <filename> en lugar de a la consola.

     La macro `with_stdout' devuelve el valor de su último argumento.

     Véase también `writefile'.

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800


 -- Función: writefile (<filename>)
     Comienza escribiendo una transcripción de la sesión de Maxima en
     el archivo <filename>.  Cualquier interacción entre Maxima y el
     usuario se almacena también en este archivo, tal como aparece en
     la consola.

     Puesto que la transcripción se escribe en el formato de salida a
     la consola, su contenido no es interpretable por Maxima.  Para
     hacer un archivo que contenga expresiones que puedan ser
     nuevamente cargadas en Maxima, véanse `save' y `stringout'; la
     función `save' almacena expresiones en formato Lisp, mientras que
     `stringout' lo hace en formato Maxima.

     El resultado de ejecutar `writefile' cuando el archivo <filename>
     ya existe depende del entorno Lisp operativo; el contenido
     anterior puede ser sobreescrito o ampliado con la sesión actual.
     La función `appendfile' siempre añade la sesión al contenido
     actual.

     Puede ser útil ejecutar `playback' después de `writefile' para
     guardar las interacciones previas de la sesión. Puesto que
     `playback' muestra solamente las variables de entrada y salida
     (`%i1', `%o1', etc.), cualquier salida generada por una sentencia
     de impresión desde dentro de una función no es mostrada por
     `playback'.

     La función `closefile' cierra los archivos abiertos por
     `writefile' o `appendfile'.



File: maxima.info,  Node: Aritmética de punto flotante,  Next: Contextos,  Prev: Entrada y Salida,  Up: Top

10 Aritmética de punto flotante
*******************************

* Menu:

* Definiones para aritmética de punto flotante::


File: maxima.info,  Node: Definiones para aritmética de punto flotante,  Prev: Aritmética de punto flotante,  Up: Aritmética de punto flotante

10.1 Definiones para aritmética de punto flotante
=================================================

 -- Función: bffac (<expr>, <n>)
     Versión para "bigfloat" de la función factorial (Gamma
     desplazada). El segundo argumento indica cuántos dígitos se
     conservan y devuelven, pudiendo utilizarse para obtener algunas
     cifras extra.

     La instrucción `load ("bffac")' carga esta función.


 -- Variable optativa: algepsilon
     Valor por defecto: 10^8

     El valor de `algepsilon' es usado por `algsys'.


 -- Función: bfloat (<expr>)
     Convierte todos los números y  funciones numéricas a números
     decimales de punto flotante grandes ("bigfloats").  El número de
     dígitos significativos de los "bigfloats" resultantes se
     especifica mediante la variable global `fpprec'.

     Si `float2bf' vale `false' se mostrará un mensaje de aviso cuando
     un número en punto flotante se convierte a decimal de tipo
     "bigfloats", puesto que tal transformación puede conllevar pérdida
     de precisión.


 -- Función: bfloatp (<expr>)
     Devuelve `true' si <expr> es un número decimal en punto flotante
     grande ("bigfloats"), en caso contrario devuelve `false'.


 -- Función: bfpsi (<n>, <z>, <fpprec>)
 -- Función: bfpsi0 (<z>, <fpprec>)
     La función `bfpsi' es la poligamma de argumento real <z> y de
     orden el entero <n>. La función `bfpsi0' es la digamma.  La
     llamada `bfpsi0 (<z>, <fpprec>)' equivale a `bfpsi (0, <z>,
     <fpprec>)'.

     Estas funciones devuelven valores "bigfloat". La variable <fpprec>
     es la precisión "bigfloat" del valor de retorno.

     La instrucción `load ("bffac")' carga estas funciones.


 -- Variable optativa: bftorat
     Valor por defecto: `false'

     La variable `bftorat' controla la conversión de números decimales
     de punto flotante grandes ("bigfloats") a números racionales. Si
     `bftorat' vale `false', se utilizará `ratepsilon' para controlar
     la conversión  (lo cual resulta en números racionales
     relativamente pequeños). Si  `bftorat' vale `true', el número
     racional generado representará exactamente al número decimal de
     punto flotante grande ("bigfloat").


 -- Variable optativa: bftrunc
     Valor por defecto: `true'

     La variable `bftrunc' provoca la eliminación de ceros en números
     decimales grandes no nulos para que no se muestren.  Así, si
     `bftrunc' vale `false', `bfloat (1)' se muestra como
     `1.000000000000000B0'. En otro caso, se mostrará como `1.0B0'.


 -- Función: cbffac (<z>, <fpprec>)
     Calcula el factorial de números complejos de punto flotante
     grandes.

     La instrucción `load ("bffac")' carga esta función.


 -- Función: float (<expr>)
     Convierte los enteros, números racionales y los decimales de punto
     flotante grandes ("bigfloats") que están presentes en <expr> a
     números de punto flotante. También actúa como símbolo `evflag'.


 -- Variable optativa: float2bf
     Valor por defecto: `false'

     Si `float2bf' vale `false' se mostrará un mensaje de aviso cuando
     un número en punto flotante se convierte a decimal de tipo
     "bigfloats", puesto que tal transformación puede conllevar pérdida
     de precisión.


 -- Función: floatnump (<expr>)
     Devuelve `true' si <expr> es un número de punto flotante, en caso
     contario retorna `false'.


 -- Variable optativa: fpprec
     Valor por defecto: 16

     La variable `fpprec' guarda el número de dígitos significativos en
     la aritmética con números decimales de punto flotante grandes
     ("bigfloats"). La variable `fpprec' no afecta a los cálculos con
     números decimales de punto flotante ordinarios.

     Véanse también `bfloat' y `fpprintprec'.


 -- Variable optativa: fpprintprec
     Valor por defecto: 0

     La variable `fpprintprec' guarda el número de dígitos a imprimir
     cuando se muestren por terminal números decimales de punto
     flotante grandes, haciendo así que sea posible realizar cálculos
     con gran precisión pero mostrando los resultados con menor número
     de dígitos.

     Si `fpprintprec' vale 0, o es mayor o igual que `fpprec', entonces
     será el valor de `fpprec' el que controle el número de dígitos a
     presentar.

     Si `fpprintprec' toma un valor entre 2 y `fpprec - 1', entonces
     controlará el número de dígitos a utilizar.  (El número mínimo de
     dígitos es 2, uno a la izquierda del punto decimal y otro a la
     derecha.)

     No se admite el valor 1 para `fpprintprec'.


 -- Función Lisp: ?round (<x>)
 -- Función Lisp: ?round (<x>, <divisor>)
     Redondea el número decimal en punto flotante <x> al entero más
     próximo. El argumento debe ser un decimal flotante ordinario, no
     grande ("bigfloat").   El símbolo `?' al comienzo indica que se
     trata de una función Lisp.

          (%i1) ?round (-2.8);
          (%o1)                            - 3


 -- Función Lisp: ?truncate (<x>)
 -- Función Lisp: ?truncate (<x>, <divisor>)
     Trunca el número decimal en punto flotante <x> en dirección al 0,
     para convertirlo en un entero. El argumento debe ser un decimal
     flotante ordinario, no grande ("bigfloat").   El símbolo `?' al
     comienzo indica que se trata de una función Lisp.

          (%i1) ?truncate (-2.8);
          (%o1)                            - 2
          (%i2) ?truncate (2.4);
          (%o2)                             2
          (%i3) ?truncate (2.8);
          (%o3)                             2



File: maxima.info,  Node: Contextos,  Next: Polinomios,  Prev: Aritmética de punto flotante,  Up: Top

11 Contextos
************

* Menu:

* Definiciones para Contextos::



Local Variables:
coding: iso-8859-1
End:
