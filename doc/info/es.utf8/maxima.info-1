This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introducción a Maxima,  Prev: (dir),  Up: (dir)

Manual de Maxima
****************

Maxima es un sistema de cálculo simbólico escrito en Lisp.

   Maxima desciende del sistema Macsyma, desarrollado en el MIT
(Massachusetts Institute of Technology) entre los años 1968 y 1982 como
parte del proyecto MAC. El MIT pasó una copia del código fuente al DOE
(Department of Energy) en 1982, en una versión conocida como
DOE-Macsyma. Una de estas copias fue mantenida por el Profesor William
F. Schelter de la Universidad de Texas desde el año 1982 hasta su
fallecimiento en 2001. En 1998 Schelter había obtenido del Departamento
de Energía permiso para distribuir el código fuente de DOE-Macsyma bajo
licencia GNU-GPL, iniciando en el año 2000 el proyecto Maxima en
SourceForge con el fin de mantener y seguir desarrollando DOE-Macsyma,
ahora con el nombre de Maxima.

   Notas de la traducción española.

   La versión española del manual de Maxima la mantienen Mario
Rodríguez y Jaime Villate; para comentarios, sugerencias y
colaboraciones, contáctese mediante cualquiera de las siguientes
direcciones de correo electrónico:

   * mario ARROBA edu PUNTO xunta PUNTO es

   * villate ARROBA fe PUNTO up PUNTO pt

* Menu:


Infraestructura de Maxima

* Introducción a Maxima::            Muestra de sesiones con Maxima.
* Detección e informe de fallos::    Gestión de fallos en Maxima.
* Ayuda::                              Solicitando ayuda desde una sesión de Maxima.
* Línea de Comandos::    Sintaxis de los comandos de Maxima.
* Operadores::                         Operadores utilizados en expresiones de Maxima.
* Expresiones::                        Expresiones de Maxima.
* Simplificación::                   Simplificando expresiones.
* Gráficos::                         Gráficos en dos y tres dimensiones.
* Lectura y escritura::                Lectura y escritura de archivos
* Aritmética de punto flotante::     Rutinas numéricas de bajo nivel.
* Contextos::                          Imposición de restricciones a variables.

Soporte para campos más específicos de las matemáticas

* Polinomios::                         Operaciones con polinomios.
* Constantes::                         Constantes numéricas.
* Logaritmos::                         Transformación y cálculo de expresiones logarítmicas.
* Trigonometría::        Transformación y cálculo de expresiones trigonométricas.
* Funciones Especiales::               Funciones especiales.
* Funciones elípticas::  Funciones e integrales elípticas.
* Límites::              Cálculo de límites.
* Diferenciación::                   Cálculo diferencial.
* Integración::                      Cálculo integral.
* Ecuaciones::                         Definición y resolución de ecuaciones.
* Ecuaciones Diferenciales::           Definición y resolución de ecuaciones diferenciales.
* Métodos numéricos::              Integración numérica, transformadas de Fourier, etc.
* Arrays::                             Creación y manipulación de arrays.
* Matrices y Álgebra Lineal::        Operaciones matriciales.
* Afines::
* itensor::                            Manipulación indexada de tensores
* ctensor::                            Manipulación por componentes de tensores
* atensor::                            Manipulación algebraica de tensores
* Series::                             Series de potencias y de Taylor.
* Teoría de Números::  Teoría de números.
* Simetrías::
* Grupos::                             Álgebra abstracta.

Funcionalidades avanzadas y programación

* Entorno de Ejecución::      Personalización de Maxima.
* Miscelánea de opciones::    Opciones que afectan globalmente el comportamiento de Maxima.
* Reglas y patrones::           Patrones de definidos por el usuario y
                                reglas de simplificación.
* Listas::                      Manipulación de listas.
* Conjuntos::                   Operaciones con conjuntos.
* Definición de Funciones::   Programando funciones.
* Programación::              Programación en Maxima.
* Depurado::                    Depuración de fallos en programas Maxima.

Paquetes adicionales

* augmented_lagrangian::        Paquete augmented_lagrangian.
* bode::                        Gráficos de Bode.
* contrib_ode::                 Procedimientos adicionales para EDOs.
* descriptive::                 Estadística descriptiva.
* diag::                        Matrices de Jordan.
* distrib::                     Distribuciones de probabilidad.
* draw::                        Un interfaz Maxima-Gnuplot.
* dynamics::                    Gráficas de sistemas dinámicos y fractales.
* eval_string::                 Expresiones de Maxima en formato de cadena.
* f90::                         Traductor de Maxima fortran.
* ggf::                         Expresión general de sucesiones.
* grobner::                     Funciones para trabajar con bases de Groebner.
* impdiff::                     Derivadas implícitas.
* interpol::                    Interpolación.
* lbfgs::                       Paquete L-BFGS para minimización sin restricciones.
* lindstedt::                   Paquete Lindstedt.
* linearalgebra::               Funciones de álgebra lineal.
* lsquares::                    Mínimos cuadrados.
* makeOrders::                  Utilidad sobre polinomios.
* mnewton::                     Método de Newton.
* numericalio::                 Lectura y escritura de ficheros.
* opsubst::                     Utilidad para sustituciones.
* orthopoly::                   Polinomios ortogonales.
* plotdf::                      Gráficos de campos vectoriales.
* romberg::                     Integración numérica por el método de Romberg.
* simplex::                     Programación lineal.
* simplification::              Reglas y funciones de simplificación.
* solve_rec::                   Recurrencias lineales.
* stats::                       Inferencia estadística.
* stirling::                    Fórmula de Stirling.
* stringproc::                  Procesamiento de cadenas.
* unit::                        Unidades físicas y dimensiones.
* zeilberger::                  Funciones para series hipergeométricas.


Índice

* Índice de Funciones y Variables::  Índice.

 --- Listado detallado de los nodos ---

Introducción

* Introducción a Maxima::

Fallos

* Funciones y variables para la detección e informe de fallos::

Ayuda

* Lisp y Maxima::
* Recolector de basura::
* Documentación::
* Funciones y variables para la ayuda::

Línea de Comandos

* Introducción a la Línea de Comandos::
* Funciones y variables para  la Línea de Comandos::

Operadores

* n-arios::
* no-fijos::
* postfijos::
* prefijos::
* Operadores aritméticos::
* Operadores relacionales::
* Operadores generales::

Expresiones

* Introducción a las expresiones::
* Asignación::
* Expresiones complejas::
* Nombres y verbos::
* Identificadores::
* Desigualdades::
* Sintaxis::
* Funciones y variables para expresiones::

Simplificación

* Funciones y variables para simplificación::

Gráficos

* Funciones y variables para gráficos::

Lectura y escritura

* Comentarios::
* Archivos::
* Funciones y variables para lectura y escritura::

Aritmética de punto flotante

* Funciones y variables para la aritmética de punto flotante::

Contextos

* Funciones y variables para Contextos::

Polinomios

* Introducción a los polinomios::
* Funciones y variables para polinomios::

Constantes

* Funciones y variables para Constantes::

Logaritmos

* Funciones y variables para logaritmos::

Trigonometría

* Introducción a la trigonometría::
* Funciones y variables para trigonometría::

Funciones Especiales

* Introducción a las funciones especiales::
* Funciones y variables para las funciones especiales::

Funciones elípticas

* Introducción a las funciones e integrales elípticas::
* Funciones y variables para funciones elípticas::
* Funciones y variables para integrales elípticas::

Límites

* Funciones y variables para límites::

Diferenciación

* Funciones y variables para la diferenciación::

Integración

* Introducción a la integración::
* Funciones y variables para integración::

Ecuaciones

* Funciones y variable para las ecuaciones::

Ecuaciones Diferenciales

* Introducción a las ecuaciones diferenciales::
* Funciones y variables para ecuaciones diferenciales::

Métodos numéricos

* Introducción a los métodos numéricos::
* Series de Fourier::
* Funciones y variables para los métodos numéricos::
* Funciones y variables para las series de Fourier::

Arrays

* Funciones y variables para Arrays::

Matrices y Álgebra Lineal

* Introducción a las matrices y el álgebra lineal::
* Funciones y variables para las matrices y el álgebra lineal::

Afines

* Funciones y variables para Afines::

itensor

* Introducción a itensor::
* Funciones y variables para itensor::

ctensor

* Introducción a ctensor::
* Funciones y variables para ctensor::

atensor

* Introducción a atensor::
* Funciones y variables para atensor::

Series

* Introducción a las series::
* Funciones y variables para las series::

Teoría de Números

* Funciones y variables para teoría de números::

Simetrías

* Funciones y variables para simetrías::

Grupos

* Funciones y variables para grupos::

Entorno de Ejecución

* Introducción al entorno de ejecución::
* Interrupciones::
* Funciones y variables para el entorno de ejecución::

Miscelánea de opciones

* Introducción a la miscelánea de opciones::
* Share::
* Funciones y variables para la miscelánea de opciones::

Reglas y patrones

* Introducción a reglas y patrones::
* Funciones y variables sobre reglas y patrones::

Listas

* Introducción a las listas::
* Funciones y variables para listas::

Conjuntos

* Introducción a los conjuntos::
* Funciones y variables para los conjuntos::

Definición de Funciones

* Introducción a la definición de funciones::
* Funciones::
* Macros::
* Funciones y variables para la definición de funciones::

Programación

* Introducción a la programación::
* Funciones y variables para la programación::

Depurado

* Depuración del código fuente::
* Claves de depuración::
* Funciones y variables para depurado::

augmented_lagrangian

* Funciones y variables para augmented_lagrangian::

bode

* Funciones y variables para bode::

contrib_ode

* Introducción a contrib_ode::
* Funciones y variables para contrib_ode::
* Posibles mejoras a contrib_ode::
* Pruebas realizadas con contrib_ode::
* Referencias para contrib_ode::

descriptive

* Introducción a descriptive::
* Funciones y variables para el tratamiento de datos::
* Funciones y variables de valores descriptivos::
* Funciones y variables de valores descriptivos multivariantes::
* Funciones y variables para gráficos estadísticos::

diag

* Funciones y variables para diag::

distrib

* Introducción a distrib::
* Funciones y variables para distribuciones continuas::
* Funciones y variables para distribuciones discretas::

draw

* Introducción a draw::
* Funciones y variables para draw::
* Funciones y variables para picture::
* Funciones y variables para worldmap::

dynamics

* Introducción a dynamics::
* Funciones y variables para dynamics::

eval_string

* Funciones y variables para eval_string::

f90

* Funciones y variables para f90::

ggf

* Funciones y variables para ggf::

grobner

* Introducción a grobner::
* Funciones y variables para grobner::

impdiff

* Funciones y variables para impdiff::

interpol

* Introducción a interpol::
* Funciones y variables para interpol::

lbfgs

* Introducción a lbfgs::
* Funciones y variables para lbfgs::

lindstedt

* Funciones y variables para lindstedt::

linearalgebra

* Introducción a linearalgebra::
* Funciones y variables para linearalgebra::

lsquares

* Funciones y variables para lsquares::

makeOrders

* Funciones y variables para makeOrders::

mnewton

* Funciones y variables para mnewton::

numericalio

* Introducción a numericalio::
* Funciones y variables para numericalio::

opsubst

* Funciones y variables para opsubst::

orthopoly

* Introducción a polinomios ortogonales::
* Funciones y variables para polinomios ortogonales::

plotdf

* Funciones y variables para plotdf::

romberg

* Funciones y variables para romberg::

simplex

* Introducción a simplex::
* Funciones y variables para simplex::

simplification

* Introducción a simplification::
* Funciones y variables para simplification::

solve_rec

* Introducción a solve_rec::
* Funciones y variables para solve_rec::

stats

* Introducción a stats::
* Funciones y variables para inference_result::
* Funciones y variables para stats::
* Funciones y variables para distribuciones especiales::

stirling

* Funciones y variables para stirling::

stringproc

* Introducción al procesamiento de cadenas::
* Funciones y variables para entrada y salida::
* Funciones y variables para caracteres::
* Funciones y variables para cadenas::

unit

* Introducción a units::
* Funciones y variables para units::

zeilberger

* Introducción a zeilberger::
* Funciones y variables para zeilberger::


File: maxima.info,  Node: Introducción a Maxima,  Next: Detección e informe de fallos,  Prev: Top,  Up: Top

1 Introducción a Maxima
***********************

Se puede iniciar Maxima con el comando "maxima". Maxima desplegará
alguna información importante acerca de la versión que se está usando y
un prompt. Cada comando que vaya a ser ejecutado por Maxima debe
terminar con un punto y coma. Para finalizar una sesión en Maxima se
emplea el comando "quit();". A continuación se presenta un breve
ejemplo de sesión:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima puede buscar en las páginas info. La instrucción `describe'
mostrará el comando o comandos que contengan una cierta cadena. La
interrogación `?' (búsqueda exacta) y la doble interrogación `??'
(búsqueda aproximada) son abreviaturas de la instrucción `describe':

     (%i1) ?? integ
      0: Functions and Variables for Elliptic Integrals
      1: Functions and Variables for Integration
      2: Introduction to Elliptic Functions and Integrals
      3: Introduction to Integration
      4: askinteger  (Functions and Variables for Simplification)
      5: integerp  (Functions and Variables for Miscellaneous Options)
      6: integer_partitions  (Functions and Variables for Sets)
      7: integrate  (Functions and Variables for Integration)
      8: integrate_use_rootsof  (Functions and Variables for Integration)
      9: integration_constant_counter  (Functions and Variables for
         Integration)
      10: nonnegintegerp  (Functions and Variables for linearalgebra)
     Enter space-separated numbers, `all' or `none': 5 4

      -- Function: integerp (<expr>)
          Returns `true' if <expr> is a literal numeric integer, otherwise
          `false'.

          `integerp' returns false if its argument is a symbol, even if the
          argument is declared integer.

          Examples:

               (%i1) integerp (0);
               (%o1)                         true
               (%i2) integerp (1);
               (%o2)                         true
               (%i3) integerp (-17);
               (%o3)                         true
               (%i4) integerp (0.0);
               (%o4)                         false
               (%i5) integerp (1.0);
               (%o5)                         false
               (%i6) integerp (%pi);
               (%o6)                         false
               (%i7) integerp (n);
               (%o7)                         false
               (%i8) declare (n, integer);
               (%o8)                         done
               (%i9) integerp (n);
               (%o9)                         false

      -- Function: askinteger (<expr>, integer)
      -- Function: askinteger (<expr>)
      -- Function: askinteger (<expr>, even)
      -- Function: askinteger (<expr>, odd)
          `askinteger (<expr>, integer)' attempts to determine from the
          `assume' database whether <expr> is an integer.  `askinteger'
          prompts the user if it cannot tell otherwise, and attempt to
          install the information in the database if possible.  `askinteger
          (<expr>)' is equivalent to `askinteger (<expr>, integer)'.

          `askinteger (<expr>, even)' and `askinteger (<expr>, odd)'
          likewise attempt to determine if <expr> is an even integer or odd
          integer, respectively.

     (%o1)                                true

   Para usar un resultado de forma posterior, usted puede asignar dicho
resultado a una variable o referirse a él por medio de la etiqueta
asociada (%i* o %o*). Adicionalmente  puede usar `%' para referirse al
último resultado obtenido.

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima manipula sin ningún problema números complejos y constantes
numéricas:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima puede hacer derivadas  e integrales:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima puede resolver sistemas de ecuaciones lineales y cúbicas:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima puede resolver sistemas de ecuaciones no lineales. Tenga en
cuenta que si usted no desea que el resultado sea impreso, puede
finalizar el comando con `$' en vez de `;'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Bajo un sistema X window, (es decir que poseea interfaz gráfica),
Maxima puede generar gráficas  de una o más funciones:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12],
           [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Detección e informe de fallos,  Next: Ayuda,  Prev: Introducción a Maxima,  Up: Top

2 Detección e informe de fallos
*******************************

* Menu:

* Funciones y variables para la detección e informe de fallos::


File: maxima.info,  Node: Funciones y variables para la detección e informe de fallos,  Up: Detección e informe de fallos

2.1 Funciones y variables para la detección e informe de fallos
===============================================================

 -- Función: run_testsuite ()
 -- Función: run_testsuite (<boolean>)
 -- Función: run_testsuite (<boolean>, <boolean>)
 -- Función: run_testsuite (<boolean>, <boolean>, <list>)
     Ejecuta el conjunto de pruebas de Maxima. Los tests que producen
     las respuestas deseadas son considerados como "pruebas superadas",
     como los tests que no producen las respuestas deseadas, son
     marcados como fallos conocidos.

     `run_testsuite ()' muestra sólo los test que no pasaron la prueba.

     `run_testsuite (true)' muestra los tests que son marcados como
     fallos conocidos, además de fallos.

     `run_testsuite (true, true)' muestra todos los tests.

     Si se incluye el tercer argumento opcional, se ejecutará una parte
     de los tests.  Los tests a ejecutar se especifican formando una
     lista con los nombres de los mismos. La lista completa de tests
     está en `testsuite_files'.

     `run_testsuite' cambia el entorno de Maxima.  Típicamente un
     script de test ejecuta `kill' para establecer un entorno conocido
     (llámese uno sin funciones ni variables definidas por el usuario)
     y entonces define una serie de funciones y variables apropiadas
     para el test.

     `run_testsuite' retorna `done'.

 -- Variable opcional: testsuite_files
     `testsuite_files' es el conjunto de tests a ejecutar por
     `run_testsuite'. Se trata de una lista con los nombres de los
     ficheros que contienen los tests a ejecutar. Si se sabe que alguno
     de los tests de un fichero falla, entonces en lugar de listar el
     nombre del fichero, se utiliza una lista que contiene el nombre
     del fichero y los números de los tests que fallan.

     Por ejemplo, esta es una parte de los tests por defecto:

           ["rtest13s", ["rtest14", 57, 63]]

     Con esto se especifica que el conjunto de tests está formado por
     los ficheros "rtest13s"  y "rtest14", pero que "rtest14" contiene
     dos tests que se sabe que causan fallos, el 57 y el 63.

 -- Función: bug_report ()
     Imprime las versiones de Maxima y de Lisp y proporciona un enlace
     a la página web sobre informe de fallos del proyecto Maxima.  La
     información respecto a las versiones es la misma que reporta la
     función `build_info'.

     Cuando se informa sobre un fallo, es de gran ayuda que se copie la
     información relacionada con la versión de Maxima y de Lisp usada,
     dentro del propio informe.

     `bug_report' retorna una cadena vacía `""'.

 -- Función: build_info ()
     Imprime un resumen de los parámetros que se usaron para construir
     la versión de Maxima que se está usando.

     `build_info' retorna una cadena vacía  `""'.


File: maxima.info,  Node: Ayuda,  Next: Línea de Comandos,  Prev: Detección e informe de fallos,  Up: Top

3 Ayuda
*******

* Menu:

* Lisp y Maxima::
* Recolector de basura::
* Documentación::
* Funciones y variables para la ayuda::


File: maxima.info,  Node: Lisp y Maxima,  Next: Recolector de basura,  Prev: Ayuda,  Up: Ayuda

3.1 Lisp y Maxima
=================

Maxima fue escrito en Lisp, y es muy fácil tener acceso a funciones y
variables Lisp desde Maxima y viceversa.  Los símbolos Lisp y los
símblos Maxima están claramente diferenciados por medio de una
convención de nombres.  Un símblo Lisp el cual comienza con un signo
pesos `$' corresponde a un símbolo Maxima sin el signo pesos.  Un
símbolo Maxima el cual comienza con un signo de cierre de interrogación
`?' corresponde a un símbolo Lisp sin dicho signo.  Por ejemplo, el
símbolo Maxima `foo' corresponde a el símbolo Lisp `$foo', mientras que
el símbolo Maxima `?foo' corresponde a el símbolo Lisp `foo', tenga en
cuenta que `?foo' esta escrito sin espacio entre `?' y `foo'; de otra
manera se estaría invocando a `describe ("foo")'.

   El guión `-', asterisco `*', u otros carácteres especiales en
símbolos Lisp deben ser escritos mediante un backslash `\' si aparecen
en código Maxima.  Por ejemplo, el identificador Lisp `*foo-bar*' se
debe escribir `?\*foo\-bar\*' en Maxima.

   Se puede ejecutar código Lisp desde una sesión de Maxima.  Una línea
Lisp (que contenga una o más formas) puede ser ejecutada por medio de
un comando especial `:lisp'. Por ejemplo,

     (%i1) :lisp (foo $x $y)

se llama a la función Lisp `foo' con variables Maxima `x' y `y' como
argumentos.  La instrucción `:lisp' puede aparecer en el prompt
interactivo o en un archivo que sea procesado por `batch' o `demo',
pero no en un archivo que sea procesado por `load', `batchload',
`translate_file' o `compile_file'.

   La función `to_lisp()' abre una sesión interactiva con el interprete
Lisp.  Escribiendo `(to-maxima)' se cierra la sesión con Lisp y se
retorna a Maxima.

   Las funciones y variables Lisp las cuales esten para ser visibles en
Maxima como funciones y variables con nombres oridinarios (sin una
puntuación especial), deben tener nombres tipo Lisp que comiencen con
el signo pesos `$'.

   Maxima es case-sensitive, distingue entre letras minúsculas y
mayúsculas en identificadores, mientras que Lisp no.  Existen algunas
reglas que gobiernan la traducción de nombres entre Lisp y Maxima.

  1. Un identificador Lisp que no se encuentra encerrado en barras
     verticales corresponde a un identificador Maxima en minúscula.
     Que el idenficador Lisp esté en mayúscula, minúscula o una
     combinación de ambas, no afecta en nada.  Por ejemplo, los
     identificadores Lisp `$foo', `$FOO', y `$Foo', todos corresponden
     al identificador Maxima `foo'.

  2. Un identificador Lisp el cual se encuentre todo en mayúscula o
     todo en minúscula y encerrado entre barras verticales corresponde
     a un identicador Maxima con el caso contrario.  Esto es, de
     mayúsculas cambia a minúsculas y de minúsculas cambia a mayúsculas.
     E.g., el identificador Lisp `|$FOO|' y `|$foo|' corresponden los
     identificadores Maxima `foo' y `FOO', respectivamente.

  3. Un identificador Lisp el cual esta escrito mezclando letras
     mayúsculas y minúsculas y se encuentra entre barras verticales
     corresponde a un identificador Maxima con la misma escritura.
     E.g., el identificador Lisp `|$Foo|' corresponde a el
     identificador Maxima `Foo'.

   La macro Lisp `#$' permite el uso de expresiones Maxima dentro de
código Lisp. `#$<expr>$' extiende a una expresión Lisp equivalente a la
expresión Maxima <expr>.

     (msetq $foo #$[x, y]$)

Esto tiene el mismo efecto que:

     (%i1) foo: [x, y];

La función Lisp `displa' imprime una expresión en formato Maxima.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Las funciones definidas en Maxima no son funciones Lisp ordinarias.
La función Lisp `mfuncall' llama a una función Maxima.  Por ejemplo:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Algunas funciones Lisp son compartidas en el paquete Maxima, las
cuales se listan a continuación:

   `complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', y `gcd'.


File: maxima.info,  Node: Recolector de basura,  Next: Documentación,  Prev: Lisp y Maxima,  Up: Ayuda

3.2 Recolector de basura
========================

La computación simbólica tiende a crear una buena cantidad de basura, y
un manejo efectivo de esto puede ser crucial para el término exitoso de
algunos programas.

   Bajo GCL (GNU Common Lisp), en los sistemas UNIX donde la llamada al
sistema mprotect esta disponible (incluyendo SUN OS 4.0 y algunas
variantes de BSD) un recolector de basura estratificado está
disponible. Estos límites de colección para memoria virtual, han sido
escritos recientemente. Mire la documentación de GCL bajo ALLOCATE y
GBC.  En el nivel lisp haga (setq si::*notify-gbc* t) eso le ayudará a
determinar cuales áreas necesitan más espacio.


File: maxima.info,  Node: Documentación,  Next: Funciones y variables para la ayuda,  Prev: Recolector de basura,  Up: Ayuda

3.3 Documentación
=================

El manual en línea del usuario de Maxima puede ser visto en diferentes
formas.  Desde el prompt interactivo de Maxima, el manual de usuario es
visto como texto plano por medio del comando  `?' (i.e., la función
`describe').  El manual de usuario también puede ser visto como
hipertexto tipo `info' por medio del programa `info' y como una página
web a través de cualquier navegador.

   El comando `example' muestra ejemplos para muchas funciones Maxima.
Por ejemplo:

     (%i1) example (integrate);

   produce:

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   y salidas adicionales.


File: maxima.info,  Node: Funciones y variables para la ayuda,  Prev: Documentación,  Up: Ayuda

3.4 Funciones y variables para la ayuda
=======================================

 -- Función: demo (<archivo>)
     Evalua las expresiones Maxima contenidas en <archivo> y muestra
     los resultados.  `demo' hace pausas después de evaluar  cada
     expresión y continua después de que el usuario ingrese un retorno
     de carro.  (Si se ejecuta en Xmaxima, `demo' puede que necesite un
     punto y coma `;' a continuación del retorno de carro.)

     `demo' busca la lista de directorios `file_search_demo' para
     encontrar `archivo'.  Si el archivo tiene el sufijo `dem', el
     sufijo puede ser omitido.  Ver también `file_search'.

     `demo' evalua su argumento.  `demo' retorna el nombre del archivo
     demostración.

     Ejemplo:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)

 -- Función: describe (<string>)
 -- Función: describe (<string>, exact)
 -- Función: describe (<string>, inexact)
     La sentencia `describe(<string>)' equivale a `describe(<string>,
     exact)'.

     La sentencia `describe(<string>, exact)' encuentra el elemento, si
     existe, cuyo título coincide exactamente con <string> (ignorando
     la diferencia entre mayúsculas y minúsculas).

     La sentencia `describe(<string>, inexact)' encuentra todos los
     elementos documentados que contengan <string> en sus títulos.

     Si hay más de una opción, Maxima preguntará al usuario para que
     seleccione las opciones que desee consultar.

     La sentencia `? foo' (con espacio entre `?' y `foo') equivale a
     `describe("foo", exact)', mientras que `?? foo' equivale a
     `describe("foo", inexact)'.

     `describe ("", inexact)' produce una lista de todos los temas
     documentados en el manual en línea.

     `describe' no evalúa su argumento. La función `describe' devuelve
     `true' si encuentra la documentación solicitada y `false' en caso
     contrario.

     Véase también `Documentación'.

     Ejemplo:

          (%i1) ?? integ
           0: Functions and Variables for Elliptic Integrals
           1: Functions and Variables for Integration
           2: Introduction to Elliptic Functions and Integrals
           3: Introduction to Integration
           4: askinteger  (Functions and Variables for Simplification)
           5: integerp  (Functions and Variables for Miscellaneous Options)
           6: integer_partitions  (Functions and Variables for Sets)
           7: integrate  (Functions and Variables for Integration)
           8: integrate_use_rootsof  (Functions and Variables for
              Integration)
           9: integration_constant_counter  (Functions and Variables for
              Integration)
           10: nonnegintegerp  (Functions and Variables for linearalgebra)
          Enter space-separated numbers, `all' or `none': 7 8

           -- Function: integrate (<expr>, <x>)
           -- Function: integrate (<expr>, <x>, <a>, <b>)
               Attempts to symbolically compute the integral of <expr> with
               respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
               integral, while `integrate (<expr>, <x>, <a>, <b>)' is a
               definite integral, [...]

           -- Option variable: integrate_use_rootsof
               Default value: `false'

               When `integrate_use_rootsof' is `true' and the denominator of
               a rational function cannot be factored, `integrate' returns
               the integral in a form which is a sum over the roots (not yet
               known) of the denominator.
               [...]

     En este ejemplo fueron seleccionadas las opciones 7 y 8 (la salida
     ha sido recortada, tal como indica `[...]').  Todas o ninguna de
     las opciones pueden ser seleccionadas escribiendo `all' o `none',
     las cuales pueden ser abreviadas por `a' o `n', respectivamente.


 -- Función: example (<tema>)
 -- Función: example ()
     `example (<tema>)' mostrará algunos ejemplos de <tema>, el cual es
     un símbolo (no una cadena).  La mayoría de los temas son nombres
     de funciones.  `example ()' retorna la lista de todos los temas
     conocidos.

     El nombre del archivo que contiene los ejemplos esta dado por la
     variable global `manual_demo', cuyo valor por defecto es
     `"manual.demo"'.

     `example' no evalua su argumento.  `example' retorna `done' a
     menos que haya un error o que no haya argumento, en cuyo caso
     `example' devolverá la lista de todos los temas conocidos.

     Ejemplos:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done



File: maxima.info,  Node: Línea de Comandos,  Next: Operadores,  Prev: Ayuda,  Up: Top

4 Línea de Comandos
*******************

* Menu:

* Introducción a la Línea de Comandos::
* Funciones y variables para  la Línea de Comandos::


File: maxima.info,  Node: Introducción a la Línea de Comandos,  Next: Funciones y variables para la Línea de Comandos,  Prev: Línea de Comandos,  Up: Línea de Comandos

4.1 Introducción a la Línea de Comandos
=======================================

 -- Operador: '
     El operador comilla simple `'' evita la evaluación.

     Aplicado a un símbolo, la comilla simple evita la evaluación del
     símbolo.

     Aplicado a la llamada de una función, la comilla simple evita la
     evaluación de la función llamada, aunque los argumentos de la
     función son evaluados (siempre y cuando la evaluación no se evite
     de otra manera).  El resultado es una forma de nombre de la
     función llamada.

     Aplicado a una expresión con paréntesis, la comilla simple evita
     la evaluación de todos los símbolos y llamadas a funciones que
     hayan en la expresión.  E.g., `'(f(x))' significa que no se evalua
     la expresión `f(x)'.  `'f(x)' (con la comilla simple aplicada a
     `f' en cambio de a `f(x)') significa el retorno de la forma de
     nombre de `f' aplicada a `[x]'.

     La comilla simple no evita la simplificación.

     Cuando el interruptor global `noundisp' es `true', los nombres se
     muestran con una comilla simple.  Este interruptor siempre tiene
     como valor `true' cuando se muestran definiciones de funciones.

     Ver también los operadores comilla-comilla `''' y `nouns'.

     Ejemplos:

     Aplicado a un símbolo, la comilla simple evita la evaluación del
     símbolo.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Aplicado a la llamada de una función, la comilla simple evita la
     evaluación de la función llamada, aunque los argumentos de la
     función son evaluados (siempre y cuando la evaluación no se evite
     de otra manera).  El resultado es una forma de nombre de la
     función llamada.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Aplicado a una expresión con paréntesis, la comilla simple evita
     la evaluación de todos los símbolos y llamadas a funciones que
     hayan en la expresión.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     La comilla simple no evita la simplificación.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1


 -- Operador: "
     El operador comilla-comilla `''' (dos comillas simples) modifica
     la evaluación en las expresiones de entrada.

     Aplicado a cualquier expresión general <expr>, las dos comillas
     simples hacen que el valor de <expr> sea sustituido por <expr> en
     la expresión de entrada.

     Aplicado al operador de una expresión, el operador comilla-comilla
     hace que el operador pase de ser un nombre a ser un verbo, a menos
     que ya sea un verbo.

     El operador comilla-comilla es aplicado por el analizador
     sintáctico de entrada; no se almacena como una parte de la
     expresión de entrada analizada.  Este operador se aplica siempre
     tan pronto como es detectado y no puede ser comentado con una
     comilla simple. De esta manera, el operador comilla-comilla
     provoca la evaluación de una expresión cuando ésta no estaba
     previsto que fuese evaluada, como en la definición de funciones,
     expresiones lambda y expresiones comentadas con una comilla simple
     `''.

     El operador comilla-comilla es reconocido tanto por `batch' como
     por `load'.

     Véanse también el operador comilla simple `'' y `nouns'.

     Ejemplos:

     Aplicado a cualquier expresión general <expr>, las dos comillas
     simples hacen que el valor de <expr> sea sustituido por <expr> en
     la expresión de entrada.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Aplicado al operador de una expresión, el operador comilla-comilla
     hace que el operador pase de ser un nombre a ser un verbo, a menos
     que ya sea un verbo.

          (%i1) sin (1);
          (%o1)                        sin(1)
          (%i2) ''sin (1);
          (%o2)                    0.8414709848079
          (%i3) declare (foo, noun);
          (%o3)                         done
          (%i4) foo (x) := x - 1729;
          (%o4)                 ''foo(x) := x - 1729
          (%i5) foo (100);
          (%o5)                       foo(100)
          (%i6) ''foo (100);
          (%o6)                        - 1629

     El operador comilla-comilla es aplicado por el analizador
     sintáctico de entrada; no se almacena como una parte de la
     expresión de entrada analizada.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     El operador comilla-comilla provoca la evaluación de una expresión
     cuando ésta no estaba previsto que fuese evaluada, como en la
     definición de funciones, expresiones lambda y expresiones
     comentadas con una comilla simple `''.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i4) integrate (log (x), x);
          (%o4)                     x log(x) - x
          (%i5) foo_2a (x) := ''%;
          (%o5)               foo_2a(x) := x log(x) - x
          (%i6) foo_2b (x) := %;
          (%o6)                    foo_2b(x) := %
          (%i7) dispfun (foo_2a, foo_2b);
          (%t7)               foo_2a(x) := x log(x) - x

          (%t8)                    foo_2b(x) := %

          (%o8)                      [%t7, %t8]
          (%i8) F : lambda ([u], diff (sin (u), u));
          (%o8)             lambda([u], diff(sin(u), u))
          (%i9) G : lambda ([u], ''(diff (sin (u), u)));
          (%o9)                  lambda([u], cos(u))
          (%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o11)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1



File: maxima.info,  Node: Funciones y variables para la Línea de Comandos,  Prev: Introducción a la Línea de Comandos,  Up: Línea de Comandos

4.2 Funciones y variables para la Línea de Comandos
===================================================

 -- Función: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provee un nombre alternativo para una (bien sea definida por el
     usuario o por el sistema) función, variable, arreglo, etc.
     Cualquier número par de argumentos puede ser usado.


 -- Variable opcional: debugmode
     Valor por defecto: `false'

     Cuando en Maxima ocurre un error, Maxima inicializará el depurador
     si `debugmode' tiene el valor `true'.  El usuario puede ingresar
     comandos para examinar la pila de llamadas, los puntos de
     interrupción; en pocas palabras ir a través del código de Maxima.
     Vea `debugging' para una lista de los comandos del depurador.

     Habilitando `debugmode' no se capturarán los errores tipo Lisp.


 -- Función: ev (<expr>, <arg_1>, ..., <arg_n>)
     Evalua la expresión <expr> en el entorno especificado por los
     argumentos <arg_1>, ..., <arg_n>.  Los argumentos son
     interruptores (Variables Booleanas), variables de asignación,
     ecuaciones y funciones.  `ev' retorna el resultado (otra
     expresión) de la evaluación.

     La evaluación se realiza por etapas, como sigue:

       1. Primero se configura el entorno de acuerdo a los argumentos
          los cuales pueden ser algunos o todos de la siguiente lista:

             * `simp' causa que <expr> sea simplificada sin importar el
               valor de la variable interruptor `simp' la cual inhibe
               la simplificación cuando su valor es `false'.

             * `noeval' suprime la fase de evaluación de `ev' (Vea el
               paso (4) más adelante).  Esto es muy útil en conjunción
               con otras variables interruptor y causan en <expr> que
               sea resimplificada sin ser reevaluada.

             * `nouns' causa la evaluación de las formas nominales
               (típicamente funciones sin evaluar tales como
               `'integrate' or `'diff') en `expr'.

             * `expand' causa expansión.

             * `expand (<m>, <n>)' causa expansión, asignando los
               valores de `maxposex' y `maxnegex' a <m> y <n>,
               respectivamente.

             * `detout' hace que cualesquiera matrices inversas
               calculadas en <expr> conserven su determinante fuera de
               la inversa, en vez de que divida a cada elemento.

             * `diff' realiza todas las diferenciaciones indicadas en
               <expr>.

             * `derivlist (<x>, <y>, <z>, ...)' realiza sólo las
               diferenciaciones con respecto a las variables indicadas.

             * `float' provoca la conversión de los números racionales
               no-enteros a números decimales de coma flotante.

             * `numer' causa que algunas funciones matemáticas
               (incluyendo potenciación) con argumentos numéricos sean
               evaluados como punto flotante. Esto causa que las
               variables en <expr> las cuales hayan sido declaradas
               como variables numéricas sean reemplazadas por sus
               respectivos valores. Esto también configura la variable
               interruptor `float' a `true'.

             * `pred' provoca la evaluación de los predicados
               (expresiones las cuales se evaluan a `true' o `false').

             * `eval' provoca una post-evaluación extra de <expr>
               (véase el paso (5) más adelante), pudiendo aparecer
               `eval' varias veces; por cada aparición de `eval', la
               expresión es reevaluada.

             * `A', donde `A' es un átomo declarado como una variable
               de tipo interruptor, (Vea `evflag') causa que `A' tenga
               como valor `true' durante la evaluación de <expr>.

             * `V: expresion' (o alternativamente `V=expresion') causa
               que `V' tenga el valor de `expresion' durante la
               evaluación de <expr>. Notese que si `V' es una opción
               Maxima, entonces `expresion' se usa como su valor
               durante la evaluación de <expr>. Si más de un argumento
               de `ev' es de este tipo entonces el vínculo se hace en
               paralelo. Si `V' es una expresión no atómica entonces se
               hace una sustitución más que un vínculo.

             * `F' donde `F', un nombre de función, ha sido declarado
               para ser una función de evaluación (Vea `evfun') causa
               que `F' sea aplicada a <expr>.

             * Cualquier otro nombre de función (e.g., `sum') causa la
               evaluación de las ocurrencias de esos nombres en `expr'
               como si ellos fueran verbos.

             * En adición de que una función ocurra en <expr> (digamos
               `F(x)') puede ser definida localmente para el propósito
               de esta evaluación de <expr> pasando `F(x) := expresion'
               como un argumento a `ev'.

             * Si un átomo no mencionado anteriormente o una variable o
               expresión con subíndices fueran pasadas como un
               argumento, esta es evaluada y si el resultado es una
               ecuación o una asignación entonces el vínculo o
               sustitución se llevará a cabo. Si el resultado es una
               lista entonces los miembros de la lista tratados como si
               ellos fueran argumentos adicionales pasados a `ev'. Esto
               permite que una lista de argumentos sea pasada (e.g.,
               `[X=1, Y=A**2]') o una lista de nombres de ecuaciones
               (e.g., `[%t1, %t2]' donde `%t1' y `%t2' son ecuaciones)
               tal como lo que es retornado por `solve'.

          Los argumentos de `ev' pueden ser pasados en cualquier orden
          con excepción de la sustitución de ecuaciones las cuales son
          manipuladas en secuencia, de izquierda a derecha y las
          funciones de evaluación las cuales son compuestas, e.g., `ev
          (<expr>, ratsimp, realpart)' es manipulada como `realpart
          (ratsimp (<expr>))'.

          Los interruptores `simp', `numer', `float' y `pred' pueden
          también ser configurados localmente en una sentencia block, o
          globalmente en Maxima para que su efecto permanezca hasta que
          sean reconfiguradas.

          Si <expr> es una Expresión Racional Canónica (CRE, por sus
          siglas en inglés), entonces la expresión retornada por `ev'
          es también de tipo CRE, siempre que los interruptores `numer'
          y `float' no sean `true'.

       2. Durante el paso (1), se fabrica una lista de las variables
          que no contienen subíndices que aparecen en el lado izquierdo
          de las ecuaciones en los argumentos o en el valor de algunos
          argumentos si el valor es una ecuación. Las variables
          (variables que contienen subíndices las cuales no tienen
          asociado un arreglo de funciones como también las variables
          que no contienen subíndices) en la expresión <expr> son
          reemplazadas por sus valores globales, excepto por aquellos
          que aparezcan en esa lista.  Usualmente, <expr> es sólo una
          etiqueta o un `%' (como en `%i2' en el ejemplo de más abajo)
          así que este paso simplemente recupera la expresión a la que
          hace referencia la etiqueta y así `ev' puede trabajarla.

       3. Si algunas sustituciones son indicadas por los argumentos,
          ellas serán llevadas a cabo ahora.

       4. La expresión resultante es también reevaluada (a menos que
          uno de los argumentos fuese `noeval') y simplificada de
          acuerdo a los argumentos. Notese que cualquier llamada a una
          función en <expr> será llevada a cabo después de que las
          variables sean evaluadas en ella y que `ev(F(x))' pueda
          comportarse como `F(ev(x))'.

       5. Por cada aparición de `eval' en los argumentos, se repetirán
          los pasos (3) y (4).

     Ejemplos

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     Una sintaxis alternativa de alto nivel ha sido proveida para `ev',
     por medio de la cual uno puede escribir solamente sus argumentos,
     sin el comando `ev()'. Esto es, una forma sencilla de escritura:

          <expr>, <arg_1>, ..., <arg_n>

     Esto no es permitido como parte de otra expresión , e.g., en
     funciones, sentencias block, etc.

     Nótese el proceso de vínculo en paralelo en el siguiente ejemplo:

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solución

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Propiedad: evflag
     Cuando un símbolo <x> goza de la propiedad `evflag', las
     expresiones `ev(<expr>, <x>)' y `<expr>, <x>' (en modo
     interactivo) equivalen a `ev(<expr>, <x> = true)'.  Esto es, a <x>
     se le asigna `true' al tiempo que se evalúa <expr>.

     La expresión `declare(<x>, evflag)' dota a la variable <x> de la
     propiedad `evflag'.

     Los interruptores que tienen la propiedad `evflag' son:

     `algebraic', `cauchysum', `demoivre', `dotscrules', `%emode',
     `%enumer', `exponentialize', `exptisolate', `factorflag', `float',
     `halfangles', `infeval', `isolate_wrt_times', `keepfloat',
     `letrat', `listarith', `logabs', `logarc', `logexpand',
     `lognegint', `lognumer', `m1pbranch', `numer_pbranch',
     `programmode', `radexpand', `ratalgdenom', `ratfac', `ratmx',
     `ratsimpexpons', `simp', `simpsum', `sumexpand', y `trigexpand'.

     Ejemplos:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then YES else NO;
          (%o11)                         NO
          (%i12) if aa = true then YES else NO, aa;
          (%o12)                         YES


 -- Propiedad: evfun
     Cuando la función <F> goza de la propiedad `evfun', las
     expresiones `ev(<expr>, <F>)' y `<expr>, <F>' (en modo
     interactivo) equivalen a `<F>(ev(<expr>))'.

     Si se especifican dos o más funciones, <F>, <G>, etc., como
     poseedoras de la propiedad `evfun', éstas se aplican en el mismo
     orden en el que han sido especificadas como tales.

     La expresión `declare(<F>, evfun)' dota a la función  <F> de la
     propiedad `evfun'.

     Las funciones que tienen la propiedad `evfun' por defecto son:

     `bfloat', `factor', `fullratsimp', `logcontract', `polarform',
     `radcan', `ratexpand', `ratsimp', `rectform', `rootscontract',
     `trigexpand', y `trigreduce'.

     Ejemplos:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))


 -- Variable opcional: infeval
     Habilita el modo de "evaluación infinita". `ev' repetidamente
     evalua una expresión hasta que se interrumpa la acción. Para
     prevenir que una variable, digamos `X', sea evaluada sin parar en
     este modo, simplemente incluya `X='X' como argumento de `ev'.
     Esta claro que expresiones como: `ev (X, X=X+1, infeval)'
     generarán un bucle infinito.

 -- Función: kill (<a_1>, ..., <a_n>)
 -- Función: kill (labels)
 -- Función: kill (inlabels, outlabels, linelabels)
 -- Función: kill (<n>)
 -- Función: kill ([<m>, <n>])
 -- Función: kill (values, functions, arrays, ...)
 -- Función: kill (all)
 -- Función: kill (allbut (<a_1>, ..., <a_n>))
     Elimina todas las asignaciones (valor, función, arreglo o regla)
     hechas a los argumentos <a_1>, ..., <a_n>.  Un argumento <a_k>
     puede ser un símbolo o el elemento de un array. Si <a_k> es
     elemento de un array, `kill' elimina la asignación hecha a este
     elemento sin afectar al resto del array.

     Se reconocen varios argumentos especiales.  Se pueden combinar
     diferentes clases de argumentos, como por ejemplo, `kill
     (inlabels, functions, allbut (foo, bar))'.

     La instrucción `kill (labels)' borra todas las asignaciones
     asociadas a las etiquetas de entrada, de salida e intermedias
     creadas hasta el momento. La instrucción `kill (inlabels)' elimina
     únicamente las asignaciones de las etiquetas de entrada que
     comienzan con el valor actual de `inchar'. Del mismo modo, `kill
     (outlabels)' elimina únicamente las asignaciones de las etiquetas
     de salida que comienzan con el valor actual de `outchar'.
     Finalmente, `kill (linelabels)' elimina únicamente las asignaciones
     de las etiquetas de las expresiones intermedias que comienzan con
     el valor actual de `linechar'.

     La instrucción `kill (<n>)', siendo <n> un entero, elimina las
     asignaciones de las últimas <n> etiquetas, tanto de entrada como
     de salida.

     La instrucción `kill ([<m>, <n>])' elimina las asignaciones hechas
     a las etiquetas de entrada y salida desde la <m> hasta la<n>.

     La instrucción `kill (<infolist>)', siendo <infolist> cualquier
     elemento de `infolists' (como `values', `functions' o `arrays'),
     elimina todas las asignaciones hechas a los elementos de
     <infolist>. Véase también `infolists'.

     La instrucción `kill (all)' elimina todas las asignaciones de
     todas las variables, pero no reinicia las variables globales a sus
     valores por defecto. Véase también `reset'.

     La instrucción `kill (allbut (<a_1>, ..., <a_n>))' elimina las
     asignaciones hechas a todas las variables, excepto a <a_1>, ...,
     <a_n>; la instrucción `kill (allbut (<infolist>))' elimina todas
     las asignaciones, excepto las de los elementos de <infolist>,
     pudiendo ser <infolist> igual a `values', `functions', `arrays',
     etc.

     La memoria reservada para una asignación no se libera hasta que no
     se vacíen todos los símbolos asociados con esta asignación; por
     ejemplo, para liberar la memoria del valor de un símbolo es
     necesario eliminar tanto la asignación de la etiqueta de salida
     que muestra el resultado, como la del propio símbolo.

     La función `kill' no evalua sus argumentos.  El operador
     comilla-comilla, `''', obliga a que se realice la evaluación.

     La llamada `kill (<symbol>)' elimina todas las propiedades de
     <symbol>.  Por el contrario, `remvalue', `remfunction', `remarray'
     y `remrule' eliminan propiedades específicas.

     `kill' siempre devuelve `done', incluso cuando alguno de sus
     argumentos carecía de asignación previa.


 -- Función: labels (<symbol>)
 -- Variable del sistema: labels
     Retorna la lista de etiquetas de entrada, salida o de expresiones
     intermedias las cuales empiezan con <symbol>.  Típicamente
     <symbol> es el valor de las variables `inchar', `outchar' o
     `linechar'.  El caractér de etiqueta puede ser pasado con o sin
     signo de porcentaje, así, por ejemplo, `i' y `%i' producen el
     mismo resultado.

     Si ninguna etiqueta empieza con <symbol>, `labels' retorna a una
     lista vacía.

     La función `labels' no evalua su argumento.  El operador
     comilla-comilla, `''', obliga a que se realice la evaluación.  Por
     ejemplo, `labels (''inchar)' devuelve las etiquetas de entrada que
     empiezan con el caractér de etiqueta de entrada actual.

     La variable `labels' es una lista de las etiquetas de entrada,
     salida y expresiones intermedias, incluyendo todas las etiquetas
     anteriores en el caso de que `inchar', `outchar' o `linechar'
     hayan sido redefinidas.

     Por defecto, Maxima muestra el resultado de cada expresión
     introducida por el usuario, asignando al resultado una etiqueta de
     salida.  La salida (es decir el resultado) puede ser suprimida
     terminando la expresión de entrada con un `$' (signo de dólar) en
     vez de un `;' (punto y coma).  En este caso, se crea la etiqueta
     de salida y se le asigna el resultado, aunque éste no se muestre;
     aún así, la etiqueta puede ser referenciada de la misma forma que
     se hace con aquéllas cuyos resultados sí son mostrados.

     Véanse también: `%', `%%' y `%th'.

     Las etiquetas de expresiones intermedias pueden ser generadas por
     algunas funciones. El interruptor `programmode' controla si
     `solve' y algunas otras funciones generan etiquetas de expresiones
     intermedias en vez de retornar una lista de expresiones.  Algunas
     otras funciones, tales como `ldisplay', siempre generan etiquetas
     de expresiones intermedias.

     Véase también: `inchar', `outchar', `linechar' y `infolists'.


 -- Variable del sistema: linenum
     El número de la línea del par de expresiones de entrada y salida
     actuales.

 -- Variable del sistema: myoptions
     Valor por defecto: `[]'

     `myoptions' es la lista de todas las opciones que nunca fueron
     reconfiguradas por el usuario, aunque éstas hayan sido
     reconfiguradas a su valor por defecto.


 -- Variable opcional: nolabels
     Valor por defecto: `false'

     Cuando `nolabels' vale `true', las etiquetas de entrada y salida
     (`%i' y `%o', respectivamente) son mostradas, pero a éstas no se
     les asignan los resultados; además, las etiquetas no se incorporan
     a la lista `labels'.  Puesto que a las etiquetas no se les asignan
     resultados, el colector de basura puede recuperar la memoria
     ocupada por éstos.

     En el caso contrario, a las etiquetas de entrada y salida se les
     asignan los resultados correspondientes y son añadidas a la lista
     `labels'.

     Las etiquetas de expresiones intermedias (`%t') no se ven
     afectadas por la variable `nolabels'; independientemente de que
     `nolabels' valga `true' o `false', a las etiquetas de expresiones
     intermedias se les asignan siempre valores, además de ser añadidas
     a la lista `labels'.

     Véanse también `batch', `batchload' y `labels'.


 -- Variable opcional: optionset
     Valor por defecto: `false'

     Cuando `optionset' tiene como valor `true', Maxima imprime un
     mensaje cada vez que una opción de Maxima es reconfigurada. Esto es
     muy útil si el usuario duda con frecuencia de la correctitud de
     alguna opción y quiere estar seguro de la variable a la que él
     asignó un valor fue verdaramente una variable opción (o
     interruptor).


 -- Función: playback ()
 -- Función: playback (<n>)
 -- Función: playback ([<m>, <n>])
 -- Función: playback ([<m>])
 -- Función: playback (input)
 -- Función: playback (slow)
 -- Función: playback (time)
 -- Función: playback (grind)
     Muestra las entradas, salidas y expresiones intermedias sin
     recalcularlas.  `playback' sólo muestra las expresiones asociadas
     con etiquetas; cualquier otra salida (tal como texto impreso por
     `print' o `describe', o mensajes de error) no es mostrada.  Véase
     también: `labels'.

     `playback' no evalua sus argumentos.  El operador comilla-comilla,
     `''', obliga a que se realice la evaluación.  `playback' siempre
     devuelve `done'.

     `playback ()' (sin argumentos) muestra todas las entradas, salidas
     y expresiones intermedias generadas hasta el momento.  Una
     expresión de salida es mostrada incluso si ésta fue suprimida por
     el caracter de terminación `$', cuando fue originalmente calculada.

     `playback (<n>)'  muestra las <n> expresiones más recientes. Cada
     entrada, salida y expresión intermedia cuenta como una.

     `playback ([<m>, <n>])' muestra entradas, salidas y expresiones
     intermedias con los números desde <m> hasta <n>, ambos inclusive.

     `playback ([<m>])' es equivalente a `playback ([<m>, <m>])'; esto
     usualmente imprime un par de expresiones de entrada y salida.

     `playback (input)' muestra todas las expresiones de entrada
     generadas hasta el momento.

     `playback (slow)' hace pausas entre expresiones y espera a que el
     usuario pulse la tecla `enter' para continuar.  Esto es un
     comportamiento similar a `demo'.

     `playback (slow)' es muy útil en conjunción con `save' o
     `stringout' cuando se crea un archivo secundario de almacenamiento
     con el objetivo de elegir cuidadosamente las expresiones realmente
     útiles.

     `playback (time)' muestra el tiempo de computo por cada expresión.

     `playback (grind)' muestra las expresiones de entrada en el mismo
     formato como la función `grind'.  Las expresiones de salida no se
     ven afectadas por la opción `grind'.  Vea `grind'.  Los argumentos
     pueden ser combinados, por ejemplo, `playback ([5, 10], grind,
     time, slow)'.


 -- Función: printprops (<a>, <i>)
 -- Función: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Función: printprops (all, <i>)
     Muestra la propiedad con el indicador <i> asociado con el átomo
     <a>. <a> puede ser también una lista de átomos o el átomo `all' en
     cuyo caso todos los átomos a los cuales se les haya dado esa
     propiedad serán usados.  Por ejemplo, `printprops ([f, g],
     atvalue)'. `printprops' es para propiedades que no pueden ser
     mostradas de otra manera, i.e. para `atvalue', `atomgrad',
     `gradef', y `matchdeclare'.


 -- Variable opcional: prompt
     Valor por defecto: `_'

     `prompt' es el símbolo del prompt de la función `demo', del modo
     `playback (slow)' y del bucle de interrupción de Maxima (el que se
     invoca con `break').


 -- Función: quit ()
     Termina una sesión de Maxima.  Nótese que la función debe ser
     invocada como `quit();' o `quit()$', no como `quit'.

     Para parar un cálculo muy demorado pulse `Control-C'.  La acción
     por defecto es retornar a prompt de Maxima.  Si `*debugger-hook*'
     tiene como valor `nil', pulsar `Control-C' abrirá el depurador de
     Lisp.  Vea también: `debugging'.


 -- Función: remfunction (<f_1>, ..., <f_n>)
 -- Función: remfunction (all)
     Desliga las definiciones de función de sus símbolos <f_1>, ...,
     <f_n>.  Los argumentos pueden ser nombres de funciones ordinarias
     (creadas con `:=' o `define') o de funciones macro (creadas con
     `::=').

     La instrucción `remfunction (all)' desliga todas las definiciones
     de funciones.

     La función `remfunction' no evalúa sus argumentos.

     La función `remfunction' devuelve una lista con los símbolos para
     los que la definición de función fue desligada. Devuelve `false'
     en el lugar de cualquier símbolo para el que no hay función
     definida.


 -- Función: reset ()
     Reconfigura muchas variables y opciones globales y algunas otras
     variables a sus valores por defecto.

     `reset' procesa las variables que se encuentran en la lista Lisp
     `*variable-initial-values*'.  La macro Lisp `defmvar' pone las
     variables en ésta lista (entre otras acciones).  Muchas, pero no
     todas, las variables y opciones globales son definidas por
     `defmvar', y algunas variables definidas por `defmvar' no son ni
     variables ni opciones globales.


 -- Variable opcional: showtime
     Valor por defecto: `false'

     Cuando `showtime' tiene como valor `true', el tiempo de cálculo y
     el tiempo de retardo se imprimen junto con la salida de cada
     expresión.

     El tiempo de cálculo se almacena siempre, de manera que `time' y
     `playback' puedan mostrar el tiempo de cálculo incluso cuando
     `showtime' vale `false'.

     Véase también `timer'.


 -- Función: sstatus (<feature>, <package>)
     Configura el estado de <feature> en <package>.  Después de que
     `sstatus (<feature>, <package>)' es ejecutado `status (<feature>,
     <package>)' retorna `true'.  Esto puede ser muy útil para
     escritores de paquetes, con el objetivo de conservar las pistas de
     que caracterísiticas han cargado estos.


 -- Function: to_lisp ()
     Entra en el intérprete Lisp bajo Maxima. `(to-maxima)' retorna de
     nuevo a Maxima.


 -- Variable del sistema: values
     Valor inicial: `[]'

     `values' es una lista de todas las variables que el usuario ha
     creado (no constituye las opciones Maxima ni los interruptores).
     La lista comprende los símbolos `:' , `::', o `:='.



File: maxima.info,  Node: Operadores,  Next: Expresiones,  Prev: Línea de Comandos,  Up: Top

5 Operadores
************

* Menu:

* n-arios::
* no-fijos::
* postfijos::
* prefijos::
* Operadores aritméticos::
* Operadores relacionales::
* Operadores generales::


File: maxima.info,  Node: n-arios,  Next: no-fijos,  Prev: Operadores,  Up: Operadores

5.1 n-arios
===========

Un operador de tipo `nary'(`n'-ario, en Maxima nary) es usado para
denotar una función cuyo número de argumentos es arbitrario; los
argumentos se separa por el símbolo del operador, como en A+B o A+B+C.
La función `nary("x")' es una extensión de la función `syntax' para
declarar a x como un operador `n'-ario. Las funciones pueden ser
declaradas para ser `nary'. Si se hace `declare(J,nary);', se esta
diciendo al simplificador que haga la reducción de `j(j(a,b),j(c,d))' a
`j(a, b, c, d)'.

   Véase también `syntax'.


File: maxima.info,  Node: no-fijos,  Next: postfijos,  Prev: n-arios,  Up: Operadores

5.2 no-fijos
============

Los operadores de tipo `nofix' (no-fijos, en Maxima nofix) son usados
para denotar funciones que no reciben argumentos. La mera presencia de
tal operador en un comando causará que la correspondiente función sea
evaluada. Por ejemplo, cuando se escribe "exit;" para salir de una
interrupción de Maxima, "exit" se está comportando de forma similar a
un operador no-fijo (`nofix'). La función `nofix("x")' es una extensión
de la función syntax la cual declara a x como un operador `nofix'.

   Véase también `syntax'.


File: maxima.info,  Node: postfijos,  Next: prefijos,  Prev: no-fijos,  Up: Operadores

5.3 postfijos
=============

Un operador de tipo `postfix' (postfijo), al contrario de los de tipo
`prefix', denota funciones de un solo argumento, pero en este caso el
argumento precede inmediatamente la ocurrencia del operador en la
cadena de entrada, como en `3!'. La función `postfix("x")' es una
extensión de la función syntax para declarar a x como un operador
`postfix'.

   Véase también `syntax'.


File: maxima.info,  Node: prefijos,  Next: Operadores aritméticos,  Prev: postfijos,  Up: Operadores

5.4 prefijos
============

Un operador de tipo `prefix' (prefijo, en Maxima prefix) indica una
función de un (1) argumento, dicho argumento viene inmediatamente
después de una ocurrencia del operador. La función `prefix("x")' es una
extensión de la función syntax para declarar a x como un operador de
`prefix'.

   Véase también `syntax'.


File: maxima.info,  Node: Operadores aritméticos,  Next: Operadores relacionales,  Prev: prefijos,  Up: Operadores

5.5 Operadores aritméticos
==========================

 -- Operador: +
 -- Operador: -
 -- Operador: *
 -- Operador: /
 -- Operador: ^
     Los símbolos `+' `*' `/' y `^' representan la suma, resta,
     multiplicación, división y exponenciación, respectivamente.  Los
     nombres de estos operadores son `"+"' `"*"' `"//"' y `"^"', que
     pueden aparecer allá donde se requiera el nombre de una función u
     operador.

     Los símbolos `+' y `-' representan el positivo y negativo unario,
     siendo los nombres de estos operadores `"+"' y `"-"',
     respectivamente.

     En Maxima, la resta `a - b' se representa como la suma `a + (- b)'.
     Expresiones tales como `a + (- b)' se muestran como restas. Maxima
     reconoce `"-"' tan solo como el operador de negación unaria, no
     como el nombre del operador de resta binaria.

     La división `a / b' se representa en maxima como la multiplicación
     `a * b^(- 1)'. Expresiones tales como `a * b^(- 1)' se muestran
     como divisiones. Maxima reconoce `"//"' como el nombre del operador
     de división.

     La suma y la multiplicación son operadores conmutativos n-arios. La
     división y la exponenciación son operadores no conmutativos
     binarios.

     Maxima ordena los operandos de los operadores conmutativos para
     formar lo que se conoce como representación canónica. A efectos de
     almacenamiento interno, la ordenación viene determinada por
     `orderlessp'.  A efectos de presentación de las expresiones, la
     ordenación de la suma la determina `ordergreatp', y en el caso de
     la multiplicación, la ordenación coincide con la del
     almacenamiento interno.

     Los cálculos aritméticos se realizan con números literales
     (enteros, racionales, decimales ordinarios y decimales grandes).
     Excepto en el caso de la exponenciación, todas las operaciones
     aritméticas con números dan lugar a resultados en forma de
     números. La exponenciación da como resultado un número si alguno
     de los operandos es decimal ordinario o grande (bigfloat), o si el
     resultado es un entero o racional; en caso contrario, la
     exponenciación puede expresarse como una raíz cuadrada (`sqrt'),
     como otra potencia, o simplemente no sufre cambios.

     Se produce contagio de los decimales en coma flotante en los
     cálculos aritméticos: si algún operando es un número decimal
     grande (bigfloat), el resultado será también un número decimal
     grande; no habiendo decimales grandes, pero sí ordinarios, el
     resultado srá también un decimal ordinario; de no haber operandos
     decimales, el resultado será un número racional o entero.

     Los cálculos aritméticos son simplificaciones, no evaluaciones,
     por lo que se realizan en expresiones comentadas.

     Las operaciones aritméticas se aplican elemento a elemento en el
     caso de las listas cuando la variable global `listarith' vale
     `true'; pero en el caso de las matrices, siempre se aplican
     elemento a elemento.  Cuando un operando es una lista o matriz y
     otro operando lo es de otro tipo cualquiera, éste se combina con
     cada uno de los elementos de la lista o matriz.

     Ejemplos:

     La suma y la multiplicación son operadores conmutativos n-arios.
     Maxima ordena los operandos para formar lo que se conoce como
     representación canónica. Los nombres de estos operadores son `"+"'
     y `"-"'.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     La división y la exponenciación son operadores no conmutativos
     binarios.  Los nombres de estos operadores son `"//"' y `"^"'.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[//, ^], [[a, b], [a, b]]]
          (%i3) [apply ("//", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     La resta y la división se representan internamente en términos de
     la suma y multiplicación, respectivamente.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Los cálculos se realizan con números literales.  Se produce el
     contagio de los números decimales.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Los cálculos aritméticos son una simplificación, no una evaluación.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     Los cálculos aritméticos se realizan elemento a elemento en las
     listas (según sea el valor de `listarith') y matrices.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]


 -- Operador: **
     Operador de exponenciación.  Maxima identifica `**' con el
     operador `^' en la entrada de expresiones, pero se representa como
     `^' en las salidas no formateadas (`display2d=false'), o colocando
     un superíndice en la salida formateada (`display2d=true').

     La función `fortran' representa el operador de exponenciación con
     `**', tanto si se ha introducido como `**' o como `^'.

     Ejemplos:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done



File: maxima.info,  Node: Operadores relacionales,  Next: Operadores generales,  Prev: Operadores aritméticos,  Up: Operadores

5.6 Operadores relacionales
===========================

 -- Operator: <
 -- Operator: <=
 -- Operator: >=
 -- Operator: >


File: maxima.info,  Node: Operadores generales,  Prev: Operadores relacionales,  Up: Operadores

5.7 Operadores generales
========================

 -- Operator: ^^
     Operador de exponenciación no conmutativa.  Se trata del operador
     de exponenciación correspondiente a la multiplicación no
     conmutativa `.', del mismo modo que el operador de exponenciación
     ordinario `^' se corresponde con la multiplicación conmutativa `*'.

     La exponenciación no conmutativa se representa como `^^' en las
     salidas no formateadas (`display2d=false'), o colocando un
     superíndice entre ángulos (`< >') en la salida formateada
     (`display2d=true').

     Ejemplos:

          (%i1) a . a . b . b . b + a * a * a * b * b;
                                  3  2    <2>    <3>
          (%o1)                  a  b  + a    . b
          (%i2) string (a . a . b . b . b + a * a * a * b * b);
          (%o2)                  a^3*b^2+a^^2 . b^^3


 -- Operador: !
     El operador factorial. Para cualquier número complejo `x'
     (incluyendo enteros, racionales  y números reales) excepto para
     enteros negativos, `x!' se define como `gamma(x+1)'.

     Para un entero `x', `x!' simplifica el producto de los enteros
     desde 1 hasta `x'.  `0!' simplifica a 1.  Para a un número de
     punto flotante `x', `x!' calcula al valor de `gamma(x+1)'.  Para
     `x' igual a `n/2' donde `n' es un entero impar, `x!' simplifica a
     un factor racional por `sqrt(%pi)' (donde `gamma(1/2)') es igual a
     `sqrt(%pi)').  Si `x' es cualquier otra cosa, `x!' no se
     simplifica.

     Las variables `factlim', `minfactorial' y  `factcomb' controlan la
     simplificación de expresiones que contienen factoriales.

     Las funciones `gamma', `bffac' y `cbffac' son variaciones de la
     función gamma.  `makegamma' substituye a `gamma' para factoriales
     y funciones relacionadas.

     Funciones relacionadas: `binomial'

        * El factorial de un entero, semi-entero o de punto flotante es
          simplificado a menos que el operando sea mayor que `factlim'.

               (%i1) factlim : 10;
               (%o1)                          10
               (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
                           105 sqrt(%pi)
               (%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
                                16

        * El factorial de un número complejo, constante  conocida (por
          ejemplo `%e') o una expresión general no es simplificado.

          Sin embargo puede ser posible simplificar el factorial
          después de evaluar el operando.

               (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
               (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
               (%i2) ev (%, numer, %enumer);
               (%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357,
                                                              1.227580202486819]

        * El factorial de un símbolo no se simplifica.

               (%i1) kill (foo);
               (%o1)                         done
               (%i2) foo!;
               (%o2)                         foo!

        * Los factoriales son simplificados, no evaluados.  Así `x!'
          puede ser reemplazado en una expresión precedida por el
          operador comilla.

               (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                         105 sqrt(%pi)
               (%o1) [1, -------------, 81.44668037931199, 40320,
                              16
                                                            2432902008176640000]


 -- Operador: !!
     El operador doble factorial.

     Para un número entero, de punto flotante o racional `n', `n!!' se
     evaluará como el producto de `n (n-2) (n-4) (n-6) ... (n - 2
     (k-1))' donde `k' es igual a `entier(n/2)', que es, el mayor entero
     menor o igual a `n/2'.  Note que esta definición no coincide con
     otras definciones publicadas para argumentos, los cuales no son
     enteros.

     Para un entero par (o impar) `n', `n!' se evalua el producto de
     todos los enteros pares (o impares) consecutivos desde 2 (o 1) por
     `n' inclusive.

     Para un argumento `n' el cual no es un número entero, punto
     flotante o racional, `n!!' produce una forma de nombre `genfact
     (n, n/2, 2)'.


 -- Operador: #
     Representa la negación de la igualdad sintáctica `='.

     Nótese que debido a las reglas de evaluación de expresiones de
     tipo predicado (en concreto debido a que `not <expr>' obliga a la
     evaluación previa de <expr>), `not <a> = <b>' equivale a `is(<a> #
     <b>)', pero no a `<a> # <b>'.

     Ejemplos:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not a = b);
          (%o6)                         true


 -- Operador: .
     El operador punto, para multiplicación de matrices
     (no-conmutativo).  Cuando "." se usa de esta forma, se dejarán
     espacios a ambos lados de éste, como en `A . B'. Así se evita que
     se confunda con el punto decimal de los números.

     Véanse: `dot', `dot0nscsimp', `dot0simp', `dot1simp', `dotassoc',
     `dotconstrules', `dotdistrib', `dotexptsimp', `dotident' y
     `dotscrules'.


 -- Operador: :
     El operador de asignación. Por ejemplo, `A:3' se asigna a la
     variable <A> el valor de 3.

 -- Operador: ::
     Operador de asignación. :: asigna el valor de una expresión en su
     derecha a el valor de la cantidad en su izquierda, la cual debe
     evaluarse a una variable de tipo atómica o una variable
     subindicada.


 -- Operador: ::=
     El operador de definición de macros `::=' define una función
     (llamada macro por razones históricas) que no evalúa sus
     argumentos, siendo la expresión que retorna (llamada
     "macroexpansión") evaluada dentro del contexto desde el cual se ha
     invocado la macro. En cualquier otro sentido, una función macro es
     igual que una función ordinaria.

     `macroexpand' devuelve la expresión que a su vez fue devuelta por
     una macro (sin evaluar la expresión); `macroexpand (foo (x))'
     seguida de `''%' es equivalente a `foo (x)' si `foo' es una
     función macro.

     `::=' coloca el nombre de la nueva función macro en la lista
     global `macros'. Por otro lado, las funciones `kill', `remove' y
     `remfunction' borran las definiciones de las funciones macro y
     eliminan sus nombres de la lista `macros'.

     Las funciones `fundef' y `dispfun' devuelven la definición de una
     función macro y le asignan una etiqueta, respectivamente.

     Las funciones macro normalmente contienen expresiones `buildq' y
     `splice' para construir una expresión, que luego será evaluada.

     Ejemplos:

     Una función macro no evalúa sus argumentos, por lo que el mensaje
     (1) muestra `y - z', no el valor de `y - z'.  La macroexpansión
     (es decir, la expresión no evaluada `'(print ("(2) x is equal to",
     x))') se evalúa en el contexto desde el cual se produjo la llamada
     a la macro, imprimiendo el mensaje (2).

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printq1 (x) ::=
                   block (print ("(1) x is equal to", x),
                   '(print ("(2) x is equal to", x)));
          (%o4) printq1(x) ::= block(print("(1) x is equal to", x),
                                          '(print("(2) x is equal to", x)))
          (%i5) printq1 (y - z);
          (1) x is equal to y - z
          (2) x is equal to %pi
          (%o5)                          %pi

     Una función ordinaria evalúa sus argumentos, por lo que el mensaje
     (1) muestra el valor de `y - z'.  El valor de retorno no se
     evalúa, por lo que el mensaje (2) no se imprime hasta la
     evaluación explícita `''%'.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printe1 (x) :=
                   block (print ("(1) x is equal to", x),
                         '(print ("(2) x is equal to", x)));
          (%o4) printe1(x) := block(print("(1) x is equal to", x),
                                          '(print("(2) x is equal to", x)))
          (%i5) printe1 (y - z);
          (1) x is equal to 1234 - 1729 w
          (%o5)              print((2) x is equal to, x)
          (%i6) ''%;
          (2) x is equal to %pi
          (%o6)                          %pi

     `macroexpand' devuelve la macroexpansión; `macroexpand (foo (x))'
     seguida de `''%' es equivalente a `foo (x)' si `foo' es una
     función macro.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) g (x) ::= buildq ([x], print ("x is equal to", x));
          (%o4)    g(x) ::= buildq([x], print("x is equal to", x))
          (%i5) macroexpand (g (y - z));
          (%o5)              print(x is equal to, y - z)
          (%i6) ''%;
          x is equal to 1234 - 1729 w
          (%o6)                     1234 - 1729 w
          (%i7) g (y - z);
          x is equal to 1234 - 1729 w
          (%o7)                     1234 - 1729 w


 -- Operador: :=
     El operador de definición de funciones.  La expresión `<f>(<x_1>,
     ..., <x_n>) := <expr>' define una función de nombre <f> con
     argumentos <x_1>, ..., <x_n> y cuerpo <expr>.  El operador `:=' no
     evalúa el cuerpo de la función (a menos que se indique lo
     contrario mediante el operador comilla-comilla `''').  La función
     así definida puede ser una función ordinaria de Maxima (con
     argumentos encerrados entre paréntesis) o una función array (con
     argumentos encerrados entre corchetes).

     Cuando el último o único argumento <x_n> es una lista de un solo
     elemento, la función definida por `:=' acepta un número variable
     de argumentos. Los valores de los argumentos se asignan uno a uno
     a los argumentos formales <x_1>, ..., <x_(n - 1)>, y cualesquiera
     otros valores de argumentos, si existen, se asignan a <x_n> en
     forma de lista.

     Todas las definiciones de funciones aparecen en el mismo espacio de
     nombres; definiendo una función `f' dentro de otra función `g' no
     limita el alcance de `f' a `g'.

     Si un argumento formal <x_k> es un símbolo afectado por el
     operador comilla (expresión nominal), la función definida por `:='
     no evalúa el correspondiente valor de argumento.  En cualquier
     otro caso, los argumentos que se pasan son evaluados.

     Véanse también `define' y `::='.

     Ejemplos:

     `:=' no evalúa el cuerpo de la función (a menos que se indique lo
     contrario mediante el operador comilla-comilla `''').

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) F1 (x, y) := expr;
          (%o2)                   F1(x, y) := expr
          (%i3) F1 (a, b);
          (%o3)                    cos(y) - sin(x)
          (%i4) F2 (x, y) := ''expr;
          (%o4)              F2(x, y) := cos(y) - sin(x)
          (%i5) F2 (a, b);
          (%o5)                    cos(b) - sin(a)

     La función así definida puede ser una función ordinaria de Maxima
     o una función array.

          (%i1) G1 (x, y) := x.y - y.x;
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) G2 [x, y] := x.y - y.x;
          (%o2)                G2     := x . y - y . x
                                 x, y

     Cuando el último o único argumento <x_n> es una lista de un solo
     elemento, la función definida por `:=' acepta un número variable
     de argumentos.

          (%i1) H ([L]) := apply ("+", L);
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a


 -- Operador: =
     Operador de ecuación.

     La expresión `<a> = <b>' representa una ecuación sin evaluar, la
     cual puede verificarse o no. Las ecuaciones sin evaluar pueden
     aparecer como argumentos de `solve', `algsys' y de algunas otras
     funciones.

     La función `is' evalúa el operador `=' a un resultado booleano;
     `is(<a> = <b>)' asigna un valor de verdad a `<a> = <b>', siendo
     `true' si <a> y <b> son idénticos, lo cual acontece si ambos <a> y
     <b> son átomos idénticos, o si no siendo átomos, sus operadores y
     argumentos respectivos son idénticos; en caso contrario, `is(<a> =
     <b>)' devuelve el valor  `false'. Nunca se devuelve el valor
     `unknown'.  Cuando `is(<a> = <b>)' toma el valor `true', se dice
     que <a> y <b> son sintácticamente iguales, no expresiones
     equivalentes, para las cuales `is(equal(<a>, <b>))' devuelve
     `true'.  Las expresiones pueden ser equivalentes, pero no
     sintácticamente iguales.

     La negación de `=' se representa por `#'.  Como en el caso de `=',
     la expresión `<a> # <b>' no está evaluada; sin embargo, `is(<a> #
     <b>)' evalúa `<a> # <b>' a `true' o `false'.

     Además de `is', hay otros operadores que evalúan `=' y `#' a
     `true' o `false'; a saber, `if', `and', `or' y `not'.

     Nótese que debido a las reglas de evaluación de expresiones de
     tipo predicado (en concreto debido a que `not <expr>' obliga a la
     evaluación previa de <expr>), `not <a> = <b>' equivale a `is(<a> #
     <b>)', pero no a `<a> # <b>'.

     Las funciones `rhs' y `lhs' devuelven los miembros derecho e
     izquierdo, respectivamente, de una ecuación o inecuación.

     Véanse también `equal' y `notequal'.

     Ejemplos:

     La expresión `<a> = <b>' representa una ecuación sin evaluar, la
     cual puede verificarse o no.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     `is(<a> = <b>)' evalúa `<a> = <b>' a `true' si <a> y <b> son
     sintácticamente iguales (es decir, idénticas).  Las expresiones
     pueden ser equivalentes, pero no sintácticamente iguales.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Algunos operadores evalúan `=' y `#' a `true' o `false'.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2
                  then FOO else BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Debido a que `not <expr>' obliga a la evaluación previa de <expr>,
     `not <a> = <b>' equivale a `is(<a> # <b>)'.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true


 -- Operador: and
     Operador de conjunción lógica.  El operador `and' es un operador
     infijo `n'-ario; sus operandos son expresiones booleanas y su
     resultado es un valor lógico.

     El operador `and' impone la evaluación (igual que `is') de uno o
     más operandos, y puede forzar la evaluación de todos los operandos.

     Los operandos se evalúan en el orden en el que aparecen; sólo
     evalúa tantos operandos como sean necesarios para determinar el
     resultado.  Si algún operando vale `false', el resultado es
     `false' y ya no se evalúan más operandos.

     La variable global `prederror' controla el comportamiento de `and'
     cuando la evaluación de un operando no da como resultado `true' o
     `false'; `and' imprime un mensaje de error cuando `prederror' vale
     `true'.  Cuando los operandos devuelven un valor diferente a
     `true' o `false' al ser evaluados, el resultado es una expresión
     booleana.

     El operador `and' no es conmutativo: `a and b' puede no ser igual
     a `b and a' debido al tratamiento de operandos indeterminados.


 -- Operador: or
     Operador de disyunción lógica. El operador `or' es un operador
     infijo `n'-ario; sus operandos son expresiones booleanas y su
     resultado es un valor lógico.

     El operador `or' impone la evaluación (igual que `is') de uno o
     más operandos, y puede forzar la evaluación de todos los operandos.

     Los operandos se evalúan en el orden en el que aparecen; `or' sólo
     evalúa tantos operandos como sean necesarios para determinar el
     resultado. Si un operando vale `true', el resultado es `true' y ya
     no se evalúan más operandos.

     La variable global `prederror' controla el comportamiento de `or'
     cuando la evaluación de un operando no da como resultado `true' o
     `false'; `or' imprime un mensaje de error cuando `prederror' vale
     `true'.  Cuando los operandos devuelven un valor diferente a
     `true' o `false' al ser evaluados, el resultado es una expresión
     booleana.

     El operador `or' no es conmutativo: `a or b' puede no ser igual a
     `b or a' debido al tratamiento de operandos indeterminados.


 -- Operador: not
     Operador de negación lógica. El operador `not' es un operador
     prefijo; su operando es una expresión booleana y su resultado es
     un valor lógico.

     El operador `not' impone la evaluación (igual que `is') de su
     operando.

     La variable global `prederror' controla el comportamiento de `not'
     cuando la evaluación de su operando no da como resultado `true' o
     `false'; `not' imprime un mensaje de error cuando `prederror' vale
     `true'.  Cuando los operandos devuelven un valor diferente a
     `true' o `false' al ser evaluados, el resultado es una expresión
     booleana.


 -- Función: abs (<expr>)
     Devuelve el valor absoluto de <expr>. Si la expresión es compleja,
     retorna el módulo de <expr>.


 -- Clave: additive
     Si `declare(f,additive)' ha sido ejecutado, entonces:

     (1) Si `f' es univariado, cada vez que el simplificador encuentre
     `f' aplicada a una suma, `f' será distribuida bajo esta suma. Por
     ejemplo, `f(x+y)' se simplificará a `f(x)+f(y)'.

     (2) Si `f' es una función de 2 o más argumentos, aditivamente es
     definida como aditiva en el primer argumento de `f', como en el
     caso de `sum' o `integrate'. Por ejemplo, `f(h(x)+g(x),x)' se
     simplificará a `f(h(x),x)+f(g(x),x)'. Esta simplificación no
     ocurre cuando `f' se aplica a expresiones de la forma
     `sum(x[i],i,lower-limit,upper-limit)'.


 -- Clave: allbut
     Opera con los comandos `part' (como `part', `inpart', `substpart',
     `substinpart', `dpart' y `lpart'). Por ejemplo:

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     mientras que:

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, allbut (2, 5));
          (%o2)                       e + c + b

     La función `kill' también reconoce a `allbut'.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

     La sentencia `kill(allbut(<a_1>, <a_2>, ...))' tiene el mismo
     efecto que `kill(all)', excepto que no elimina los símbolos <a_1>,
     <a_2>, ... .


 -- Declaración: antisymmetric
     Si `declare(h,antisymmetric)' es ejecutado, esto dice al
     simplificador que `h' es antisimétrico. E.g. `h(x,z,y)' será
     simplificado a `-h(x,y,z)'. Que es, el producto de (-1)^n por el
     resultado dado por `symmetric' o `commutative', donde n es el
     número de intercambios necesarios de dos argumentos para
     convertirle a esta forma.


 -- Función: cabs (<expr>)
     Devuelve el valor absoluto complejo (módulo complejo) de <expr>.


 -- Función: ceiling (<x>)
     Si <x> es un número real, devuelve el menor entero mayor o igual
     que <x>.

     Si <x> es una expresión constante (por ejemplo, `10 * %pi'),
     `ceiling' evalúa <x> haciendo uso de números grandes en coma
     flotante (big floats), aplicando a continuación  `ceiling' al
     número decimal obtenido. Puesto que `ceiling' hace evaluaciones en
     coma flotante, es posible, pero improbable, que esta función
     devuelva un valor erróneo para entradas constantes. Para evitar
     estos errores, la evaluación en punto flotante se lleva a cabo
     utilizando tres valores para `fpprec'.

     Para argumentos no constantes, `ceiling' intenta devolver un valor
     simplificado. Aquí se presentan algunos ejemplos sobre las
     simplificaciones que `ceiling' es capaz de hacer:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                                false

     La función `ceiling' no se extiende automáticamente a los
     elementos de listas y matrices.  Por último, para todos los
     argumentos que tengan una forma compleja, `ceiling' devuelve una
     forma nominal.

     Si el rango de una función es subconjunto de los números enteros,
     entonces puede ser declarada como `integervalued'. Tanto `ceiling'
     como `floor' son funciones que hacen uso de esta información; por
     ejemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Función: charfun (<p>)
     Devuelve 0 cuando el predicado <p> toma el valor `false', y
     devuelve 1 cuando vale `true'.  Si el predicado toma un valor
     diferente de `true' y `false' (desconocido), entonces devuelve una
     forma nominal.

     Ejemplos:

          (%i1) charfun(x<1);
          (%o1) charfun(x<1)
          (%i2) subst(x=-1,%);
          (%o2) 1
          (%i3) e : charfun('"and"(-1 < x, x < 1))$
          (%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
          (%o4) [0,1,0]


 -- Declaración: commutative
     Si `declare(h,commutative)' es ejecutado, le dice al simplificador
     que `h' es una función conmutaiva. Por ejemplo, `h(x,z,y)' se
     simplificará a `h(x,y,z)'. Esto es lo mismo que `symmetric'.


 -- Función: compare (<x>, <y>)
     Devuelve un operador de comparación <op> (`<', `<=', `>', `>=',
     `=' o `#') de manera que `is (<x> <op> <y>)' tome el valor `true';
     cuando tanto <x> como <y> dependan de `%i' y `<x> # <y>', devuelve
     `notcomparable'; cuando no exista tal operador o Maxima sea
     incapaz de determinarlo, devolverá `unknown'.

     Ejemplos:

          (%i1) compare(1,2);
          (%o1) <
          (%i2) compare(1,x);
          (%o2) unknown
          (%i3) compare(%i,%i);
          (%o3) =
          (%i4) compare(%i,%i+1);
          (%o4) notcomparable
          (%i5) compare(1/x,0);
          (%o5) #
          (%i6) compare(x,abs(x));
          (%o6) <=

     La función `compare' no intenta determinar si los dominios reales
     de sus argumentos son conjuntos no vacíos; así,

          (%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
          (%o1) <

     Aquí, el dominio real de `acos (x^2 + 1)' es el conjunto vacío.


 -- Función: entier (<x>)
     Devuelve el mayor entero menor o igual a <x>, siendo <x> numérico.
     La función  `fix' (como en `fixnum') es un sinónimo, de modo que
     `fix(<x>)' hace justamente lo mismo.


 -- Función: equal (<a>, <b>)
     Representa la equivalencia, esto es, la igualdad de los valores.

     Por sí misma, `equal' no evalúa ni simplifica.  La función `is'
     intenta evaluar `equal' a un resultado booleano. La instrucción
     `is(equal(<a>, <b>))' devuelve `true' (o `false') si y sólo si <a>
     y <b> son iguales (o no iguales) para todos los posibles valores
     de sus variables, tal como lo determina `ratsimp(<a> - <b>)'; si
     `ratsimp' devuelve 0, las dos expresiones se consideran
     equivalentes. Dos expresiones pueden ser equivalentes  sin ser
     sintácticamente iguales (es decir, idénticas).

     Si `is' no consigue reducir `equal' a `true' o `false', el
     resultado está controlado por la variable global `prederror'.  Si
     `prederror' vale `true', `is' emite un mensaje de error; en caso
     contrario, `is' devuelve `unknown'.

     Además de `is', otros operadores evalúan `equal' y `notequal' a
     `true' o `false'; a saber, `if', `and', `or' y `not'.

     La negación de `equal' es `notequal'.

     Ejemplos:

     Por sí misma, `equal' no evalúa ni simplifica.

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     La función `is' intenta evaluar `equal' a un resultado booleano.
     La instrucción `is(equal(<a>, <b>))' devuelve `true' si
     `ratsimp(<a> - <b>)' devuelve 0. Dos expresiones pueden ser
     equivalentes  sin ser sintácticamente iguales (es decir,
     idénticas).

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Si `is' no consigue reducir `equal' a `true' o `false', el
     resultado está controlado por la variable global `prederror'.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Otros operadores evalúan `equal' y `notequal' a  `true' o `false'.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Debido a que `not <expr>' obliga a la evaluación previa de <expr>,
     `not equal(<a>, <b>)' equivale a `is(notequal(<a>, <b>))'.

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true

 -- Función: floor (<x>)
     Si <x> es un número real, devuelve el mayor entero menor o igual
     que <x>.

     Si <x> es una expresión constante (por ejemplo, `10 * %pi'),
     `floor' evalúa <x> haciendo uso de números grandes en coma
     flotante (big floats), aplicando a continuación  `floor' al número
     decimal obtenido. Puesto que `floor' hace evaluaciones en coma
     flotante, es posible, pero improbable, que esta función devuelva
     un valor erróneo para entradas constantes. Para evitar estos
     errores, la evaluación en punto flotante se lleva a cabo
     utilizando tres valores para `fpprec'.

     Para argumentos no constantes, `floor' intenta devolver un valor
     simplificado. Aquí se presentan algunos ejemplos sobre las
     simplificaciones que `floor' es capaz de hacer:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     La función `floor' no se extiende automáticamente a los elementos
     de listas y matrices.  Por último, para todos los argumentos que
     tengan una forma compleja, `floor' devuelve una forma nominal.

     Si el rango de una función es subconjunto de los números enteros,
     entonces puede ser declarada como `integervalued'. Tanto `ceiling'
     como `floor' son funciones que hacen uso de esta información; por
     ejemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Función: notequal (<a>, <b>)
     Representa la negación de `equal (<a>, <b>)'.

     Ejemplos:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true


 -- Operador: eval
     El operador `eval' realiza una evaluación extra de una expresión
     <expr>.  Véase `ev'.


 -- Función: evenp (<expr>)
     Devuelve `true' si <expr> es un entero par y `false' en cualquier
     otro caso.


 -- Función: fix (<x>)
     Es un sinónimo de  `entier (<x>)'.


 -- Función: fullmap (<f>, <expr_1>, ...)
     Similar a `map', pero conservará el mapeado descendente de todas
     las subexpresiones hasta que los operadores principales ya no sean
     los mismos.

     La función `fullmap' es utilizada por el simplificador de Maxima
     en algunas transformaciones matriciales, por lo que Maxima
     generará en algunas ocasiones mensajes de error relacionados con
     `fullmap' aunque el usuario no haya invocado explícitamente esta
     función.

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)


 -- Función: fullmapl (<f>, <list_1>, ...)
     Similar a `fullmap', pero `fullmapl' sólo hace mapeo sobre listas
     y matrices.

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]


 -- Función: is (<expr>)
     Intenta determinar si el predicado <expr>  se puede deducir de los
     hechos almacenados en la base de datos gestionada por `assume'.

     Si el predicado se reduce a `true' o `false', `is' devuelve `true'
     o `false', respectivamente.  En otro caso, el valor devuelto está
     controlado por la variable global `prederror'.  Si `prederror'
     vale `true', `is' emite un mensaje de error; en caso contrario,
     `is' devuelve `unknown'.

     La instrucción `ev(<expr>, pred)' (que puede escribirse como
     `<expr>, pred' en el modo interactivo) equivale a `is(<expr>)'.

     Véanse también `assume', `facts' y `maybe'.

     Ejemplos:

     `is' evalúa los predicados,

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     `is' intenta evaluar predicados a partir del conocimiento
     almacenado en la base de datos de `assume'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     Si `is' no puede evaluar el valor lógico del predicado a partir de
     la base de datos gestionada por `assume', la variable global
     `prederror' controla el comportamiento de `is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown


 -- Función: maybe (<expr>)
     Intenta determinar si el predicado <expr>  se puede deducir de los
     hechos almacenados en la base de datos gestionada por `assume'.

     Si el predicado se reduce a `true' o `false', `maybe' devuelve
     `true' o `false', respectivamente.  En otro caso, `maybe' devuelve
     `unknown'.

     La función `maybe' es funcionalmente equivalente a `is' con
     `prederror: false', pero el resultado se calcula sin asignar valor
     alguno a `prederror'.

     Véanse también `assume', `facts' y `is'.

     Ejemplos:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Función: isqrt (<x>)
     Devuelve la "raíz cuadrada entera" del valor absoluto de <x>, el
     cual debe ser un entero.


 -- Función: lmax (<L>)
     Si <L> es una lista o conjunto, devuelve `apply ('max, args
     (<L>))'.  Si <L> no es una lista o conjunto, envía un mensaje de
     error.

 -- Función: lmin (<L>)
     Si <L> es una lista o conjunto, devuelve `apply ('min, args
     (<L>))'.  Si <L> no es una lista o conjunto, envía un mensaje de
     error.

 -- Función: max (<x_1>, ..., <x_n>)
     Devuelve un valor simplificado de la mayor de las expresiones
     desde <x_1> hasta <x_n>.  Si `get (trylevel, maxmin)' es 2 o más,
     `max' aplica la simplificación `max (e, -e) --> |e|'.  Si `get
     (trylevel, maxmin)' es 3 o más, <max> intenta eliminar las
     expresiones que estén entre otros dos de los argumentos dados; por
     ejemplo, `max (x, 2*x, 3*x) --> max (x, 3*x)'. Para asignar el
     valor 2 a `trylevel' se puede hacer `put (trylevel, 2, maxmin)'.


 -- Función: min (<x_1>, ..., <x_n>)
     Devuelve un valor simplificado de la menor de las expresiones
     desde <x_1> hasta <x_n>.  Si `get (trylevel, maxmin)' es 2 o más,
     `min' aplica la simplificación `min (e, -e) --> |e|'.  Si `get
     (trylevel, maxmin)' es 3 o más, <min> intenta eliminar las
     expresiones que estén entre otros dos de los argumentos dados; por
     ejemplo, `min (x, 2*x, 3*x) --> min (x, 3*x)'. Para asignar el
     valor 2 a `trylevel' se puede hacer `put (trylevel, 2, maxmin)'.


 -- Función: polymod (<p>)
 -- Función: polymod (<p>, <m>)
     Convierte el polinomio <p> a una representación modular respecto
     del módulo actual, que es el valor almacenado en la variable
     `modulus'.

     La llamada `polymod (<p>, <m>)' especifica un módulo <m> para ser
     utilizado en lugar de valor almacenado en `modulus'.

     Véase `modulus'.

 -- Función: mod (<x>, <y>)
     Si <x> e <y> son números reales e <y> es distinto de cero,
     devuelve `<x> - <y> * floor(<x> / <y>)'.  Para todos los reales
     <x>, se tiene `mod (<x>, 0) = <x>'. Para información sobre la
     definición de  `mod (<x>, 0) = <x>', véase la sección 3.4 de
     "Concrete Mathematics", by Graham, Knuth, and Patashnik. La
     función `mod (<x>, 1)' es de diente de sierra con periodo unidad y
     con `mod (1, 1) = 0' y `mod (0, 1) = 0'.

     Para encontrar el argumento principal (un número del intervalo
     `(-%pi, %pi]') de un número complejo, hágase uso de la función
     `<x> |-> %pi - mod (%pi - <x>, 2*%pi)', donde <x> es un argumento.

     Si <x> e <y> son expresiones constantes (por ejemplo, `10 * %pi'),
     `mod' utiliza el mismo esquema de evaluación basado en números
     grandes en coma flotante (big floats) que `floor' y `ceiling'.
     También es posible, pero improbable, que `mod' pueda retornar un
     valor erróneo en tales casos.

     Para argumentos no numéricos <x> o <y>, `mod' aplica algunas
     reglas de simplificación:

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0

 -- Función: oddp (<expr>)
     Devuelve `true' si <expr> es un entero impar y `false' en caso
     contrario.


 -- Operador: pred
     El operador `pred' realiza una evaluación extra de un predicado
     (expresión cuya evaluación debe dar `true' o `false'). Véase `ev'.


 -- Función: make_random_state (<n>)
 -- Función: make_random_state (<s>)
 -- Función: make_random_state (true)
 -- Función: make_random_state (false)
     Un objeto de estado aleatorio representa el estado del generador
     de números aleatorios. El estado consiste en 627 cadenas binarias
     de 32 bits.

     La llamada `make_random_state (<n>)' devuelve un nuevo objeto de
     estado aleatorio creado a partir de una semilla entera igual a <n>
     módulo 2^32. El argumento <n> puede ser negativo.

     La llamada `make_random_state (<s>)' devuelve una copia del estado
     aleatorio <s>.

     La llamada `make_random_state (true)' devuelve un nuevo objeto de
     estado aleatorio, cuya semilla se genera a partir de la hora
     actual del reloj del sistema como semilla.

     La llamada `make_random_state (false)' devuelve una copia del
     estado actual del generador de números aleatorios.


 -- Función: set_random_state (<s>)
     Establece <s> como estado del generador de números aleatorios.

     La función `set_random_state' devuelve `done' en todo caso.


 -- Función: random (<x>)
     Devuelve un número seudoaleatorio. Si <x> es un entero, `random
     (<x>)' devuelve un entero entre 0 y `<x> - 1', ambos inclusive. Si
     <x> es un decimal en punto flotante, `random (<x>)' devuelve un
     decimal no negativo en punto flotante menor que <x>.  La función
     `random' emite un mensaje de error si <x> no es ni entero ni de
     punto flotante, o si <x> no es positivo.

     Las funciones `make_random_state' y `set_random_state' permiten
     controlar el estado del generador de números aleatorios.

     El generador de números aleatorios de Maxima implementa el
     algoritmo de Mersenne twister MT 19937.

     Ejemplos:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


 -- Función: rationalize (<expr>)
     Convierte todos los números en coma flotante de doble precisión y
     grandes (big float) presentes en una expresión <expr> de Maxima a
     sus formas racionales exactas equivalentes. Si el usuario no está
     familiarizado con la representación binaria de números en coma
     flotante, le puede extrañar que `rationalize (0.1)' no sea igual
     que 1/10.  Este comportamiento no es único de Maxima, ya que el
     número 1/10 en su forma binaria es periódico y no exacto.

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                         1
          (%o2)                          --
                                         10
          (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                                        x    28
          (%o7)                     sin(-- + --)
                                        10   5

     Ejemplo de uso:

          (%i1) unitfrac(r) := block([uf : [], q],
              if not(ratnump(r)) then
                error("The input to 'unitfrac' must be a rational number"),
              while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
              reverse(uf));
          (%o1) unitfrac(r) := block([uf : [], q],
          if not ratnump(r) then
            error("The input to 'unitfrac' must be a rational number"),
                                               1
          while r # 0 do (uf : cons(q : ----------, uf), r : r - q),
                                                   1
                                           ceiling(-)
                                                   r
          reverse(uf))
                                      1  1  1
          (%o2)                      [-, -, --]
                                      2  3  15
          (%i3) unitfrac (9/10);
                                         9
          (%o3)                          --
                                         10
          (%i4) apply ("+", %);
                                            1
          (%o4)                       [- 1, --]
                                            10
          (%i5) unitfrac (-9/10);
                                          9
          (%o5)                         - --
                                          10
          (%i6) apply ("+", %);
                                  1  1  1  1    1
          (%o6)                  [-, -, -, --, ----]
                                  2  3  8  69  6808
          (%i7) unitfrac (36/37);
                                         36
          (%o7)                          --
                                         37
          (%i8) apply ("+", %);


 -- Función: sign (<expr>)
     Intenta determinar el signo de <expr> en base a los hechos
     almacenados en la base de datos. Devuelve una de las siguientes
     respuestas: `pos' (positivo), `neg' (negativo), `zero' (cero), `pz'
     (positivo o cero), `nz' (negativo o cero), `pn' (positivo o
     negativo), o `pnz' (positivo, negativo o cero, lo que significa
     que el signo es desconocido).


 -- Función: signum (<x>)
     Para <x> numérico, devuelve 0 si <x> es 0, en caso contrario
     devuelve -1 o +1, según que <x> sea menor o mayor que 0,
     respectivamente.

     Si <x> no es numérico, entonces se devuelve una forma simplificada
     equivalente.  Por ejemplo, `signum(-x)' devuelve `-signum(x)'.


 -- Función: sort (<L>, <P>)
 -- Función: sort (<L>)
     Ordena la lista <L> de acuerdo con el predicado `P' de dos
     argumentos, de tal manera que `<P> (<L>[k], <L>[k + 1])' es `true'
     (verdadero) para cualesquiera dos elementos sucesivos.  El
     predicado se puede especificar como nombre de una función o de un
     operador infijo binario, o como una expresión `lambda'.  Si se
     especifica con el nombre de un operador, este nombre debe
     encerrarse con "comillas dobles".

     La lista ordenada se devuelve como un objeto nuevo, de manera que
     el argumento <L> no se ve alterado.  A fin de construir el valor
     de retorno, `sort' hace una copia previa de los elementos de <L>.

     Si el predicado <P> no ordena totalmente los elementos de <L>,
     entonces `sort' puede seguir ejecutándose hasta el final sin emitir
     errores, pero el resultado no es predecible.  La función muestra
     un mensaje de error en caso de que el predicado devuelva algo
     diferente de `true' o `false'.

     La llamada `sort (<L>)' equivale a `sort (<L>, orderlessp)'; esto
     es, el orden por defecto es el ascendente, tal como queda definido
     por `orderlessp'. Todos los átomos y expresiones de Maxima son
     comparables para `orderlessp', aunque existen ejemplos aislados de
     expresiones para las cuales `orderlessp' deja de ser transitivo;
     se trata de un fallo de Maxima.

     Ejemplos:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x],
                    ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b],
                                       orderlessp (reverse (a), reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]


 -- Función: sqrt (<x>)
     Raíz cuadrada de <x>. Se representa internamente por `<x>^(1/2)'.
     Véase también `rootscontract'.

     Si la variable `radexpand' vale `true' hará que las raíces
     `n'-ésimas de los factores de un producto que sean potencias de
     `n' sean extraídas del radical; por ejemplo, `sqrt(16*x^2)' se
     convertirá en `4*x' sólo si `radexpand' vale `true'.


 -- Variable opcional: sqrtdispflag
     Valor por defecto: `true'

     Si `sqrtdispflag' vale `false', hará que `sqrt' se muestre con el
     exponente 1/2.


 -- Función: sublis (<list>, <expr>)
     Realiza sustituciones  múltiples en paralelo en una expresión.

     La variable `sublis_apply_lambda' controla la simplificación
     después de `sublis'.

     Ejemplo:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)


 -- Función: sublist (<list>, <p>)
     Devuelve la lista de elementos de <list> para los cuales el
     predicado `p' retorna `true'.

     Ejemplo:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Variable opcional: sublis_apply_lambda
     Valor por defecto: `true'

     Controla si los `lambda' sustituidos son aplicados en la
     simplificación después de invocar a `sublis', o si se tiene que
     hacer un `ev' para hacerlo. Si `sublis_apply_lambda' vale `true',
     significa que se ejecute la aplicación.


 -- Función: subst (<a>, <b>, <c>)
     Sustituye <a> por <b> en <c>. El argumento  <b> debe ser un átomo
     o una subexpresión completa de <c>.  Por ejemplo, `x+y+z' es una
     subexpresión completa de  `2*(x+y+z)/w' mientras que `x+y' no lo
     es. Cuando <b> no cumple esta característica, se puede utilizar en
     algunos casos `substpart' o `ratsubst' (ver más abajo).
     Alternativamente, si <b> no es de la forma `e/f' entonces se puede
     usar `subst (a*f, e, c)', pero si <b> es de la forma `e^(1/f)' se
     debe usar `subst (a^f, e, c)'.  La instrucción `subst' también
     reconoce `x^y' en `x^-y', de manera que  `subst (a, sqrt(x),
     1/sqrt(x))' da `1/a'. Los argumentos <a> y <b> también pueden ser
     operadores de una expresión acotados por comillas dobles `"' o
     nombres de funciones.  Si se quiere sustituir la variable
     independiente en expresiones con derivadas se debe utilizar la
     función `at' (ver más abajo).

     La función `subst' es sinónimo de `substitute'.

     La llamada `subst (<eq_1>, <expr>)' o `subst ([<eq_1>, ...,
     <eq_k>], <expr>)' están permitidas.  Las <eq_i> son ecuaciones que
     indican las sustituciones a realizar.  Para cada ecuación, el
     miembro derecho será sustituida por la expresión del miembro
     izquierdo en <expr>.

     Si la variable `exptsubst' vale `true' se permiten ciertas
     sustituciones de exponentes; por ejemplo, sustituir `y' por `%e^x'
     en `%e^(a*x)'.

     Si `opsubst' vale `false', `subst' no intentará sustituir un
     operador de una expresión. Por ejemplo, `(opsubst: false, subst
     (x^2, r, r+r[0]))' trabajará sin problemas.

     Ejemplos:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Para más ejemplos, ejecútese `example (subst)'.


 -- Función: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Es similar a `substpart', pero `substinpart' trabaja con la
     representación interna de <expr>.

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

     Si el último argumento de la función `part' es una lista de
     índices, entonces se toman varias subexpresiones, cada una de las
     cuales en correspondencia con un índice de la lista. Así,

          (%i1) part (x+y+z, [1, 3]);
          (%o1)                         z + x

     `piece' guarda el valor de la última expresión seleccionada cada
     vez que se utiliza la función `part'. Esta asignación se se hace
     durante la ejecución de la función, con lo que puede ser
     referenciada en la propia función tal como se muestra más abajo.
     Si `partswitch' vale `true' entonces se devuelve `end' cuando la
     parte seleccionada de una expresión no existe, en caso contrario
     se muestra un mensaje de error.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Además, darle a la opción `inflag' el valor `true' y llamar a
     `part' o a `substpart' es lo mismo que llamar a `inpart' o a
     `substinpart'.


 -- Función: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Sustituye <x> por la subexpresión determinada por el resto de
     argumentos, según el esquema de `part'.  Devuelve el nuevo valor
     de <expr>. El argumento  <x> puede ser un operador a ser
     sustituido por un operador de <expr>. En algunos casos <x>
     necesita estar acotado por comillas dobles `"', como en `substpart
     ("+", a*b, 0)' para que retorne `b + a'.

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f (b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Además, darle a la opción `inflag' el valor `true' y llamar a
     `part' o a `substpart' es lo mismo que llamar a `inpart' o a
     `substinpart'.


 -- Función: subvarp (<expr>)
     Devuelve `true' si <expr> es una variable subindicada, como `a[i]'.


 -- Función: symbolp (<expr>)
     Devuelve `true' si <expr> es un símbolo y `false' en caso
     contrario.  La llamada `symbolp(x)' equivale al predicado `atom(x)
     and not numberp(x)'.

     Véase también `Identifiers'.


 -- Función: unorder ()
     Desactiva las asociaciones creadas por la última utilización de
     los comandos de ordenación `ordergreat' y `orderless', los cuales
     no pueden ser utilizados más de una vez sin invocar a `unorder'.
     Véase también `ordergreat' y `orderless'.

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
           %th(1) - %th(3);
                                       2
          (%o4)                       a  + b x
          (%i5) unorder();
                                        2    2
          (%o5)                        a  - a


 -- Función: vectorpotential (<givencurl>)
     Devuelve el vector potencial de un vector rotacional en el sistema
     de coordenadas actual.  `potentialzeroloc' tiene un rol similar al
     de `potential', pero el orden del miembro izquierdo de las
     ecuaciones debe ser una permutación cíclica de las coordenadas.


 -- Función: xthru (<expr>)
     Combina todos los términos de <expr> (la cual debe ser una suma)
     sobre un común denominador sin expandir productos ni sumas
     elevadas a exponentes al modo que lo hace `ratsimp'. La función
     `xthru' cancela factores comunes en el numerador y denominador de
     expresiones racionales, pero sólo si los factores son explícitos.

     En ocasiones puede ser útil el uso de `xthru' antes de la llamada
     a `ratsimp' a fin de cancelar factores explícitos del máximo común
     divisor del numerador y denominador y así simplificar la expresión
     a la que se va a aplicar `ratsimp'.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
           xthru (%);
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)


 -- Función: zeroequiv (<expr>, <v>)
     Analiza si la expresión <expr> de variable <v> equivale a cero,
     devolviendo `true', `false' o `dontknow'.

     La función `zeroequiv' tiene estas restricciones:
       1. No utilizar funciones que Maxima no sepa derivar y evaluar.

       2. Si la expresión tiene polos en la recta real, pueden aparecer
          errores en el resultado, aunque es poco probable.

       3. Si la expresión contiene funciones que no son soluciones de
          ecuaciones diferenciales ordinarias de primer orden (como las
          funciones de Bessel) pueden presentarse resultados
          incorrectos.

       4. El algoritmo utiliza evaluaciones en puntos aleatoriamente
          seleccionados. Esto conlleva un riesgo,aunque el algoritmo
          intenta minimizar el error.

     Por ejemplo, `zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' devuelve
     `true' y `zeroequiv (%e^x + x, x)' devuelve `false'.  Por otro
     lado `zeroequiv (log(a*b) - log(a) - log(b), a)' devuelve
     `dontknow' debido a la presencia del parámetro `b'.



File: maxima.info,  Node: Expresiones,  Next: Simplificación,  Prev: Operadores,  Up: Top

6 Expresiones
*************

* Menu:

* Introducción a las expresiones::
* Asignación::
* Expresiones complejas::
* Nombres y verbos::
* Identificadores::
* Cadenas de caracteres::
* Desigualdades::
* Sintaxis::
* Funciones y variables para expresiones::


File: maxima.info,  Node: Introducción a las expresiones,  Next: Asignación,  Prev: Expresiones,  Up: Expresiones

6.1 Introducción a las expresiones
==================================

Existe un cierto número de palabras reservadas que no pueden utilizarse
como nombres de variables. Su uso podría causar errores críticos de
sintaxis.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   La mayoría de los objetos en Maxima son expresiones. Una secuencia
de expresiones puede constituir una expresión, separándolas por comas y
colocando paréntesis alrededor de ellas. Esto es similar a las
expresiones con coma en C.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Incluso los bucles en Maxima son expresiones, aunque el valor que
retornan (`done') no es muy útil.

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   pero quizás se quiera incluir un tercer término en la expresión con
coma para que devuelva el valor de interés.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Asignación,  Next: Expresiones complejas,  Prev: Introducción a las expresiones,  Up: Expresiones

6.2 Asignación
==============

Existen dos operadores de asignación en Maxima, `:' y `::'.  Por
ejemplo, `a: 3' asigna a la variable `a' el valor de 3. Por otro lado,
`::' asigna el valor de la expresión de su derecha al valor de la
cantidad de su izquierda, el cual debe evaluarse a una variable de tipo
átomo o una variable subindicada.


File: maxima.info,  Node: Expresiones complejas,  Next: Nombres y verbos,  Prev: Asignación,  Up: Expresiones

6.3 Expresiones complejas
=========================

Una expresión compleja se especifica en Maxima añadiendo a la parte
real de la expresión el producto de `%i' por la parte imaginaria. Así
las raíces de la ecuación `x^2 - 4*x + 13 = 0' son `2 + 3*%i' y `2 -
3*%i'. Nótese que la simplificación de productos de expresiones
complejas puede ser efectuado expandiendo el producto. La
simplificación de cocientes, raíces y otras funciones que contengan
expresiones complejas pueden normalmente conseguirse a través de las
funciones `realpart', `imagpart', `rectform', `polarform', `abs' o
`carg'.


File: maxima.info,  Node: Nombres y verbos,  Next: Identificadores,  Prev: Expresiones complejas,  Up: Expresiones

6.4 Nombres y verbos
====================

Maxima distingue entre operadores que son "nombres" y operadores que
son "verbos".  Un verbo es un operador que puede ser ejecutado.  Un
nombre es un operador que aparece como un símbolo en una expresión pero
sin ser ejecutado.  Por defecto, los nombres de funciones son verbos.
Un verbo puede transformarse en nombre utilizando el apóstrofo o
aplicando la función `nounify'.  Un nombre puede transformarse en verbo
aplicando la función `verbify'.  La variable `nouns' hace que `ev'
evalúe los nombres presentes en una expresión.

   La forma verbal se distingue mediante la precedencia del carácter
dólar `$' al correspondiente símbolo de Lisp.  Por otro lado, la forma
nominal se distingue mediante la precedencia del carácter porcentaje
`%' al correspondiente símbolo de Lisp.  Algunos nombres gozan de
propiedades especiales para su representación, como `'integrate' o
`'derivative' (devuelto por `diff'), pero la mayoría no.  Por defecto,
las formas nominal y verbal de una función son idénticas cuando se
muestran en un terminal.  La variable global `noundisp' hace que Maxima
muestre los nombres precedidos del apóstrofo `''.

   Véanse también `noun', `nouns', `nounify' y `verbify'.

   Ejemplos:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identificadores,  Next: Cadenas de caracteres,  Prev: Nombres y verbos,  Up: Expresiones

6.5 Identificadores
===================

En Maxima, los identificadores pueden contener caracteres alfabéticos,
números del 0 al 9 y cualquier otro carácter precedido de la barra
invertida `\'.

   Un identificador puede comenzar con un carácter numérico si éste va
precedido de la barra invertida `\'.  Los caracteres numéricos que
ocupen la segunda posición o posterior no necesitan ir precedidos de la
barra invertida.

   Los caracteres pueden declararse como alfabéticos con la función
`declare'.  Así declarados, no necesitan ir precedidos de la barra
invertida en un identificador.  En principio, los caracteres
alfabéticos son las letras de `A' a `Z' y `a' a `z', junto con  `%' y
`_'.

   Maxima distingue minúsculas y mayúsculas. Los identificadores `foo',
`FOO' y `Foo' son distintos.  Véase *Note Lisp y Maxima:: para más
información.

   Un identificador en Maxima es un símbolo Lisp que comienza con el
símbolo dólar `$'.  Cualquier otro símbolo de Lisp va precedido de la
interrogación `?' cuando aparece en Maxima.  Véase *Note Lisp y
Maxima:: para más información.

   Ejemplos:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Cadenas de caracteres,  Next: Desigualdades,  Prev: Identificadores,  Up: Expresiones

6.6 Cadenas de caracteres
=========================

Las cadenas de caracteres deben ir acotadas por comillas dobles (`"')
al ser introducidas en Maxima, siendo luego mostradas con o sin ellas,
dependiendo del valor de la variable global `stringdisp'.

   Las cadenas pueden contener todo tipo de caracteres, incluyendo
tabulaciones, caracteres de nueva línea y de retorno.  La secuencia
`\"' se reconoce literalmente como una comilla doble, al tiempo que
`\\' se interpreta como una barra invertida. Cuando la barra invertida
aparece al final de una línea, tanto la barra como el final de línea
(representado éste bien por el carácter de nueva línea o el de retorno)
son ignorados, de forma que la cadena continúa en el siguiente renglón.
No se reconocen más combinaciones especiales de la barra invertida con
otros caracteres aparte de las comentadas; de modo que si la barra
invertida aparece antes de cualquier otro carácter distinto de `"',
`\', o de un final de línea, dicha barra será ignorada.  No hay manera
de representar los caracteres especiales (tabulación, nueva línea o
retorno) de otra forma que no sea incluyéndolos literalmente en la
cadena.

   No existe en Maxima el tipo de variable carácter, debiéndose
representar un carácter simple como una cadena de un solo carácter.

   En Maxima, las cadenas de caracteres se implementan como símbolos de
Lisp, no como cadenas de Lisp, lo cual puede cambiar en versiones
futuras de Maxima.  Maxima puede representar cadenas y caracteres de
Lisp, aunque algunas operaciones, como las pruebas de igualdad, pueden
no funcionar correctamente.

   El paquete adicional `stringproc' contiene muchas funciones que
permiten trabajar con cadenas.

   Ejemplos:

     (%i1) s_1 : "This is a Maxima string.";
     (%o1)               This is a Maxima string.
     (%i2) s_2 : "Embedded \"double quotes\" and backslash \\ characters.";
     (%o2) Embedded "double quotes" and backslash \ characters.
     (%i3) s_3 : "Embedded line termination
     in this string.";
     (%o3) Embedded line termination
     in this string.
     (%i4) s_4 : "Ignore the \
     line termination \
     characters in \
     this string.";
     (%o4) Ignore the line termination characters in this string.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)               This is a Maxima string.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)              "This is a Maxima string."


File: maxima.info,  Node: Desigualdades,  Next: Sintaxis,  Prev: Cadenas de caracteres,  Up: Expresiones

6.7 Desigualdades
=================

Maxima dispone de los operadores de desigualdad `<', `<=', `>=', `>',
`#' y `notequal'.  Véase `if' para una descripción de las expresiones
condicionales.


File: maxima.info,  Node: Sintaxis,  Next: Funciones y variables para expresiones,  Prev: Desigualdades,  Up: Expresiones

6.8 Sintaxis
============

Es posible definir nuevos operadores con una precedencia especificada,
o eliminar o redefinir la precedencia de operadores ya existentes.  Un
operador puede ser de tipo prefijo unario o postfijo unario, infijo
binario, infijo `n'-ario, "bi-fijo" (matchfix) o "no-fijo"; "bi-fijo"
se refiere a un par de símbolos que encierran su o sus argumentos, y
"no-fijo" es un operador que no necesita argumentos.  A continuación
ejemplos sobre los diferentes tipos de operadores.

prefijo unario
     negación `- a'

postfijo unario
     factorial `a!'

infijo binario
     exponenciación `a^b'

n-ary infix
     suma `a + b'

"bi-fijo"
     construcción de una lista `[a, b]'

   (Maxima no incluye operadores "no-fijos", pero se puede ver un
ejemplo en `nofix'.)

   El mecanismo para definir un nuevo operador es sencillo.  Tan solo
es necesario declarar una función como operador; la función operador
puede estar definida o no.

   Un ejemplo de operador definido por el usuario es el siguiente.
Nótese que la llamada a función `"dd" (a)' equivale a `dd a', de igual
manera que  `"<-" (a, b)' también equivale a `a <- b'.  Nótese también
que las funciones `"dd"' y `"<-"' no están definidas en este ejemplo.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   Las funciones de Maxima que definen nuevos operadores se resumen en
esta tabla, en la que se establecen las fuerzas de enlace a izquierda
(lbp, de left binding power) y a derecha (rbp, de right binding power)
por defecto.  (La fuerza de enlace determina la precedencia del
operador. Sin embargo, puesto que las fuerzas de enlace a izquierda y
derecha pueden ser diferentes, la fuerza de enlace es algo más que la
simple precedencia.)  Algunas de las funciones para definir operadores
toman argumentos adicionales; véanse las descripciones de estas
funciones para más detalles.

`prefix'
     rbp=180

`postfix'
     lbp=180

`infix'
     lbp=180, rbp=180

`nary'
     lbp=180, rbp=180

`matchfix'
     (la fuerza de enlace no se aplica aquí)

`nofix'
     (la fuerza de enlace no se aplica aquí)

   A efectos comparativos, aquí se presentan algunos operadores de
Maxima junto con sus fuerzas de enlace a izquierda y derecha.

     Operator   lbp     rbp

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   Las funciones `remove' y `kill' eliminan propiedades de operadores
de un átomo.  La llamada `remove ("<a>", op)' sólo elimina las
propiedades de operador de <a>.  La llamada `kill ("<a>")' elimina
todas las propiedades de <a>, incluidas las propiedades de operador.
Nótese que el nombre del operador debe ir entre comillas.

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)


File: maxima.info,  Node: Funciones y variables para expresiones,  Prev: Sintaxis,  Up: Expresiones

6.9 Funciones y variables para expresiones
==========================================

 -- Función: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Función: at (<expr>, <eqn>)
     Evalúa la expresión <expr> asignando a las variables los valores
     especificados para ellas en la lista de ecuaciones `[<eqn_1>, ...,
     <eqn_n>]' o en la ecuación simple <eqn>.

     Si una subexpresión depende de cualquiera de las variables para la
     cual se especifica un valor, pero  no puede ser evaluado, entonces
     `at' devuelve una forma nominal.

     La función `at' realiza múltiples sustituciones en serie, no en
     paralelo.

     Véase también `atvalue'.  Para otras funciones que también llevan
     a cabo sustituciones, consúltense `subst' y `ev'.

     Ejemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Función: box (<expr>)
 -- Función: box (<expr>, <a>)
     Devuelve <expr> encerrada en una caja.  El valor devuelto es una
     expresión con `box' como operador y <expr> como argumento.  Se
     dibujará una caja cuando `display2d' valga `true'.

     La llamada `box (<expr>, <a>)' encierra <expr> en una caja
     etiquetada con el símbolo <a>.  La etiqueta se recorta si es más
     larga que el ancho de la caja.

     La función `box' evalúa su argumento. Sin embargo, la expresión
     encerrada no se evalúa, siendo excluída de los cálculos.

     La variable `boxchar' guarda el carácter a utilizar para dibujar
     la caja en las funciones `box', `dpart' y `lpart'.

     Ejemplos:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""
          (%i7) boxchar: "-";
          (%o7)                           -
          (%i8) box (sin(x) + cos(y));
                                  -----------------
          (%o8)                   -cos(y) + sin(x)-
                                  -----------------


 -- Variable opcional: boxchar
     Valor por defecto: `"'

     La variable `boxchar' guarda el carácter a utilizar para dibujar
     la caja en las funciones `box', `dpart' y `lpart'.

     Todas las cajas en una expresión se dibujan con el valor actual de
     `boxchar', carácter que no se almacena con las expresión encerrada.


 -- Función: carg (<z>)
     Devuelve el argumento complejo de <z>.  El argumento complejo es
     un ángulo `theta' en `(-%pi, %pi]' tal que `r exp (theta %i) =
     <z>' donde `r' es la magnitud de <z>.

     La función `carg' es computacional, no simplificativa.

     La función `carg' ignora la declaración `declare (<x>, complex)',
     y trata a <x> como una variable real.  Se trata de un fallo
     conocido en Maximo.  Véanse también `abs' (módulo complejo),
     `polarform', `rectform', `realpart' y `imagpart'.

     Ejemplos:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Operator especial: constant
     La llamada `declare (<a>, constant)' declara <a> como constante.
     Véase `declare'.


 -- Función: constantp (<expr>)
     Devuelve `true' si <expr> es una expresión constante y `false' en
     caso contrario.

     Una expresión se considera constante si sus argumentos son números
     (incluidos los números racionales que se muestran con `/R/'),
     constantes simbólicas como `%pi', `%e' o `%i', variables con valor
     constante o declarada como constante por `declare', o funciones
     cuyos argumentos son constantes.

     La función `constantp' evalúa sus argumentos.

     Ejemplos:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)

 -- Función: declare (<a_1>, <f_1>, <a_2>, <f_2>, ...)
     Asigna al átomo o lista de átomos <a_i> la propiedad o lista de
     propiedades<p_i>. Si <a_i> y/o <p_i> son listas, cada uno de los
     átomos adquiere todas las propiedades.

     La función `declare' no evalúa sus argumentos y siempre devuelve la
     expresión `done'.

     La llamada `featurep (<object>, <feature>)' devuelve `true' si
     <object> ha sido previamente declarado como poseedor de la
     propiedad <feature>. No obstante, `featurep' no reconoce algunas
     propiedades, lo cual es un fallo conocido de Maxima.

     Véase también `features'.

     La función `declare' reconoce las siguientes propiedades:


          `evfun' Hace que <a_i> sea reconocida por `ev', de manera que
          la función nombrada por <a_i> se aplique cuando <a_i>
          aparezca como argumento de control de `ev'.  Véase `evfun'.

    `evflag'
          Hace que <a_i> sea reconocida por `ev', de manera que a <a_i>
          se le asigne el valor `true' durante la ejecución de `ev'
          cuando <a_i> aparezca como argumento de control de `ev'.

    `bindtest'
          Hace que Maxima envíe un error si <a_i> es evaluado sin
          habérsele asignado un valor.

    `noun'
          Hace que Maxima considere a <a_i> como un nombre. El efecto
          que se obtiene es que se reemplazan todas las expresiones
          <a_i> por `'<a_i>' o `nounify (<a_i>)', dependiendo del
          contexto.

    `constant'
          Hace que Maxima considere a <a_i> como una constante
          simbólica.

    `scalar'
          Hace que Maxima considere a <a_i> como una variable escalar.

    `nonscalar'
          Hace que Maxima considere a <a_i> como una variable no
          escalar.  Se aplica comúnmente para declarar una variable
          como un vector simbólico o una matriz simbólica.

    `mainvar'
          Hace que Maxima considere a <a_i> como una "variable
          principal" (`mainvar'); `ordergreatp' determina la ordenación
          de los átomos como sigue:

          (variables principales) > (otras variables) > (variables
          escalares) > (constantes) > (números)

    `alphabetic'
          Indica a Maxima que reconozca todos los caracteres de la
          cadena alfanumérica <a_i> como caracteres alfabéticos.

    `feature'
          Hace que Maxima considere a <a_i> como el nombre de una
          propiedad.  Otros átomos podrán ser declarados entonces como
          poseedores de la propiedad <a_i>.

    `rassociative', `lassociative'
          Hace que Maxima reconozca a <a_i> como una función asociativa
          por la derecha o por la izquierda.

    `nary'
          Hace que Maxima reconozca a <a_i> como una función n-aria.

          La declaración `nary' no es equivalente a la función `nary'.
          El único efecto de `declare(foo, nary)' consiste en hacer que
          el simplificador de Maxima reduzca expresiones anidadas; por
          ejemplo, para transformar `foo(x, foo(y, z))' a `foo(x, y,
          z)'.

    `symmetric', `antisymmetric', `commutative'
          Hace que Maxima reconozca a <a_i> como una función simétrica o
          antisimétrica. La propiedad `commutative' equivale a
          `symmetric'.

    `evenfun', `oddfun'
          Hace que Maxima reconozca a <a_i> como una función par o
          impar.

    `outative'
          Hace que Maxima simplifique las expresiones <a_i> extrayendo
          los factores constantes del primer argumento.

          Cuando <a_i> tenga un único argumento, un factor se
          considerará constante si es una constante literal o declarada.

          Cuando <a_i> tenga dos o más argumentos, un factor se
          considerará constante si el segundo argumento es un símbolo y
          el factor no contiene al segundo argumento.

    `multiplicative'
          Hace que Maxima simplifique las expresiones <a_i> haciendo
          uso de la sustitución `<a_i>(x * y * z * ...)' `-->'
          `<a_i>(x) * <a_i>(y) * <a_i>(z) * ...'.  Tal sustitución se
          aplica únicamente al primer argumento.

    `additive'
          Hace que Maxima simplifique las expresiones <a_i> haciendo
          uso de la sustitución `<a_i>(x + y + z + ...)' `-->'
          `<a_i>(x) + <a_i>(y) + <a_i>(z) + ...'.  Tal sustitución se
          aplica únicamente al primer argumento.

    `linear'
          Equivale a declarar <a_i> conjuntamente como `outative' y
          `additive'.

    `integer', `noninteger'
          Hace que Maxima reconozca a <a_i> como una variable entera o
          no entera.

    `even', `odd'
          Hace que Maxima reconozca a <a_i> como una variable entera
          par o impar.

    `rational', `irrational'
          Hace que Maxima reconozca a <a_i> como una variable real
          racional o irracional.

    `real', `imaginary', `complex'
          Hace que Maxima reconozca a <a_i> como una variable real,
          imaginaria o compleja.


          `increasing', `decreasing' Hace que Maxima reconozca a <a_i>
          como una función creciente o decreciente.

    `posfun'
          Hace que Maxima reconozca a <a_i> como una función positiva.

    `integervalued'
          Hace que Maxima reconozca a <a_i> como una función de valor
          entero.


     Ejemplos:

     Declaraciones en base a `evfun' y `evflag'.
          (%i1) declare (expand, evfun);
          (%o1)                         done
          (%i2) (a + b)^3;
                                             3
          (%o2)                       (b + a)
          (%i3) (a + b)^3, expand;
                               3        2      2      3
          (%o3)               b  + 3 a b  + 3 a  b + a
          (%i4) declare (demoivre, evflag);
          (%o4)                         done
          (%i5) exp (a + b*%i);
                                       %i b + a
          (%o5)                      %e
          (%i6) exp (a + b*%i), demoivre;
                                a
          (%o6)               %e  (%i sin(b) + cos(b))

     Declaración en base a  `bindtest'.
          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

     Declaración en base a  `noun'.
          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

     Declaraciones en base a `constant', `scalar', `nonscalar' y
     `mainvar'.

     Declaración en base a `alphabetic'.
          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

     Declaración en base a `feature'.
          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

     Declaraciones en base a `rassociative' y `lassociative'.

     Declaración en base a `nary'.
          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

     Declaraciones en base a `symmetric' y `antisymmetric'.
          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

     Declaraciones en base a `oddfun' y `evenfun'.
          (%i1) o (- u) + o (u);
          (%o1)                     o(u) + o(- u)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- u) + o (u);
          (%o3)                           0
          (%i4) e (- u) - e (u);
          (%o4)                     e(- u) - e(u)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- u) - e (u);
          (%o6)                           0

     Declaración en base a `outative'.
          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

     Declaración en base a `multiplicative'.
          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

     Declaración en base a `additive'.
          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

     Declaración en base a `linear'.
          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1


 -- Función: disolate (<expr>, <x_1>, ..., <x_n>)
     Es similar a `isolate (<expr>, <x>)', excepto que permite al
     usuario aislar más de una variable simultáneamente. Puede ser útil
     para hacer un cambio de variables en integrales múltiples en las
     que tales variables dependan de de dos o más variables de
     integración.  Esta función se carga automáticamente desde
     `simplification/disol.mac'.  Se dispone de una demostyración en
     `demo("disol")$'.


 -- Función: dispform (<expr>)
     Devuelve la representación externa de <expr> con respecto a su
     operador principal. Es útil cuando se usa conjuntamente con
     `part', que también trata de la representación externa.  Sipóngase
     que  <expr> es -A .  Entonces la representación interna de  <expr>
     es "*"(-1,A), mientras que la representación externa es "-"(A). La
     llamada `dispform (<expr>, all)' convierte la expresión entera al
     formato externo.  Por ejemplo, si `expr: sin (sqrt (x))', entonces
     `freeof (sqrt, expr)' y `freeof (sqrt, dispform (expr))' dan
     `true', mientras que `freeof (sqrt, dispform (expr, all))' da
     `false'.


 -- Función: distrib (<expr>)
     Diistribuye sumas sobre productos.  Difiere de `expand' en que
     trabaja sólo al nivel superior de una expresión, siendo más rápida
     que `expand'.  Difiere de  `multthru' en que expande todas las
     sumas del nivel superior.

     Ejemplos:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Función: dpart (<expr>, <n_1>, ..., <n_k>)
     Selecciona la misma expresión que `part', pero en lugar de
     devolver esa expresión como su valor, devuelve la expresión
     completa con la subexpresión seleccionada dentro de una caja. La
     caja es parte de la expresión.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """


 -- Función: exp (<x>)
     Representa la función exponencial.  La expresión  `exp (<x>)' en
     la entrada se simplifica en `%e^<x>'; `exp' no aparece en
     expresiones simplificadas.

     Si la variable `demoivre' vale `true' hace que `%e^(a + b %i)' se
     simplifique a `%e^(a (cos(b) + %i sin(b)))' si `b' no contiene a
     `%i'. Véase `demoivre'.

     Si la variable `%emode' vale `true', hace que  `%e^(%pi %i x)' se
     simplifique. Véase `%emode'.

     Si la variable `%enumer' vale `true' hace que `%e' se reemplace por
     2.718...  siempre que `numer' valga `true'. Véase `%enumer'.


 -- Variable opcional: %emode
     Valor por defecto: `true'

     Si `%emode' vale `true', `%e^(%pi %i x)' se simplifica como sigue.

     `%e^(%pi %i x)' se simplifica a `cos (%pi x) + %i sin (%pi x)' si
     `x' es un entero o múltiplo de 1/2, 1/3, 1/4 o 1/6, y luego se
     sigue simplificando.

     Para otros valores numéricos de `x', `%e^(%pi %i x)' se simplifica
     a `%e^(%pi %i y)' donde `y' es `x - 2 k' para algún entero `k' tal
     que `abs(y) < 1'.

     Si `%emode' vale `false', no se realizan simplificaciones
     especiales a `%e^(%pi %i x)'.


 -- Variable opcional: %enumer
     Valor por defecto: `false'

     Si la variable `%enumer' vale `true' hace que `%e' se reemplace por
     2.718...  siempre que `numer' valga `true'.

     Si `%enumer' vale `false', esta sustitución se realiza sólo si el
     exponente en `%e^x' tiene un valor numérico.

     Véanse también `ev' y `numer'.


 -- Variable opcional: exptsubst
     Valor por defecto: `false'

     Si `exptsubst' vale `true' permite la sustitución `y' por `%e^x'
     en `%e^(a x)'.


 -- Función: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof (<x_1>, <expr>)' Devuelve `true' si ninguna subexpresión
     de  <expr> es igual a <x_1> o si  <x_1> aparece como variable muda
     en <expr>, devolviendo `false' en otro caso.

     La llamada `freeof (<x_1>, ..., <x_n>, <expr>)' equivale a `freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     Los argumentos <x_1>, ..., <x_n> pueden seer nombres de funciones
     y variables, nombres subindicados, operadores (encerrados entre
     comillas dobles) o expresiones generales.  La función `freeof'
     evalúa sus argumentos.

     Una variable es una variable muda en una expresión si no tiene
     valor asignado fuera de la expresión.  Variable mudas reconocidas
     por  `freeof' son el índice de una suma o producto, la variable
     límite en `limit', la variable de integración en la versión de
     integral definida de `integrate', la variable original en
     `laplace', variables formales en expresiones `at' y los argumentos
     de las expresiones  `lambda'.  Las variables locales en  `block'
     no son reconocidas por `freeof' como variables mudas; esto es un
     fallo de Maxima.

     La versión indefinida de  `integrate' no está libre de su variable
     de integración.

        * Los argumentos son nombres de funciones, variables, nombres
          subindicados, operaores y expresiones. La llamada `freeof (a,
          b, expr)' equivale a `freeof (a, expr) and freeof (b, expr)'.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        * `freeof' evalúa sus argumentos.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        * `freeof' no considera funciones equivalentes.  La
          simplificación puede dar una expresión equivalente pero
          diferente.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        * Un sumatorio o integral definida está libre de su variable
          muda.  Una integral indefinida de  `integrate' no está libre
          de su variable de integración

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false


 -- Función: genfact (<x>, <y>, <z>)
     Devuelve el factorial generalizado, definido como `x (x-z) (x - 2
     z) ... (x - (y - 1) z)'.  Así, para el entero <x>, `genfact (x, x,
     1) = x!' y `genfact (x, x/2, 2) = x!!'.


 -- Función: imagpart (<expr>)
     Devuelve la parte imaginaria de la expresión <expr>.

     La función `imagpart' es computacional, no simplificativa.

     Véanse también `abs', `carg', `polarform', `rectform' y `realpart'.


 -- Función: infix (<op>)
 -- Función: infix (<op>, <lbp>, <rbp>)
 -- Función: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declara <op> como operador infijo.  Un operador infijo es una
     función de dos argumentos, con el nombre de la función escrito
     entre sus argumentos.  Por ejemplo, el operador de sustracción `-'
     es un operador infijo.

     `infix (<op>)' declara <op> como operador infijo con fuerzas de
     ligadura por la izquierda y por la derecha iguales a 180, que es
     el valor por defecto, y partes izquierda y derecha iguales a `any'.

     `infix (<op>, <lbp>, <rbp>)' declara <op> como operador infijo con
     fuerzas de ligadura por la izquierda y por la derecha declaradas
     en los argumentos, siendo las partes izquierda y derecha iguales a
     `any'.

     `infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declara <op>
     como operador infijo con fuerzas de ligadura por la izquierda y
     por la derecha y partes declaradas en los argumentos.

     La precedencia de <op> con respecto a otros operadores deriva de
     las fuerzas de ligadura de los operadores en cuestión.  Si las
     fuerzas de ligadura a izquierda y derecha de <op> son ambas
     mayores que las fuerzas de ligadura a izquierda y derecha de otro
     operador, entonces <op> tiene preferencia sobre el otro operador.
     Si las fuerzas de ligadura no son ambas mayores o menores, se
     aplican otras relaciones más complejas.

     La asociatividad de <op> depende de las fuerzas de ligadura.  Una
     mayor fuerza de ligadura a la izquierda (<lbp>) implica que <op>
     sea evaluado antes que otros operadores a su izquierda en la
     expresión, mientras que mayor fuerza de ligadura a la derecha
     (<rbp>) implica que <op> sea evaluado antes que otros operadores a
     su derecha en la expresión.  Así, si <lbp> es mayor, <op> es
     asociativo por la derecha, mientras que si <rbp> es mayor, <op> es
     asociativo por la izquierda.

     Véase también `Syntax'.

     Ejemplos:

     Si las fuerzas de ligadura a izquierda y derecha de <op> son ambas
     mayores que las fuerzas de ligadura a izquierda y derecha de otro
     operador, entonces <op> tiene preferencia sobre el otro operador.

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     Mayor <lbp> hace a <op> asociativo por la derecha, mientras que
     mayor  <rbp> hace a <op> asociativo por la izquierda.

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)


 -- Variable opcional: inflag
     Valor por defecto: `false'

     Si `inflag' vale `true', las funciones para la extracción de
     partes inspeccionan la forma interna de `expr'.

     Nótese que el simplificador reordena expresiones.  Así,  `first (x
     + y)' devuelve `x' si `inflag' vale `true' y `y' si `inflag' vale
     `false'.  (`first (y + x)' devuelve el mismo resultado.)

     Además, dándole a  `inflag' el valor `true' y llamando a `part' o
     a `substpart' es lo mismo que llamar a `inpart' o a `substinpart'.

     Las funciones que se ven afectadas por el valor de `inflag' son:
     `part', `substpart', `first', `rest', `last', `length', la
     construcción `for' ... `in', `map', `fullmap', `maplist', `reveal'
     y `pickapart'.


 -- Función: inpart (<expr>, <n_1>, ..., <n_k>)
     Similar a `part', pero trabaja con la representación interna de la
     expresión, siendo más rápida. Se debe tener cuidado con el orden
     de subexpresiones en sumas y productos, pues el orden de las
     variables en la forma interna es normalmente diferente al que se
     muestra por el terminal, y cuando se trata con el signo menos
     unario, resta y división, pues estos operadores desaparecen de la
     expresión. Las llamadas `part (x+y, 0)' o `inpart (x+y, 0)'
     devuelven `+', siendo necesario encerrar el operador entre
     comillas dobles cuando se haga referencia aél. Por ejemplo, `...
     if inpart (%o9,0) = "+" then ...'.

     Ejemplos:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Función: isolate (<expr>, <x>)
     Devuelve <expr> con subexpresiones que son sumas y que no
     contienen variables reemplazadas por etiquetas de expresiones
     intermedias (tales etiquetas son símbolos atómicos como `%t1',
     `%t2', ...).  Esta función es de utilidad para evitar la expansión
     innecesaria de subexpresiones que no contienen la variable de
     interés. Puesto que las etiquetas intermedias toman el valor de
     subexpresiones pueden ser todas sustituidas evaluando la expresión
     en la que aparecen.

     Si la variable `exptisolate', cuyo valor por defecto es `false',
     vale `true' hará que `isolate' busque exponentes de átomos (como
     `%e') que contengan la variable.

     Si `isolate_wrt_times' vale `true', entonces `isolate' también
     aislará respecto de los productos. Véase `isolate_wrt_times'.

     Para ejemplos, ejecútese `example (isolate)'.


 -- Variable opcional: isolate_wrt_times
     Valor por defecto: `false'

     Si `isolate_wrt_times' vale `true', entonces `isolate' también
     aislará respecto de los productos. Compárese el comportamiento de
     `isolate' al cambiar el valor de esta variable global en el
     siguiente ejemplo,

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Variable opcional: listconstvars
     Valor por defecto: `false'

     Si `listconstvars' vale `true', hará que `listofvars' incluya
     `%e', `%pi', `%i' y cualquier otra variable que sea declarada
     constante de las que aparezcan en el argumento de `listofvars'.
     Estas constantes se omiten por defecto.


 -- Variable opcional: listdummyvars
     Valor por defecto: `true'

     Si `listdummyvars' vale `false', las "variables mudas" de la
     expresión no serán incluídas en la lista devuelta por
     `listofvars'. (La definición de "variables mudas" se encuentra en
     la descripción de `freeof'.  "Variables mudas" son objetos
     matemáticos como el índice de un sumatorio o producto, una
     variable límite o la variable de una integración definida.)
     Ejemplo:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Función: listofvars (<expr>)
     Devuelve una lista con las variables presentes en <expr>.

     Si la variable `listconstvars' vale `true' entonces  `listofvars'
     incluirá `%e', `%pi', `%i'y cualquier otra variable declarada
     constante de las que aparezcan en <expr>.  Estas constantes se
     omiten por defecto.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Función: lfreeof (<list>, <expr>)
     Para cada miembro  <m> de <list>, realiza la llamada `freeof (<m>,
     <expr>)'.  Devuelve `false' si alguna de estas llamadas a `freeof'
     retornó `false', y `true' en caso contrario.

 -- Función: lopow (<expr>, <x>)
     Devuelve el mínimo exponente de <x> que aparece explícitamente en
     <expr>.  Así,

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)


 -- Función: lpart (<label>, <expr>, <n_1>, ..., <n_k>)
     Similar a `dpart' pero utiliza una caja etiquetada. Una caja
     etiquetada es similar a la que produce `dpart', pero con un nombre
     en la línea superior.


 -- Función: multthru (<expr>)
 -- Función: multthru (<expr_1>, <expr_2>)
     Multiplica un factor (que debería ser una suma) de <expr> por los
     otros factores de <expr>.  Esto es, <expr> es `<f_1> <f_2> ...
     <f_n>', donde al menos un factor, por ejemplo <f_i>, es una suma
     de términos.  Cada término en esta suma se multiplica por los
     otros factores del producto, excepto el propio <f_i>. La función
     `multthru' no expande sumas elevadas a exponentes, siendo el
     método más rápido para distribuir productos (sean o no
     conmutativos) sobre sumas. Puesto que los cocientes se representan
     como productos, puede utilizarse`multthru' para dividir sumas
     entre productos.

     La llamada `multthru (<expr_1>, <expr_2>)' multiplica cada término
     de <expr_2> (que debería ser una suma o una ecuación) por
     <expr_1>.  Si <expr_1> no es ella misma una suma, entonces la
     llamada es equivalente a `multthru (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Función: nounify (<f>)
     Devuelve la forma nominal de la función cuyo nombre es <f>.  Puede
     ser útil cuando se quiera hacer referencia al nombre de una
     función sin que ésta se ejecute.  Nótese que algunas funciones
     verbales devolverán su forma nominal si no pueden ser evaluadas
     para ciertos argumentos.  Esta es también la expresión que se
     obtiene cuando la llamada a una función va precedida por del
     apóstrofo.


 -- Función: nterms (<expr>)
     Devuelve el número de términos que  <expr> llegaría a tener si
     fuese completamente expandida y no hubiesen cancelaciones ni
     combinaciones de términos semejantes.  Nótese que expresiones como
     `sin (<expr>)', `sqrt (<expr>)', `exp (<expr>)', etc.  cuentan
     como un sólo término, independientemente de cuántos términos tenga
     a su vez <expr> en caso de tratarse de una suma.


 -- Función: op (<expr>)
     Devuelve el operador principal de la expresión <expr>. La llamada
     `op (<expr>)' equivale a `part (<expr>, 0)'.

     La función `op' devuelve una cadena si el operador principal es un
     operador prefijo, infijo (binario o `n'-ario), postfijo, "bi-fijo"
     o "no-fijo" ("bi-fijo"  se refiere a un par de símbolos que
     encierran su o sus argumentos, y "no-fijo" es un operador que no
     necesita argumentos).  Si <expr> es la expresión de una función
     subindicada, `op' devuelve la función subindicada; en cuyo caso el
     valor devuelto no es un átomo.  En otro caso, <expr> es la
     expresión de una función array u ordinaria, y entonces `op'
     devuelve un símbolo.

     La función `op' observa el valor de la variable global `inflag'.

     La función `op' evalúa sus argumentos.

     Véase también `args'.

     Ejemplos:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G


 -- Función: operatorp (<expr>, <op>)
 -- Función: operatorp (<expr>, [<op_1>, ..., <op_n>])
     La llamada `operatorp (<expr>, <op>)' devuelve `true' si <op> es
     igual al operador de <expr>.

     La llamada `operatorp (<expr>, [<op_1>, ..., <op_n>])' devuelve
     `true' si algún elemento  <op_1>, ..., <op_n> es igual al operador
     de <expr>.


 -- Función: optimize (<expr>)
     Devuelve una expresión que produce el mismo valor y efectos
     secundarios que <expr>, pero de forma más eficiente al evitar
     recalcular subexpresiones comunes. La función `optimize' también
     tiene el efecto secundario de colapsar su argumento de manera que
     se compartan todas sus subexpresiones comunes.  Hágase `example
     (optimize)' para ver ejemplos.


 -- Variable opcional: optimprefix
     Valor por defecto: `%'

     La variable `optimprefix' es el prefijo utilizado para los
     símbolos generados por la instrucción `optimize'.


 -- Función: ordergreat (<v_1>, ..., <v_n>)
     Establece una ordenación para las variables <v_1>, ..., <v_n> de
     manera que <v_1> > <v_2> > ...  > <v_n> y <v_n> > cualquier otra
     variable no mencionada como argumento.

     Véase también `orderless'.


 -- Función: ordergreatp (<expr_1>, <expr_2>)
     Devuelve `true' si <expr_2> precede a <expr_1> según el orden
     establecido con la función `ordergreat'.


 -- Función: orderless (<v_1>, ..., <v_n>)
     Establece una ordenación para las variables <v_1>, ..., <v_n> de
     manera que <v_1> < <v_2> < ...  < <v_n> y <v_n> < cualquier otra
     variable no mencionada como argumento.

     Así, la ordenación completa de objetos es: constantes numéricas <
     constantes declaradas < escalares declarados < primer argumento de
     `orderless' < ...  < último argumento de `orderless' < variables
     que empiezan por A < ...  < variables que empiezan por Z < último
     argumento de  `ordergreat' <  ... < primer argumento de
     `ordergreat' < objetos declarados como `mainvar'.

     Véanse también `ordergreat' y `mainvar'.


 -- Función: orderlessp (<expr_1>, <expr_2>)
     Devuelve `true' si <expr_1> precede a <expr_2> según el orden
     establecido con la función `orderless'.


 -- Función: part (<expr>, <n_1>, ..., <n_k>)
     Devuelve partes de la forma mostrada de `expr'. Obtiene la parte
     de `expr' que se especifica por los índices <n_1>, ..., <n_k>.
     Primero se obtiene la parte <n_1> de `expr', después la parte
     <n_2> del resultado anterior, y así sucesivamente.  El resultado
     que se obtiene es la parte <n_k> de ... la parte <n_2> de la parte
     <n_1> de `expr'.

     La función `part' se puede utilizar para obtener un elemento de
     una lista, una fila de una matriz, etc.

     Si el último argumento de la función `part' es una lista de
     índices, entonces se toman varias subexpresiones, cada una de las
     cuales correspondiente a un índice de la lista.  Así, `part (x + y
     + z, [1, 3])' devuelve `z+x'.

     La variable `piece' guarda la última expresión seleccionada con la
     función `part'. Se actualiza durante la ejecución de la función,
     por lo que puede ser referenciada en la misma función.

     Si `partswitch' vale `true' entonces de devuelve `end' cuando no
     exista la parte seleccionada de una expresión, si vale `false' se
     mostrará un mensaje de error.

     Ejemplo: `part (z+2*y, 2, 1)' devuelve 2.

     La instrucción `example (part)' muestra más ejemplos.


 -- Función: partition (<expr>, <x>)
     Devuelve una lista con dos expresiones, que son: (1) los factores
     de <expr> si es un producto, los términos de <expr> si es una
     suma, o los elementos de <expr>, si es una lista, que no contengan
     a <x>, (2) los factores, términos o lista que contengan a <x>.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Variable opcional: partswitch
     Valor por defecto: `false'

     Si `partswitch' vale `true' entonces de devuelve `end' cuando no
     exista la parte seleccionada de una expresión, si vale `false' se
     mostrará un mensaje de error.


 -- Función: pickapart (<expr>, <n>)
     Asigna etiquetas de expresiones intermedias a subexpresiones de
     <expr> al nivel de profundidad <n>, que es un entero. A las
     subexpresiones a un nivel de profundidad mayor o menor no se les
     asignan etiquetas. La función `pickapart' devuelve una expresión
     en términos de expresiones intermedias equivalente a la expresión
     original <expr>.

     Véanse también `part', `dpart', `lpart', `inpart' y `reveal'.

     Ejemplos:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- System variable: piece
     Guarda la última expresión seleccionada por las funciones `part'.


 -- Función: polarform (<expr>)
     Devuelve una expresión de la forma `r %e^(%i theta)' equivalente a
     <expr>, con `r' y `theta' son reales.


 -- Función: powers (<expr>, <x>)
     Devuelve las potencias de <x> dentro de <expr>.

     La instrucción `load (powers)' carga esta función.


 -- Función: product (<expr>, <i>, <i_0>, <i_1>)
     Representa el producto de los valores de `expr' según el índice
     <i> varía de <i_0> hasta <i_1>.  La forma nominal `'product' se
     presenta en forma de letra pi mayúscula.

     La función `product' evalúa <expr> y los límites inferior y
     superior, <i_0> y <i_1>, pero no evalúa el índice <i>.

     Si la diferencia entre los límites superior e inferior es un
     número entero, la expresión <expr> se evalúa para cada valor del
     índice <i>, siendo el resultado un producto en forma explícita.

     En caso contrario, el rango del índice no está definido,
     aplicándose entonces algunas reglas que permitan simplificar el
     producto.  Cuando la variable global `simpproduct' valga `true',
     se aplicarán reglas adicionales.  En ciertos casos, la
     simplificación dará lugar a un resultado que ya no tenga el
     formato del producto; en caso contrario se devolverá una forma
     nominal `'product'.

     Véanse también `nouns' y `evflag'.

     Ejemplos:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b


 -- Función: realpart (<expr>)
     Devuelve la parte real de <expr>. La funciones `realpart' y
     `imagpart' operan también con expresiones que contengan funciones
     trigonométricas e hiperbólicas, raíces cuadradas, logaritmos y
     exponentes.


 -- Función: rectform (<expr>)
     Devuelve una expresión de la forma `a + b %i' equivalente a
     <expr>, con <a> y <b> reales.


 -- Función: rembox (<expr>, unlabelled)
 -- Función: rembox (<expr>, <label>)
 -- Función: rembox (<expr>)
     Elimina cajas de <expr>.

     La llamada `rembox (<expr>, unlabelled)' elimina todas las cajas
     no etiquetadas de <expr>.

     La llamada `rembox (<expr>, <label>)' sólo elimina las cajas
     etiquetadas con <label>.

     La llamada `rembox (<expr>)' elimina todas las caajs,
     independientemente de que estén etiquetadas o no.

     Las cajas son dibujadas por las funciones `box', `dpart' y `lpart'.

     Ejemplos:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Función: sum (<expr>, <i>, <i_0>, <i_1>)
     Representa la suma de los valores de `expr' según el índice <i>
     varía de <i_0> hasta <i_1>.  La forma nominal `'sum' se presenta
     en forma de letra sigma mayúscula.

     La función `sum' evalúa su sumando <expr> y los límites inferior y
     superior, <i_0> y <i_1>, pero no evalúa el índice <i>.

     Si la diferencia entre los límites superior e inferior es un
     número entero, el sumando <expr> se evalúa para cada valor del
     índice <i>, siendo el resultado una suma en forma explícita.

     En caso contrario, el rango del índice no está definido,
     aplicándose entonces algunas reglas que permitan simplificar la
     suma.  Cuando la variable global `simpsum' valga `true', se
     aplicarán reglas adicionales.  En ciertos casos, la simplificación
     dará lugar a un resultado que ya no tenga el formato del
     sumatorio; en caso contrario se devolverá una forma nominal
     `'product'.

     Cuando `cauchysum' vale `true', el producto de sumatorios se
     expresa como un producto de Cauchy, en cuyo caso el índice del
     sumatorio interior es función del índice del exterior, en lugar de
     variar independientemente.

     La variable global `genindex' guarda el prefijo alfabético a
     utilizar cuando sea necesario generar automáticamente el siguiente
     índice de sumatorio.

     La variable global `gensumnum' guarda el sufijo numérico a
     utilizar cuando sea necesario generar automáticamente el siguiente
     índice de sumatorio. Si `gensumnum' vale `false', un índice
     generado automáticamente constará sólo de `genindex', sin sufijo
     numérico.

     Véanse también `sumcontract', `intosum', `bashindices',
     `niceindices', `nouns' y `evflag'.

     Ejemplos:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
          Incorrect syntax: Too many )'s
          else b^k, k, 1, 10))
                            ^
          (%i12) linenum:11;
          (%o11)                         11
          (%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o12)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a


 -- Función: lsum (<expr>, <x>, <L>)
     Representa la suma de <expr> para cada elemento <x> en <L>.

     Se retornará la forma nominal `'lsum' si el argumento <L> no es
     una lista.

     Ejemplos:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)


 -- Función: verbify (<f>)
     Devuelve la forma verbal del nombre de función <f>.

     Véanse también `verb', `noun' y `nounify'.

     Ejemplos:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Simplificación,  Next: Gráficos,  Prev: Expresiones,  Up: Top

7 Simplificación
****************

* Menu:

* Funciones y variables para simplificación::


File: maxima.info,  Node: Funciones y variables para simplificación,  Prev: Simplificación,  Up: Simplificación

7.1 Funciones y variables para simplificación
=============================================

 -- Variable del sistema: askexp
     Cuando se invoca a `asksign', la expresión que se va a analizar es
     precisamente `askexp'.


 -- Función: askinteger (<expr>, integer)
 -- Función: askinteger (<expr>)
 -- Función: askinteger (<expr>, even)
 -- Función: askinteger (<expr>, odd)
     La llamada `askinteger (<expr>, integer)' intenta determinar a
     partir de la base de datos de `assume' si <expr> es un entero. La
     función `askinteger' pide más información al usuario si no
     encuentra la respuesta, tratando de almacenar la nueva información
     en la base de datos si es posible. La llamada `askinteger
     (<expr>)' equivale a `askinteger (<expr>, integer)'.

     La llamadas `askinteger (<expr>, even)' ay `askinteger (<expr>,
     odd)' intentan determinar si <expr> es un entero par o impar,
     respectivamente.


 -- Función: asksign (<expr>)
     Primero intenta determinar si la expresión especificada es
     positiva, negativa o cero.  Si no lo consigue, planteará al
     usuario preguntas que le ayuden a conpletar la deducción. Las
     respuestas del usuario son almacenadas en la base de datos durante
     el tiempo que dure este cálculo. El valor que al final devuelva
     `asksign' será `pos', `neg' o `zero'.


 -- Función: demoivre (<expr>)
 -- Variable opcional: demoivre
     La función `demoivre (expr)' convierte una expresión sin modificar
     la variable global `demoivre'.

     Cuando `demoivre' vale `true', los exponenciales complejos se
     convierten en expresiones equivalentes pero en términos de las
     funciones trigonométricas: `exp (a + b*%i)' se reduce a `%e^a *
     (cos(b) + %i*sin(b))' si `b' no contiene a `%i'. Las expresiones
     `a' y `b' no se expanden.

     El valor por defecto de `demoivre' es `false'.

     La función `exponentialize' convierte funciones trigonométricas e
     hiperbólicas a la forma exponencial, por lo que  `demoivre' y
     `exponentialize' no pueden valer `true' al mismo tiempo.


 -- Variable opcional: domain
     Valor por defecto: `real'

     Si `domain' vale `complex', `sqrt (x^2)' permanecerá como `sqrt
     (x^2)' en lugar de devolver `abs(x)'.


 -- Función: expand (<expr>)
 -- Función: expand (<expr>, <p>, <n>)
     Expande la expresión <expr>. Los productos de sumas y de sumas con
     exponentes se multiplican, los numeradores de las expresiones
     racionales que son sumas se separan en sus respectivos términos, y
     las multiplicaciones (tanto las que son conmutativas como las que
     no) se distribuyen sobre las sumas en todos los niveles de <expr>.

     En el caso de los polinomios es más aconsejable utilizar
     `ratexpand', que utiliza un algoritmo más eficiente.

     Las variables `maxnegex' y `maxposex' controlan los máximos
     exponentes negativos y positivos que se van a expandir.

     La llamada `expand (<expr>, <p>, <n>)' expande <expr> asignando a
     `maxposex' el valor <p> y a `maxnegex' el <n>. Esto es útil para
     expandir sólo parte de la expresión.

     La variable `expon' guarda el mayor exponente negativo que será
     expandido automáticamente, independientemente de `expand'. Por
     ejemplo, si `expon' vale 4 entonces `(x+1)^(-5)' no se expandirá
     automáticamente.

     La variable `expop' guarda el mayor exponente positivo que será
     expandido automáticamente.  Así, `(x+1)^3' se expandirá
     automáticamente sólo si `expop' es mayor o igual que 3. Si se
     quiere expandir `(x+1)^n', siendo `n' mayor que `expop', entonces
     `expand ((x+1)^n)' se desarrollará sólo si `maxposex' no es menor
     que `n'.

     La variable `expand' utilizada con `ev' provocará una expansión.

     El fichero `simplification/facexp.mac' contiene algunas funciones
     relacionadas con `expand' (en concreto, `facsum', `factorfacsum' y
     `collectterms', que se cargan automáticamente) y variables
     (`nextlayerfactor' y `facsum_combine') que permiten al usuario
     estructurar las expresiones controlando la expansión.  En
     `simplification/facexp.usg' se pueden encontrar breves
     descripciones de estas funciones.  Se accederá a una demostración
     con la instrucción `demo("facexp")'.


 -- Función: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expande la expresión `expr' con respecto a las variables <x_1>,
     ..., <x_n>.  Todos los productos que contengan a las variables
     aparecen explícitamente. El resultado que se obtenga no tendr'a
     productos de sumas de expresiones que contengan a las variables.
     Los argumentos  <x_1>, ..., <x_n> pueden ser variables, operadores
     o expresiones.

     Por defecto, no se expanden los denominadores, pero esto puede
     cambiarse mediante el uso de la variable `expandwrt_denom'.

     Esta función se carga automáticamente de
     `simplification/stopex.mac'.


 -- Variable opcional: expandwrt_denom
     Valor por defecto: `false'

     La variable `expandwrt_denom' controla el tratamiento de las
     expresiones racinales por parte de `expandwrt'. Si vale `true', se
     expandirán tanto el numerador como el denominador de la expresión
     respecto de los argumentos de `expandwrt', pero si
     `expandwrt_denom' vale `false', sólo se expandirá el numerador.


 -- Función: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     Es similar a `expandwrt', pero trata a las expresiones que son
     productos de una forma algo diferente. La función
     `expandwrt_factored' expande sólo aquellos factores de `expr' que
     contienen a las variables <x_1>, ..., <x_n>.

     Esta función se carga automáticamente de
     `simplification/stopex.mac'.


 -- Variable opcional: expon
     Valor por defecto: 0

     La variable `expon' guarda el mayor exponente negativo que será
     expandido automáticamente, independientemente de `expand'. Por
     ejemplo, si `expon' vale 4 entonces `(x+1)^(-5)' no se expandirá
     automáticamente.


 -- Función: exponentialize (<expr>)
 -- Variable opcional: exponentialize
     La función `exponentialize (expr)' convierte las funciones
     trigonométricas e hiperbólicas de <expr> a exponenciales, sin
     alterar la variable global `exponentialize'.

     Cuando la variable `exponentialize' vale `true', todas las
     funciones trigonométricas e hiperbólicas se convierten a forma
     exponencial. El valor por defecto es `false'.

     La función `demoivre' convierte funciones trigonométricas e
     hiperbólicas a la forma exponencial, por lo que  `demoivre' y
     `exponentialize' no pueden valer `true' al mismo tiempo.


 -- Variable opcional: expop
     Valor por defecto: 0

     La variable `expop' guarda el mayor exponente positivo que será
     expandido automáticamente.  Así, `(x+1)^3' se expandirá
     automáticamente sólo si `expop' es mayor o igual que 3. Si se
     quiere expandir `(x+1)^n', siendo `n' mayor que `expop', entonces
     `expand ((x+1)^n)' se desarrollará sólo si `maxposex' no es menor
     que `n'.


 -- Variable opcional: factlim
     Valor por defecto: -1

     La variable `factlim' especifica el mayor factorial que será
     expandido automáticamente.  Si su valor es -1, entonces se
     expandirán todos los enteros.


 -- Función: intosum (<expr>)
     Mueve los factores multiplicativos que están fuera de un sumatorio
     hacia dentro de éste. Si el índice aparece en la expresión
     exterior, entonce `intosum' busca un índice razonable, lo mismo
     que hace con `sumcontract'. Se trata de la operación contraria a
     extraer factores comunes de los sumatorios.

     En algunos caos puede ser necesario hacer `scanmap (multthru,
     <expr>)' antes que `intosum'.


 -- Declaración: lassociative
     La instrucción `declare (g, lassociative)' le indica al
     simplificador de Maxima que `g' es asociativo por la izquierda.
     Por ejemplo, `g (g (a, b), g (c, d))'se reduce a `g (g (g (a, b),
     c), d)'.


 -- Declaración: linear
     Es una de las propiedades de operadores de Maxima. Si la función
     univariante `f' se declara lineal, la expansión de  `f(x + y)'
     produce `f(x) + f(y)', `f(a*x)' produce `a*f(x)' si `a' es una
     constante.  Si la función tiene dos o más argumentos, la
     linealidad se interpreta como la de `sum' o `integrate', esto es,
     `f (a*x + b, x)' produce `a*f(x,x) + b*f(1,x)' si `a' y `b' no
     contienen a `x'.

     `linear' equivale a `additive' y `outative'.  Véase también
     `opproperties'.


 -- Declaración: mainvar
     Se pueden declarar variables de tipo `mainvar'.  El orden de los
     átomos es: números < constantes (como `%e' o `%pi') < escalares <
     otras variables < "mainvars".  Por ejemplo, compárese `expand
     ((X+Y)^4)' con `(declare (x, mainvar), expand ((x+y)^4))'.  (Nota:
     Se debe tener cuidado si se quiere hacer uso de esta declaración.
     Por ejemplo, si se resta una expresión en la que `x' ha sido
     declarada como `mainvar' de otra en la que `x' no es `mainvar',
     puede ser necesario volver a simplificar, `ev (expr, simp)', a fin
     de obtener cancelaciones.  Además, si se guarda una expresión en
     la que `x' es `mainvar', quizás sea necesario guardar también `x'.)


 -- Variable opcional: maxapplydepth
     Valor por defecto: 10000

     La variable `maxapplydepth' es la máxima profundidad a la que van
     a introducirse `apply1' y  `apply2'.


 -- Variable opcional: maxapplyheight
     Valor por defecto: 10000

     La variable `maxapplyheight' es la m2'axima altura a la que
     escalará `applyb1' antes de detenerse.


 -- Variable opcional: maxnegex
     Valor por defecto: 1000

     La variable `maxnegex' es el mayor exponente negativo que
     expandirá la función `expand'. Véase también `maxposex'.


 -- Variable opcional: maxposex
     Valor por defecto: 1000

     La variable `maxposex' es el mayor exponenteque expandirá la
     función `expand'. Véase también `maxnegex'.


 -- Declaración: multiplicative
     La instrucción `declare (f, multiplicative)' indica al
     simplificador de Maxima que `f' is multiplicativa.

       1. Si `f' es univariante, cada vez que el simplificador
          encuentre a `f' aplicad a un producto, `f' se distribuirá
          sobre ese producto.  Por ejemplo, `f(x*y)' se reduciría a
          `f(x)*f(y)'.

       2. Si `f' es una función de 2 o más argumentos, la
          multiplicabilidad se define como multiplicabilidad para el
          primer argumento de `f', de modo que `f (g(x) * h(x), x)' se
          reduciría a `f (g(x) ,x) * f (h(x), x)'.

     Esta transformación no se realiza cuando `f' se aplica a
     expresiones de la forma `product (x[i], i, m, n)'.


 -- Variable opcional: negdistrib
     Valor por defecto: `true'

     Si `negdistrib' vale `true', -1 se distribuye sobre una expresión.
     Por ejemplo, `-(x + y)' se transforma en `- y - x'.  Dándole el
     valor `false' se mostrará `- (x + y)' tal cual. Esto puede ser
     útil, pero también peligroso; al igual que el indicador `simp', no
     conviene asignarle el valor `false'.


 -- Variable opcional: negsumdispflag
     Valor por defecto: `true'

     Si `negsumdispflag' vale `true', `x - y' se muestra como `x - y'
     en lugar de `- y + x'.  Dándole el valor `false' se realiza un
     análisis adicional para que no se representen de forma muy
     diferente dos expresiones similares.  Una aplicación puede ser
     para que `a + %i*b' y `a - %i*b' se representen ambas de la misma
     manera.


 -- Símbolo especial: noeval
     El símbolo `noeval' evita la fase de evaluación de `ev'. Es útil
     conjuntamente con otras variables globales y para poder volver a
     simplificar expresiones sin tener que evaluarlas otra vez.


 -- Declaración: noun
     El símbolo `noun' es una de las opciones de la instrucción
     `declare'. Hace que una función se declare como "nombre", lo que
     significa que no se evaluará automáticamente.


 -- Variable opcional: noundisp
     Valor por defecto: `false'

     Si `noundisp' vale `true', los nombres se muestran precedidos de
     un apóstrofo. Siempre debe valer `true' cuando se quiera
     representar la definición de funciones.


 -- Símbolo especial: nouns
     El símbolo `nouns' es una `evflag', lo que significa que cuando se
     utilice como una opción de la instrucción `ev', todas las formas
     nominales que aparezcan en una expresión las convierte en
     verbales, esto es, las evalúa.  Véanse también `noun', `nounify',
     `verb' y `verbify'.


 -- Símbolo especial: numer
     El símbolo `numer' hace algunas funciones matemáticas con
     argumentos numéricos se evalúen como decimales de punto flotante.
     También hace que las variables de una expresión a las cuales se
     les ha asignado un número sean sustituidas por sus valores.
     Además, activa la variable `float'.

 -- Función: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declara las variables `x_1', ..., <x_n> asignándoles los valores
     numéricos `expr_1', ..., `expr_n'.  El valor numérico se evalúa y
     sustituye a la variable en cualquier expresión en la que ésta
     aparezca si `numer' toma el valor `true'. Véase también `ev'.

     Las expresiones `expr_1', ..., `expr_n' pueden ser expresiones no
     necesariamente numéricas.

 -- Variable del sistema: opproperties
     La variable `opproperties' es la lista con las propiedades
     especiales de los operadores reconocidas por el simplificador de
     Maxima: `linear', `additive', `multiplicative', `outative',
     `evenfun', `oddfun', `commutative', `symmetric', `antisymmetric',
     `nary', `lassociative', `rassociative'.


 -- Variable opcional: opsubst
     Valor por defecto: `true'

     Si `opsubst' vale `false', `subst' no sustituye el operdor de una
     expresión, de manera que `(opsubst: false, subst (x^2, r,
     r+r[0]))' trabajará correctamente.


 -- Declaración: outative
     La instrucción `declare (f, outative)' le indica al simplificador
     de Maxima que los factores constantes del argumento de la función
     `f' pueden ser extraídos.

       1. Si `f' es univariante, cada vez que el simplificador se
          encuentra con `f' aplicada a un producto, éste será
          particionado en factores que son constantes y factores que no
          lo son, siendo entonces los constantes extraídos de la
          función.  Por ejemplo, `f(a*x)' se reducirá a `a*f(x)' siendo
          `a' una constante. Las constantes no atómicas no serán
          extraídas.

       2. Si `f' es una función de 2 o más argumentos, esta propiedad
          se define como en  `sum' o `integrate', esto es, `f (a*g(x),
          x)' se reducirá a `a * f(g(x), x)' si `a' no contiene a `x'.

     Las funciones `sum', `integrate' y `limit' han sido todas
     declaradas con la propiedad `outative'.


 -- Declaración: posfun
     La instrucción `declare (f, posfun)' declara a `f' como función
     positiva, de forma que `is (f(x) > 0)' devolverá `true'.


 -- Función: radcan (<expr>)
     Simplifica la expresión <expr>, que puede contener logaritmos,
     exponenciales y radicales, convirtiéndola a una forma canónica, lo
     que significa que todas las expresiones funcionalmente equivalentes
     se reducen a una forma única.  Ciertas expresiones, sin embargo,
     son reducidas por `radcan' a una forma regular, lo que significa
     que dos expresiones equivalentes no tienen necesariamente el mismo
     aspecto, pero su diferencia puede ser reducida por `radcan' a cero.

     Con algunas expresiones `radcan' puede consunir mucho tiempo. Este
     es el coste por explorar ciertas relaciones entre las componentes
     de la expresión para simplificaciones basadas en factorizaciones y
     expansiones parciales de fracciones de exponentes.

     Si `%e_to_numlog' vale `true', `%e^(r*log(expr))' se reduce a
     `expr^r' si `r'  es un número racional.

     Si `radexpand' vale `false', ciertas transformaciones se inhiben;
     `radcan (sqrt (1-x))' se mantiene como `sqrt (1-x)' y no se reduce
     a `%i sqrt (x-1)', o `radcan (sqrt (x^2 - 2*x + 11))' se mantiene
     como  `sqrt (x^2 - 2*x + 1)' sin reducirse a`x - 1'.

     La instrucción `example (radcan)' muestra algunos ejemplos.


 -- Variable opcional: radexpand
     Valor por defecto: `true'

     La variable `radexpand' controla algunas simplificaciones de
     radicales.

     Si `radexpand' vale `all', las raíces <n>-ésimas de los factores
     de un producto que sean potencias de <n> se extraen del símbolo
     radical. Por ejemplo, si `radexpand' vale `all', `sqrt (16*x^2)'
     se reduce a `4*x'.

     Más concretamente, considérese `sqrt (x^2)'.
        * Si `radexpand' vale `all' o se ha ejecutado `assume (x > 0)',
          `sqrt(x^2)' se reduce a `x'.

        * Si `radexpand' vale `true' y `domain' es `real' (su valor por
          defecto), `sqrt(x^2)' se reduce a `abs(x)'.

        * Si `radexpand' vale `false' o `radexpand' vale `true' y
          `domain' es `complex', `sqrt(x^2)' no se simplifica.

     Nótese que  `domain' sólo se tiene en cuenta si `radexpand' vale
     `true'.


 -- Variable opcional: radsubstflag
     Valor por defecto: `false'

     Si `radsubstflag' vale `true' se permite a `ratsubst' hacer la
     sustitución `u' por `sqrt (x)' in `x'.


 -- Declaración: rassociative
     La instrucción `declare (g, rassociative)' le indica al
     simplificador de Maxima que `g' es asociativa por la derecha.  Por
     ejemplo, `g(g(a, b), g(c, d))' se reduce a `g(a, g(b, g(c, d)))'.


 -- Función: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Es el "Sequential Comparative Simplification" (método debido a
     Stoute).  La función `scsimp' intenta simplificar <expr> de
     acuerdo con las reglas <rule_1>, ..., <rule_n>.  Si se obtiene una
     expresión más pequeña, el proceso se repite. En caso contrario,
     después de que se hayan intentado todas las simplificaciones,
     devuelve la respuesta original.

     La instrucción `example (scsimp)' muestra algunos ejemplos.


 -- Variable opcional: simpsum
     Valor por defecto: `false'

     Si `simpsum' vale `true', se simplifica el resultado de un
     sumatorio `sum'. Esta simplificación podrá producir en ocasiones
     una expresión compacta.  Si `simpsum' vale `false' o si se utiliza
     la forma apostrofada `'sum', el valor es una forma nominal que
     representa la notación sigma habitual en matemáticas.


 -- Función: sumcontract (<expr>)
     Combina todos los sumatorios de una suma cuyos límites inferiores
     y superiores difieren por constantes. El resultado es una
     expresión que contiene un sumatorio para conjunto de tales
     sumatorios. La función `sumcontract' combina todos los sumatorios
     compatibles y utiliza uno de los índices de uno de los sumatorios
     si puede, si no formará un índice que sea razonable.

     Puede ser necesario hacer `intosum (<expr>)' antes que
     `sumcontract'.


 -- Variable opcional: sumexpand
     Valor por defecto: `false'

     Si `sumexpand' vale `true', productos de sumatorios y de
     sumatorios con exponentes se reducen a sumatorios anidados.

     Véase también `cauchysum'.

     Ejemplos:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


 -- Variable opcional: sumsplitfact
     Valor por defecto: `true'

     Si `sumsplitfact' vale `false', `minfactorial' se aplica después
     de  `factcomb'.


 -- Declaración: symmetric
     La instrucción `declare (h, symmetric)' le indica al simplificador
     de  Maxima que `h' es una función simétrica.  Por ejemplo, `h (x,
     z, y)'  se reduce a `h (x, y, z)'.

     El nombre `commutative' es sinónimo de `symmetric'.


 -- Función: unknown (<expr>)
     Devuelve `true' si y sólo si <expr> contiene un operador o función
     no reconocido por el simplificador de Maxima.



File: maxima.info,  Node: Gráficos,  Next: Lectura y escritura,  Prev: Simplificación,  Up: Top

8 Gráficos
**********

* Menu:

* Funciones y variables para gráficos::


File: maxima.info,  Node: Funciones y variables para gráficos,  Prev: Gráficos,  Up: Gráficos

8.1 Funciones y variables para gráficos
=======================================

 -- Función: contour_plot (<expr>, <x_range>, <y_range>, <options>, ...)
     Dibuja las curvas de nivel <expr> en el rectángulo <x_range> por
     <y_range>.  Cualesquiera otros argumentos adicionales se tratan
     como en `plot3d'.

     `contour_plot' sólo trabaja cuando se utilizan `gnuplot' o
     `gnuplot_pipes'.

     Véase también `implicit_plot'.

     Ejemplos:

          (%i1) contour_plot (x^2 + y^2, [x, -4, 4], [y, -4, 4]);
          (%o1)
          (%i2) contour_plot (sin(y) * cos(x)^2, [x, -4, 4], [y, -4, 4]);
          (%o2)
          (%i3) F(x, y) := x^3 + y^2;
                                             3    2
          (%o3)                  F(x, y) := x  + y
          (%i4) contour_plot (F, [u, -4, 4], [v, -4, 4]);
          (%o4)
          (%i5) contour_plot (F, [u, -4, 4], [v, -4, 4],
                   [gnuplot_preamble, "set size ratio -1"]);
          (%o5)
          (%i6) set_plot_option ([gnuplot_preamble,
                                  "set cntrparam levels 12"])$
          (%i7) contour_plot (F, [u, -4, 4], [v, -4, 4]);


 -- Variable opcional: in_netmath
     Valor por defecto: `false'

     Si `in_netmath' vale `true', `plot3d' imprime salida de OpenMath
     en la consola si `plot_format' vale `openmath', en caso contrario,
     `in_netmath' (incluso si vale `true') deja de tener efecto alguno.

     La variable `in_netmath' no afecta a `plot2d'.


 -- Función: plot2d (<expr>, <x_range>, ..., <options>, ...)
 -- Función: plot2d ([<expr_1>, ..., <expr_n>], ..., <options>, ...)
 -- Función: plot2d ([<expr_1>, ..., <expr_n>], <x_range>,...,
          <options>, ...)
     Donde <expr>, <expr_1>, ..., <expr_n> pueden ser expresiones,
     funciones u operadores de Maxima o Lisp, o una lista de cualquiera
     de las siguientes formas: `[discrete, [<x1>, ..., <xn>], [<y1>,
     ..., <yn>]]', `[discrete, [[<x1>, <y1>], ..., [<xn>, ..., <yn>]]'
     o `[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Muestra un gráfico de una o más expresiones como función de una
     variable.

     La función `plot2d' representa gráficamente la expresión <expr> o
     expresiones `[<name_1>, ..., <name_n>]'. Las expresiones que no
     sean de tipo paramétrico o discreto deben depender todas ellas de
     una única variable <var>, siendo obligatorio utilizar <x_range>
     para nombrar la variable y darle sus valores mínimo y máximo
     usando la siguiente sintaxis: `[<variable>, <min>, <max>]'.  El
     gráfico mostrará el eje horizontal acotado por los valores <min> y
     <max>.

     La expresión a ser representada puede ser dada en la forma discreta
     o paramétrica, esto es, como una lista que comienza con las
     palabras `discrete' o `parametric'. La clave <discrete> debe
     seguirse de dos listas de valores, ambas de igual longitud,
     conteniendo las coordenadas horizontales y verticales del conjunto
     de puntos; alternativamente, las coordenadas de cada punto pueden
     darse como listas de dos valores, todas ellas formando a su vez
     una lista. La clave <parametric> debe seguirse de dos expresiones,
     <x_expr> y <y_expr>, junto con un rango de la forma `[<var>,
     <min>, <max>]'; ambas expresiones deben depender únicamente de la
     variable cuyo nombre aparece en el rango.  El gráfico mostrará los
     pares `[<x_expr>, <y_expr>]' según <var> varía de <min> a <max>.

     El rango del eje vertical no es necesario especificarlo. Es una más
     de las opciones de la función, siendo su sintaxis `[y, <min>,
     <max>]', mostrando entonces la gráfica el rango completo, incluso
     si la función no alcanza estos valores. En caso de no
     especificarse el rango vertical en `set_plot_option', se
     establecerá de forma automática como aquel rango en el que la
     función toma sus valores.

     Cualesquiera otras opciones deben ser listas, comenzando con el
     nombre de la opción.

     La opción <xlabel> puede utilizarse para darle una etiqueta al eje
     horizontal; si no se usa esta opción, el eje horizontal será
     etiquetado con el nombre de la variable especificada en <x_range>.

     Del mismo modo se puede asignar una etiqueta al eje vertical con
     la opción <ylabel>. Si sólo hay una expresión a ser representada y
     no se ha hecho uso de la opción <ylabel>, el eje vertical será
     etiquetado con la expresión a ser representada, a menos que sea
     muy larga, o con el texto "discrete data", en caso de gráficos de
     puntos. Si la expresión es de tipo paramétrico, las dos
     expresiones que dan las coordenadas horizontal y vertical serán
     utilizadas para etiquetar ambos ejes.

     Las opciones `[logx]' y `[logy]' no necesitan parámetros,
     permitiendo que los ejes horizontal y vertical se dibujen en la
     escala logarítmica.

     Si hay varias expresiones para ser dibujadas, se mostrará una
     leyenda que identifique a cada una de ellas. Las etiquetas a
     utilizar pueden especificarse con la opción <legend>. Si no se
     utiliza esta opción, Maxima creará etiquetas a partir de las
     expresiones.

     Por defecto, las funciones se dibujarán como un conjunto de
     segmentos lineales uniendo los puntos que bien se dan en formato
     <discrete>, o que se calculan automáticamente a partir de la
     expresión dada, de acuerdo con el tamaño muestral indicado por la
     opción <nticks>.  Asimismo, la opción <style> puede utilizarse
     para mostrar los puntos aislados, o éstos junto con los segmentos
     que los unen.

     Hay varias opciones globales almacenadas en la lista
     <plot_options>, las cuales se pueden modificar con la función
     `set_plot_option'; cualquiera de estas opciones puede ignorarse
     con las opciones que se utilicen desde el comando <plot2d>.

     Las funciones a ser representadas pueden especificarse con el
     nombre de una función u operador de Maxima o de Lisp, con una
     expresión lambda de MAxima, o con una expresión válida de maxima.
     En caso de especificarse con un nombre o expresión lambda, la
     función debe ser tal que dependa de un solo argumento.

     Ejemplos:

     Gráficos de funciones ordinarias.

          (%i1) plot2d (sin(x), [x, -5, 5])$

          (%i2) plot2d (sec(x), [x, -2, 2], [y, -20, 20], [nticks, 200])$

     Especificación de funciones por su nombre.

          (%i3) F(x) := x^2 $

          (%i4) :lisp (defun |$g| (x) (m* x x x))

          $g
          (%i5) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $

          (%i6) plot2d (F, [u, -1, 1])$

          (%i7) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Se puede representar una circunferencia como una función
     paramétrica de parámetro <t>. No es necesario especificar el rango
     del eje horizontal, pues el propio rango de <t> determina el
     dominio. No obstante, ya que las longitudes de los ejes horizontal
     y vertical están en una proporción de 4 a 3, se utilizará la
     opción <xrange> para conseguir la misma escala en ambos ejes:

          (%i8) plot2d ([parametric, cos(t), sin(t), [t,-%pi,%pi],
                       [nticks,80]], [x, -4/3, 4/3])$

     Si se repite el mismo gráfico con solo 8 puntos y se extiende el
     rango del parámetro para que dé dos vueltas, se tiene el dibujo de
     una estrella:

          (%i9) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                  [nticks, 8]], [x, -2, 2], [y, -1.5, 1.5])$

     Combinación del gráfico de un polinomio cúbico y de una
     circunferencia paramétrica:

          (%i10) plot2d ([x^3+2, [parametric, cos(t), sin(t), [t, -5, 5],
                  [nticks, 80]]], [x, -3, 3])$

     Ejemplo de gráfico logarítmico:

          (%i11) plot2d (exp(3*s), [s, -2, 2], [logy])$

     Ejemplos de gráficos de puntos, empezando por la definición de las
     coordenadas de cinco puntos en los dos formatos admisibles:

          (%i12) xx:[10, 20, 30, 40, 50]$
          (%i13) yy:[.6, .9, 1.1, 1.3, 1.4]$
          (%i14) xy:[[10,.6], [20,.9], [30,1.1], [40,1.3], [50,1.4]]$

     Representación de los puntos unidos por segmentos:

          (%i15) plot2d([discrete,xx,yy])$

     Representación de los puntos aislados, ilustrando también la
     segunda forma de especificar las coordenadas:

          (%i16) plot2d([discrete, xy], [style, points])$

     El gráfico de los puntos se puede mostrar conjuntamente con el de
     la función ter'ica que los predice:

          (%i17) plot2d([[discrete,xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, [points,3,5], [lines,1,3]],
                  [legend,"experiment","theory"],
                  [xlabel,"pendulum's length (cm)"],
                  [ylabel,"period (s)"])$

     Véase también `plot_options', que describe las opciones gráficas,
     junto con más ejemplos.


 -- Función: xgraph_curves (<list>)
     Dibuja el conjunto de puntos de la lista del argumento <list> con
     el programa xgraph. Si el programa xgraph no está instalado, este
     comando producirá un error.

     El conjunto de puntos puede ser de la forma

          [x0, y0, x1, y1, x2, y2, ...]
     o
          [[x0, y0], [x1, y1], ...]

     Un conjunto de puntos también puede contener símbolos con
     etiquetas u otra información.

          xgraph_curves ([pt_set1, pt_set2, pt_set3]);

     dibuja los tres conjuntos de puntos como tres curvas.

          pt_set: append (["NoLines: True", "LargePixels: true"],
                                    [x0, y0, x1, y1, ...]);

     construye el conjunto de puntos, declara que no haya segmentos
     rectilíneos entre ellos y que se utilicen píxeles grandes. Véase
     el manual de xgraph para más opciones.

          pt_set: append ([concat ("\"", "x^2+y")], [x0, y0, x1, y1, ...]);

     construye una etiqueta con el contenido "x^2+y" para este conjunto
     particular de puntos. Las comillas dobles `"' al comienzo son las
     que le indican a xgraph que se trata de una etiqueta.

          pt_set: append ([concat ("TitleText: Datos muestrales")], [x0, ...])$

     establece el título principal del gráfico como "Datos muestrales"
     en lugar de "Maxima Plot".

     Para hacer un gráfico de barras con columnas de 0.2 unidades de
     ancho y para dibujar dos diagramas diferentes de este tipo:
          (%i1) xgraph_curves ([append (["BarGraph: true", "NoLines: true",
                "BarWidth: .2"], create_list ([i - .2, i^2], i, 1, 3)),
                append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
                create_list ([i + .2, .7*i^2], i, 1, 3))]);

     Se utiliza un fichero temporal `xgraph-out'.


 -- Variable del sistema: plot_options
     Los elementos de esta lista establecen las opciones por defecto
     para los gráficos.  Si una opción está presente en una llamada a
     `plot2d' o a `plot3d', este valor adquiere prevalencia sobre las
     opciones por defecto.  En otro caso se utilizará el valor que
     tenga en `plot_options'.  Las opciones por defecto se asignan
     mediante la función `set_plot_option'.

     Cada elemento de `plot_options' es una lista de dos o más
     elementos, el primero de los cuales es el nombre de la opción,
     siendo los siguientes los valores de aquélla. En algunos casos el
     valor asignado es a su vez una lista, que puede contener varios
     elementos.

     Las opciones gráficas que reconocen `plot2d' y `plot3d' son:

        * Opción: `plot_format'

          Determina qué programa gráfico se va a utilizar con `plot2d'
          y `plot3d'.

             * Valor: `gnuplot' (es el valor por defecto en Windows)
               Gnuplot es el programa por defecto y el más avanzado.
               Requiere de una instalación externa de gnuplot.

             * Value: `gnuplot_pipes' (es el valor por defecto en
               sistemas distintos de Windows) Es similar al formato
               `gnuplot', excepto que la comunicación con Gnuplot se
               hace por medio de una tubería. Se debería utilizar para
               ver gráficos en pantalla; para guardar gráficos en
               srchivos, mejor utilizar el formato `gnuplot'.

             * Valor: `mgnuplot' Mgnuplot es una interfaz para Gnuplot
               basada en Tk. Se incluye en la distribución de Maxima.
               Mgnuplot ofrece una interface gráfica de usuario
               rudimentaria para gnuplot, pero tiene algunas mejoras
               respecto de la interface propia de gnuplot. Mgnuplot
               requiere de una instalación externa de gnuplot y de
               Tcl/Tk.

             * Valor: `openmath' Openmath es un programa gráfico
               escrito en Tcl/Tk. Este formato lo suministra el paquete
               Xmaxima, que se distribuye junto con Maxima; se deberá
               instalar Xmaxima si se quiere usar este formato. No sólo
               se puede utilizar Openmath desde Xmaxima, sino también
               desde cualquier otro interfaz gráfico para Maxima.


        * Opción: `run_viewer'

          Controla si el visor apropiado para la salida gráfica debe
          ejecutarse o no.

             * Valor por defecto: `true'

               Ejecuta el visor.

             * Valor: `false'

               No ejecuta el visor.

        * Opción: `y'

          Rango vertical del gráfico.

          Ejemplo:

               [y, - 3, 3]
          Establece el rango vertical como [-3, 3].

        * Opción: `plot_realpart' Si `plot_realpart' vale `true', se
          representará la parte real de un valor complejo <x>, lo cual
          equivale a representar `realpart(<x>)' en lugar de <x>.  Si
          vale `false', sólo se representarán aquellos valores con
          parte imaginaria nula, ignorando así cualesquiera valores
          complejos.

          Ejemplo:

               plot2d (log(x), [x, -5, 5], [plot_realpart, false]);
               plot2d (log(x), [x, -5, 5], [plot_realpart, true]);
          El valor por defecto es `false'.

        * Opción: `nticks'

          En `plot2d', es el número inicial de puntos utilizados por el
          procedimiento adaptativo para la representación de funciones.
          También es el número de puntos a ser calculados en los
          gráficos paramétricos.

          Ejemplo:

               [nticks, 20]
          El valor por defecto para `nticks' es 10.

        * Opción: `adapt_depth'

          Número máximo de particiones utilizado por el algoritmo
          adaptativo de representación gráfica.

          Ejemplo:

               [adapt_depth, 5]
          El valor por defecto para `adapt_depth' es 10.

        * Opción: `xlabel'

          Etiqueta del eje horizontal en gráficos 2d.

          Ejemplo:

               [xlabel, "Time in seconds"]

        * Opción: `ylabel'

          Etiqueta del eje vertical en gráficos 2d.

          Ejemplo:

               [ylabel, "Temperature"]

        * Opción: `logx'

          Hace que el eje horizontal en los gráficos 2d se dibuje en la
          escala logarítmica. No necesita de parámetros adicionales.

        * Opción: `logy'

          Hace que el eje vertical en los gráficos 2d se dibuje en la
          escala logarítmica. No necesita de parámetros adicionales.

        * Opción: `legend'

          Etiquetas para las expresiones de los gráficos 2d. Si hay más
          expresiones que etiquetas, éstas se repetirán. Por defecto se
          pasarán los nombres de las expresiones o funciones, o las
          palabras `discrete1', `discrete2', ..., para gráficos de
          puntos.

          Ejemplo:

               [legend, "Set 1", "Set 2", "Set 3"]

        * Opción: `style'

          Estilos a utilizar para las funciones o conjuntos de datos en
          gráficos 2d. A la palabra `style' debe seguirle uno o más
          estilos. Si hay más funciones o conjuntos de datos que
          estilos, éstos se repetirán. Los estilos que se admiten son:
          <lines> para segmentos lineales, <points> para puntos
          aislados, <linespoints> para segmentos y puntos, <dots> para
          pequeños puntos aislados. Gnuplot también acepta el estilo
          <impulses>.

          Cada estilo puede ir encerrado en una lista con parámetros
          adicionales: <lines> acepta uno o dos números: el ancho del
          segmento y un entero que identifica el color; <points> acepta
          uno o dos parámetros, el primero es el radio de los puntos y
          el segundo un entero que en Gnuplot selecciona diferentes
          formas y colores para los puntos y que en Openmath cambia el
          color de éstos; <linesdots> acepta hasta cuatro parámetros,
          los dos primeros son lo mismo que en <lines> y los dos
          últimos son lo mismo que en <points>.

          Ejemplo:

               [style,[lines,2,3],[points,1,4]]

          En Gnuplot, con este código se representaría la primera
          (tercera, quinta, etc.) expresión con segmentos azules de
          ancho 2, y la segunda (cuarta, sexta, etc.) expresión con
          cuadrados verdes de tama24no 1. En Openmath, la primera
          expresión se representaría con segmentos magenta de ancho 2, y
          la segunda con puntos naranja de radio 1. Nótese que
          `openmath_color(3)' y `openmath_color(4)' devuelven `magenta'
          y `orange', respectivamente.

          El estilo por defecto es <lines> de ancho 1 y diferentes
          colores.

        * Opción: `grid' Establece el número de puntos de la retícula a
          utilizar en las direcciones x e y en los gráficos de tres
          dimensiones.

          Ejemplo:

               [grid, 50, 50]

          establece la retícula en 50 por 50 puntos. El valor por
          defecto es 30 por 30.

        * Opción: `transform_xy'

          Permite que se realicen transformaciones en los gráficos de
          tres dimensiones.

          Ejemplo:

               [transform_xy, false]
          El valor por defecto de `transform_xy' es `false'. Cuando
          vale `false', da el resultado de

               make_transform([x,y,z], f1(x,y,z), f2(x,y,z), f3(x,y,z))$
          La transformación `polar_xy' está definida en Maxima.
          Devuelve la misma transformación que

               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

     Opciones de Gnuplot:

     Hay varias opciones gráficas que son específicas de gnuplot.
     Algunas de ellas son comandos propios de gnuplot que se
     especifican como cadenas alfanuméricas.  Consúltese la
     documentación de Gnuplot para más detalles.

        * Opción: `gnuplot_term'

          Establece el terminal de salida para Gnuplot.

             * Valor por defecto: `default'

               Gnuplot muestra el gráfico en una ventana gráfica.

             * Valor: `dumb'

               Gnuplot muestra el gráfico en la consola de Maxima en
               estilo ASCII artístico.

             * Valor: `ps'

               Gnuplot genera código en lenguaje PostScript.  Si a la
               opción `gnuplot_out_file' se le da el valor <filename>,
               Gnuplot escribe el código PostScript en <filename>. En
               caso contrario, se guarda en el archivo `maxplot.ps'.

             * Valor: Cualquier otro terminal admitido por Gnuplot.

               Gnuplot puede generar gráficos en otros muchos formatos,
               tales como png, jpeg, svg etc. Para crear gráficos en
               cualquera de estos formatos, a la opción `gnuplot_term'
               se le puede asignar cualquiera de los terminales
               admitidos por Gnuplot, bien por su nombre (símbolo) bien
               con la especificación completa del terminal (cadena).
               Por ejemplo, `[gnuplot_term,png]' guarda el gráfico en
               formato PNG (Portable Network Graphics), mientras que
               `[gnuplot_term,"png size 1000,1000"]' lo hace con
               dimensiones 1000x1000 píxeles.  Si a la opción
               `gnuplot_out_file' se le da el valor <filename>, Gnuplot
               escribe el código PostScript en <filename>. En caso
               contrario, se guarda en el archivo `maxplot.<term>',
               siendo <term> el nombre del terminal.


        * Opción: `gnuplot_out_file'

          Guarda el gráfico generado por Gnuplot en un archivo.

             * Valor por defecto: `false'

               No se especifica nombre de fichero.

             * Valor: <filename>

               Con `[gnuplot_out_file, "myplot.ps"]' se envía código
               PostScript al archivo `myplot.ps' cuando se utiliza
               conjuntamente con el terminal PostScript de Gnuplot.

        * Opción: `gnuplot_pm3d'

          Controla la utilización del modo PM3D, que tiene capacidades
          avanzadas para gráficos tridimensionales. PM3D sólo está
          disponible en versiones de Gnuplot posteriores a la 3.7. El
          valor por defecto de `gnuplot_pm3d' es `false'.

          Ejemplo:

               [gnuplot_pm3d, true]

        * Opción: `gnuplot_preamble'

          Introduce instrucciones de gnuplot antes de que se haga el
          dibujo. Puede utilizarse cualquier comando válido de gnuplot.
          Si interesa introducir varios comandos se separarán con punto
          y coma. El ejemplo que se muestra produce un gráfico en
          escala logarítmica. El valor por defecto de
          `gnuplot_preamble' es la cadena vacía `""'.

          Ejemplo:

               [gnuplot_preamble, "set log y"]

        * Opción: `gnuplot_curve_titles'

          Controla los títulos dados a la clave del gráfico. El valor
          por defecto es  `[default]', el cual establece
          automáticamente los títulos para cada curva representada. Si
          no es `[default]', `gnuplot_curve_titles' debe contener una
          lista de cadenas, cada una de las cuales es `"title
          '<title_string>'"'. (Para desactivar la clave del gráfico,
          añádase `"set nokey"' a `gnuplot_preamble'.)

          Ejemplo:

               [gnuplot_curve_titles, ["title 'My first function'", "title 'My second function'"]]

        * Opción: `gnuplot_curve_styles'

          Es una lista de cadenas que controlan el aspecto de las
          curvas, como el color, el ancho, la discontinuidad, etc., y
          que deben enviarse al comando `plot' de gnuplot. El valor por
          defecto es `["with lines 3", "with lines 1", "with lines 2",
          "with lines 5", "with lines 4", "with lines 6", "with lines
          7"]', que realiza un ciclo sobre un conjunto de colores
          diferentes. Consúltese la documentación de gnuplot sobre
          `plot' para más información.

          Ejemplo:

               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Opción: `gnuplot_default_term_command'

          Comando de gnuplot para establecer el tipo de terminal por
          defecto.  El valor por defecto es `set term windows "Verdana"
          15' en sistemas Windows, y `set term x11 font "Helvetica,16"'
          en sistemas X11.

          Ejemplo:

               [gnuplot_default_term_command, "set term x11"]

        * Opción: `gnuplot_dumb_term_command'

          Comando de gnuplot para establecer el tipo de terminal para
          el terminal oculto. El valor por defecto es `"set term dumb
          79 22"', que da una salida de texto de 79 por 22 caracteres.

          Ejemplo:

               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Opción: `gnuplot_ps_term_command'

          Comando de gnuplot para establecer el tipo de terminal para
          el terminal PostScript. El valor por defecto es `"set size
          1.5, 1.5;set term postscript eps enhanced color solid 24"',
          que establece un tamaño de 1.5 veces el valor por defecto de
          gnuplot, junto con un tamaño de fuente de 24, entre otras
          cosas. Consúltese la documentación de gnuplot para más
          información sobre `set term postscript'.

          Ejemplo:

          Todas las figuras de los ejemplos de la función <plot2d> de
          este manual se obtuvieron a partir de archivos Postscript
          generados asignándole a `gnuplot_ps_term_command' el valor

               [gnuplot_ps_term_command,"set size 1.3, 1.3;\
                set term postscript eps color solid lw 2.5 30"]


     Ejemplos:

        * Almacena un gráfico de `sin(x)' en el fichero `sin.eps'.

          (%i1) plot2d (sin(x), [x, 0, 2*%pi], [gnuplot_term, ps],
                                  [gnuplot_out_file, "sin.eps"])$

        * Utiliza la opción y para saltarse las singularidades, así
          como la opción `gnuplot_preamble' para colocar la clave en la
          parte inferior del dibujo.

          (%i2) plot2d ([gamma(x), 1/gamma(x)], [x, -4.5, 5], [y, -10, 10],
                               [gnuplot_preamble, "set key bottom"])$

        * Utiliza un `gnuplot_preamble' bastante complicado a fin de
          producir etiquetas en el eje x.  (Nótese que la cadena de
          `gnuplot_preamble' debe introducirse sin saltos de línea.)

          (%i3) my_preamble: "set xzeroaxis; set xtics ('-2pi' -6.283, \
          '-3pi/2' -4.712, '-pi' -3.1415, '-pi/2' -1.5708, '0' 0, \
          'pi/2' 1.5708, 'pi' 3.1415,'3pi/2' 4.712, '2pi' 6.283)"$

          (%i4) plot2d([cos(x), sin(x), tan(x), cot(x)],
                 [x, -2*%pi, 2.1*%pi], [y, -2, 2],
                 [gnuplot_preamble, my_preamble]);

        * Utiliza un `gnuplot_preamble' bastante complicado a fin de
          producir etiquetas en el eje x, produciendo una salida
          PostScript que aprovecha el formateo avanzado de texto
          disponible en gnuplot.  (Nótese que la cadena de
          `gnuplot_preamble' debe introducirse sin saltos de línea.)

          (%i5) my_preamble: "set xzeroaxis; set xtics ('-2{/Symbol p}' \
          -6.283, '-3{/Symbol p}/2' -4.712, '-{/Symbol p}' -3.1415, \
          '-{/Symbol p}/2' -1.5708, '0' 0,'{/Symbol p}/2' 1.5708, \
          '{/Symbol p}' 3.1415,'3{/Symbol p}/2' 4.712, '2{/Symbol p}' \
          6.283)"$

          (%i6) plot2d ([cos(x), sin(x), tan(x)], [x, -2*%pi, 2*%pi],
              [y, -2, 2], [gnuplot_preamble, my_preamble],
              [gnuplot_term, ps], [gnuplot_out_file, "trig.eps"]);

        * Un gráfico tridimensional utilizando el terminal pm3d de
          gnuplot.

          (%i7) plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [grid, 50, 50], [gnuplot_pm3d, true])$

        * Un gráfico tridimensional sin malla y con contornos
          proyectados sobre el plano inferior.

          (%i8) my_preamble: "set pm3d at s;unset surface;set contour;\
          set cntrparam levels 20;unset key"$
          (%i9) plot3d(atan(-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [grid, 50, 50], [gnuplot_pm3d, true],
              [gnuplot_preamble, my_preamble])$

        * Un gráfico en el que el eje z sólo se representa por el color.
          (Nótese que la cadena de `gnuplot_preamble' debe introducirse
          sin saltos de línea.)

          (%i10) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [gnuplot_preamble, "set view map; unset surface"],
              [gnuplot_pm3d, true], [grid, 150, 150])$


 -- Function: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>,
          <y_range>, ..., <options>, ...)
 -- Función: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Función: plot3d (<name>, <x_range>, <y_range>, ..., <options>, ...)
 -- Función: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_rge>, <y_rge>)
 -- Función: plot3d ([<name_1>, <name_2>, <name_3>], <x_range>,
          <y_range>, ..., <options>, ...)
     Representa gráficamente una o tres expresiones como funciones de
     dos variables.

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2]);

     dibuja `z = 2^(-u^2+v^2)' con `u' y `v' variando en [-3,3] y
     [-2,2] respectivamente, y con <u> sobre el eje x, y con `v' sobre
     el eje y.

     El mismo gráfico se puede dibujar usando openmath (si Xmaxima fué
     instalado):

          (%i2)  plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2],
                         [plot_format, openmath]);

     en este caso el ratón se puede usar para rotar el gráfico y ver la
     superficie desde diferentes lados.

     Un ejemplo del tercer patrón de argumentos es

          (%i3) plot3d ([cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)),
             y*sin(x/2)], [x, -%pi, %pi], [y, -1, 1], ['grid, 50, 15]);

     que dibuja una banda de Moebius, parametrizada por las tres
     expresiones dadas como primer argumento a `plot3d'. Un argumento
     opcional `['grid, 50, 15]' da el número de intervalos en las
     direcciones x e y, respectivamente.

     Cuando la función a representar ha sido definida en Maxima
     mediante  `:=' o `define', o en Lisp por DEFUN o DEFMFUN, entonces
     se podrá especificar por su nombre. Las funciones definidas a
     nivel de LISP por DEFMSPEC, las funciones de simplificación, junto
     con muchas otras funciones, no pueden especificarse directamente
     por su nombre.

     Este ejemplo muestra un gráfico de la parte real de `z^1/3'.

          (%i4) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                ['grid, 12, 80], ['transform_xy, polar_to_xy]);

     Otros ejemplos son la botella de Klein:

          (%i5) expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0) - 10.0$
          (%i6) expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0)$
          (%i7) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$

          (%i8) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                [y, -%pi, %pi], ['grid, 40, 40]);

     y un toro:

          (%i9) expr_1: cos(y)*(10.0+6*cos(x))$
          (%i10) expr_2: sin(y)*(10.0+6*cos(x))$
          (%i11) expr_3: -6*sin(x)$
          (%i12) plot3d ([expr_1, expr_2, expr_3], [x, 0, 2*%pi],
                 [y, 0, 2*%pi], ['grid, 40, 40]);

     En ocasiones puede ser necesario definir una función para
     representarla. Todos los argumentos de `plot3d' se evalúan, de
     manera que puede ser difícil escribir una expresión que haga lo
     que el usuario realmente quiere; en tales casos facilita las cosas
     definir previamente la función.

          (%i13) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                 [1, 2, 3, 3])$
          (%i14) f(x, y) := float (M [?round(x), ?round(y)])$
          (%i15) plot3d (f, [x, 1, 4], [y, 1, 4], ['grid, 4, 4])$

     Véase  `plot_options' para más ejemplos.


 -- Función: make_transform (<vars>, <fx>, <fy>, <fz>)
     Devuelve una función apropiada para la función de transformación
     de `plot3d'. Debe usarse con la opción gráfica `transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     es una transformación para pasar a coordenadas polares.

 -- Función: set_plot_option (<option>)
     Asigna un valor a una de las variables globales que controlan los
     gráficos. El argumento <option> se especifica como una lista de
     dos o más elementos, en la que el primero es el nombre de una de
     las opciones de la lista `plot_options'.

     La función `set_plot_option' evalúa sus argumentos y devuelve
     `plot_options' tal como queda después de la actualización.

     Véanse también `plot_options', `plot2d' y `plot3d'.

     Ejemplos:

     Se modifican los valores de `grid' y `x'.  Si a un nombre de
     opción de `plot_options' tiene ya un valor asignado, hacerlo
     preceder de un apóstrofo para evitar su evaluación.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]


   Funciones para trabajar con el formato gnuplot_pipes:

 -- Función: gnuplot_start ()
     Inicializa una tubería hacia Gnuplot, con el fin de ser utilizada
     para utilizar el formato `gnuplot_pipes'.  No es necesario
     inicializarla manualmente antes de hacer gráficos.


 -- Función: gnuplot_close ()
     Cierra la tubería hacia Gnuplot que haya sido utilizada para hacer
     gráficos.


 -- Función: gnuplot_restart ()
     Cierra la tubería hacia Gnuplot que haya sido utilizada para hacer
     gráficos e inicializa una nueva.


 -- Función: gnuplot_replot ()
 -- Función: gnuplot_replot (<s>)
     Actualiza la ventana de Gnuplot. Si `gnuplot_replot' es invocada
     con un comando de Gnuplot en la cadena <s>, entonces <s> es
     enviada a Gnuplot antes de redibujar la ventana.


 -- Función: gnuplot_reset ()
     Resetea Gnuplot cuando se utiliza el formato `gnuplot_pipes'.
     Para actualizar la ventana de Gnuplot invóquese a `gnuplot_replot'
     después de `gnuplot_reset'.



File: maxima.info,  Node: Lectura y escritura,  Next: Aritmética de punto flotante,  Prev: Gráficos,  Up: Top

9 Lectura y escritura
*********************

* Menu:

* Comentarios::
* Archivos::
* Funciones y variables para lectura y escritura::


File: maxima.info,  Node: Comentarios,  Next: Archivos,  Prev: Lectura y escritura,  Up: Lectura y escritura

9.1 Comentarios
===============

En Maxima, un comentario es cualquier texto encerrado entre las marcas
`/*' y `*/'.

   El analizador sintáctico de Maxima trata los comentarios como
espacios en blanco a efectos de encontrar tokens en el flujo de
entrada. Una entrada tal como `a/* foo */b' contiene dos tokens, `a' y
`b', no un único token `ab'.  En cualquier otro contexto, los
comentarios son ignorados por Maxima; no se almacenan ni sus contenidos
ni sus localizaciones.

   Los comentarios pueden anidarse hasta una profundidad arbitraria.
Las marcas  `/*' y `*/' deben emparejarse y debe haber igual número de
ambos.

   Ejemplos:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Archivos,  Next: Funciones y variables para lectura y escritura,  Prev: Comentarios,  Up: Lectura y escritura

9.2 Archivos
============

Un archivo no es más que una área de un cierto dispositivo de
almacenamiento que contiene datos o texto.  Los archivos se agrupan en
los discos en "directorios", que son listas de archivos.  Instrucciones
que operan con archivos son: `save', `load', `loadfile', `stringout',
`batch', `demo', `writefile', `closefile' y `appendfile'.



Local Variables:
coding: iso-8859-1
End:
